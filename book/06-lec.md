---
title: "Лекция 6. Оператор выборки данных SELECT"
layout: bookpage
lang: ru
navigation_weight: 6
---

# Оператор выборки данных SELECT

## 6.1. Общие сведения об операторе выборки данных SELECT

SQL-оператор SELECT является одним из самых важных в БД. Основной задачей оператора является извлечение данных из таблиц согласно условию, которое поставил пользователь. Современные информационные системы оперируют столь большим числом записей, что производительность SQL-оператора SELECT является одной из важнейших характеристик СУБД.

Оператор SELECT состоит из нескольких предложений или клауз (термин “клауза” – от английского слова clause – предложение), каждая из которых выполняет определенные действия. Порядок следования предложений и их формат четко определены, но только несколько предложений являются обязательными, остальные можно использовать по необходимости.

Вот общий вид SQL-оператора SELECT:
```sql
SELECT [ ALL | DISTINCT ] определение_полей
FROM определение таблиц
[ WHERE условие ]
[ GROUP BY условие_группировки [ HAVING условие ] ] [ ORDER BY условие_сортировки ]
```
Как	обычно	необязательная	часть	выделяется	квадратными скобками.



Оператор SELECT может содержать 6 предложений:

1. SELECT – определяет набор полей, которые требуется получить в результате запроса (ALL - повторяющиеся строки присутствуют, DISTINCT - отсутствуют).
2. FROM – определяет набор таблиц, откуда извлекается результат.
3. WHERE – определяет условие извлечения данных.
4. GROUP BY – определяет условие группировки данных.
5. HAVING – определяет условие внутри группировки.
6. ORDER BY – определяет поля и порядок сортировки.

Предложение SELECT оператора SELECT определяет набор полей, которые будут формировать результирующую таблицу. В качестве поля могут быть заданы:

1. поля таблиц;
2. простейшее выражение или SQL-выражение;
3. агрегатная функция, где в качестве аргумента, используется поле или SQL-выражение.

Для	задания	полей	могут	быть	использованы	следующие нотации:

1. “\*” – все поля всех таблиц, которые участвуют в запросе;
2. имя_поля – обозначает поле с именем “имя_поля”;
3. имя_таблицы.имя_поля – обозначает поле с именем “имя_поля”
таблицы “имя_таблицы” (или псевдоним.имя_поля);
4. SQL-выражение – SQL-выражения, куда входят поля таблиц. Каждый	производитель	СУБД	определяет	термин	“SQL-выражение” по своему, но в соответствии со стандартом ANSI SQL понятие SQL-выражения определено так.

SQL-выражениями являются:

1. выражения с арифметическими операциями “плюс”, “минус”, “умножить”, “разделить”, где в качестве аргументов используются поля таблиц БД или константы.
2. SQL-функция, в качестве аргумента которой используется поле таблицы базы, константа или их комбинация с помощью арифметических операций.
3. комбинации с помощью арифметических операций полей таблиц и вызовов SQL-функций.

Примеры SQL-выражений.
```sql
a+b
SIN(a + b) SIN(a) + SIN(b) SIN(1)
SIN(a) + 1
```
В данном примере a и b – являются полями некоторой таблицы БД. SIN и COS – функции получения синуса и косинуса.
`COS(a) + SIN(b) + a + 1`

Любая современная СУБД содержит в своем составе большое количество стандартных функций, которые могут быть использованы в операторе SELECT при извлечении данных из БД. Использование таких функций в ряде случаев оказывается очень эффективным, потому что экономит время при разработке ПО и значительно ускоряет процесс получения конечного результата, за счет того, что SQL-оператор SELECT выполняется на сервере, который, как правило, обладает значительно большей мощностью, чем рабочая станция пользователя. Позже будет рассмотрен набор стандартных функций СУБД.

## 6.2. Предложение FROM оператора SELECT

Предложение SELECT рассматривать не закончили, но продолжать не можем, потому что самый простой SQL-оператор SELECT всегда содержит в своем составе и предложение FROM, которое задает таблицы, участвующие в запросе.

В SQL-операторе SELECT может быть задано столько таблиц, сколько необходимо для выполнения текущей задачи извлечения данных, что позволяет создавать эффективные операторы SELECT, которые сильно упрощают работу по обработке данных.

Форма задания одной таблицы следующая: 
```sql
FROM имя_таблицы [псевдоним]
```

Если необходимо извлечь данные из нескольких таблиц, то они перечисляются через запятую:
```sql
FROM	имя_таблицы1	[	псевдоним1],	имя_таблицы2	[
псевдоним2], ...
```
Для каждой таблицы можно определить ее псевдоним, который действует в рамках всего SQL-оператора SELECT. Псевдоним позволяет сократить определение полей, поскольку при проектировании базы правильным считается задание такого имени таблицы, которое бы отражало сущность хранимых в ней данных. Так если необходимо хранить информацию о студентах, то логично назвать таблицу именем “Student”. Однако при дальнейшем использовании этого имени SQL-оператор SELECT значительно увеличивается в размерах, что приводит к трудностям при его прочтении и, как следствие, ведет к ошибкам. Поэтому для такой таблицы в рамках данного оператора вводится псевдоним, например “S”:
```sql
SELECT S.name FROM Student S
```
Данный оператор извлекает из таблицы “Student” имена студентов не сортируя их. SQL-оператор INSERT всегда вставляет данные в БД в порядке их поступления с целью снижения расходов связанных с помещением данных на накопитель информации. SQL- оператор SELECT всегда обрабатывает данные в том порядке, в котором они были сохранены.

Рассмотренный оператор содержит некоторое количество избыточных конструкций. В одной таблице не может существовать несколько полей с одинаковыми именами, следовательно, явное указанием имени таблицы при задании поля в предложении SELECT не требуется, точно так же как и использование псевдонима имени таблицы. Следовательно, приведенный выше оператор можно записать так:
```sql
SELECT name FROM Student
```
Обе приведенные версии являются абсолютно правильными.

Рассмотрим использование специальной нотации “\*” при задании полей таблиц. Символ “\*”, указанный в клаузе SELECT, обозначает все поля всех таблиц, которые указаны в предложении FROM. Таким образом, чтобы получить содержимое всей таблицы “Student” достаточно написать так:
```sql
SELECT * FROM Student - просмотр всех полей таблицы
“Student”
```
Такая форма оператора используется только при разработке программного обеспечения. При написании программы правильным стилем является явное указание всех полей, которые формируют результирующую таблицу SQL-оператора SELECT. Это связанно с возможным расширением набора полей таблицы в будущем. Если такое произойдет, то неверное задание SQL-операторов может привести к большим трудностям при доработке программного обеспечения. Порядок следования полей в таком операторе определяется порядком следования полей в SQL-операторе CREATE TABLE.

Предложение SELECT позволяет задавать несколько полей, перечисляя их через запятую.

Пример. Получить информацию о том, у какого студента какой средний бал (поле sr_ball).
```sql
SELECT name, sr_ball FROM Student 
```
Пример. Перестановка выводимых столбцов. 
```sql
SELECT sr_ball, name FROM Student
```
Пример - иллюстрирует преимущества задания псевдонимов для таблиц запроса. Предположим, что существует таблица “Groups”, которая содержит информацию о группах студентов (рисунок 6.1). В таблице “Student” существует внешний ключ, связанный с первичным ключом таблицы “Groups”. Если поле отображает имя группы, то соответственно мы называем его “name”. Но точно так же мы называем поле, которое хранит имя студента.

(pic)

Рисунок 6.1 − Модель БД из двух таблиц

Теперь пусть необходимо получить информацию о том, какой студент учится в какой группе. Вот так написать запрос нельзя:
```sql
SELECT name, name FROM Groups, Student
```
потому что сервер БД не сможет понять поля “name” каких таблиц необходимо получить в результате. В таком случае на помощь приходит форма явного задания имени таблицы при задании поля в предложении SELECT:
```sql
SELECT Student.name, Groups.name FROM Groups, Student
```
Недостатком данного оператора является длинная запись. Здесь становиться очевидным преимущество использования псевдонимов при задании имени таблицы. Тот же самый оператор можно записать и так:
```sql
SELECT s.name, g.name FROM Groups g, Student s
```
Такой оператор выглядит несколько короче и при этом не потерял своего читабельного вида. Не должно смущать то, что определение псевдонимов для таблиц идет после предложения SELECT, в которой эти псевдонимы уже используются. Разбор SQL- оператора SELECT СУБД выполняет таким образом, что псевдонимы уже определены на этапе проверки предложения SELECT. Поэтому приведенная запись является абсолютно правильной.

Какой псевдоним выбирать для какой таблицы – дело личного вкуса и предпочтений. Псевдоним может состоять из любого количества символов. На практике, при работе с большой базой используют двухбуквенные обозначения, чтобы псевдонимы все-таки отражали таблицы и оператор не потерял читабельности. В простых операторах достаточно и одного символа, чтобы покрыть все имена таблиц запроса.

Рассмотренный запрос демонстрирует еще одно важное свойство оператора SELECT – возможность задания и использования нескольких таблиц. В данном случае использованы 2 таблицы, но можно задать и большее число таблиц. Все зависит от конкретной операции над данными. И сразу возникает вопрос, ведь никто не требует, чтобы таблицы “Groups” и “Student” содержали одинаковое количество данных. Тогда каким образом будет выглядеть результат предыдущего запроса?

Пусть в таблице “Groups” хранится информация о двух группах – в первой с именем “535” 2 студента, а во второй с именем “535а” тоже 2 студента. Пусть таблица “Groups”имеет вид:

(pic)

Пусть таблица “Student”имеет вид:

(pic)

При выполнении SQL-оператора
```sql
Select s.name,g.name From Groups g, Student s
```
база данных “склеит” данные таблиц таким образом, чтобы в результате получилась таблица в первой нормальной форме. Такая “склейка” выполняется после многократного повторения информации одной таблицы, в которой записей меньше, с другой, в которой записей больше. Таким образом, будет получен вот такой результат выполнения данного оператора Select:

| name    | name |
|---------|------|
| Иванов  | 535  |
| Петров  | 535  |
| Сидоров | 535  |
| Семенов | 535  |
| Иванов  | 535а |
| Петров  | 535а |
| Сидоров | 535а |
| Семенов | 535а |

Очевидно,	что	такой	результат	не	отвечает	требованию	- получить информацию о том, какой студент учится в какой группе.

На самом деле результат работы этого оператора может быть совсем другой. Для решения поставленной задачи вывода информации о том, в какой группе какой студент учится, нужно явным образом с помощью предложения WHERE задать условие связи таблиц “Groups” и “Student” и тогда оператор выведет действительно ту информацию, которая нам необходима. Но как это делается, рассмотрим чуть позже.

Оператор SELECT допускает использование в целевом списке вычисляемых полей. Если требуется вычислить значение какого-либо выражения, даже не связанного с БД, может быть использован оператор SELECT.

Пример. SELECT exp(3.1) - возвращает значение 22,1979….

Теперь рассмотрим еще одну сознательно опущенную опцию задания полей в предложении SELECT. Попробуем решить следующую задачу. Если таблица “Student” имеет поле “sr_ball”, которое содержит средний бал студента, то можно вывести для каждого студента не значение этого среднего бала, а показатель его успеваемости в процентах. Пусть “отлично” - это 100%. Путем нехитрых вычислений можно вывести вот такую формулу, которая позволит оценить успеваемость студента:
```sql
усп = sr_ball * 100 / 5
```
Данная формула является классическим SQL-выражением. А это значит, что можно написать SQL-оператор SELECT, который даст информацию об успеваемости студента:
```sql
SELECT name, sr_ball * 100 / 5 FROM Student
```
Поскольку мы работаем с одной таблицей, то при задании имени поля указывать имя таблицы не нужно.

Но возникает следующий вопрос, какое имя будет иметь поле, содержащее успеваемость студента? Первое поле будет называться “name”, а имя второго – СУБД MS SQL Server сгенерирует как No column name.

(pic)

Чтобы такого не произошло, можно указать в предложении SELECT имя для поля явным образом. Это делается с помощью выражения:

`имя_поля_таблицы AS новое_имя_поля `

Таким образом, можно написать следующее:
```sql
SELECT name AS name, sr_ball * 100 / 5 AS sr_ball FROM student
```
Теперь имена полей определены и можно на них ссылаться в дальнейшем при обработке результата работы оператора SELECT в программе. При задании имени поля с помощью AS можно использовать любые символы, которые могут образовывать не только слова, но и словосочетания. Если в наименовании поля содержится символ “пробел”, то его можно взять в одинарные кавычки. Это позволяет писать вот такие операторы SELECT:
```sql
SELECT name AS 'Ф.И.О.',
sr_ball * 100 / 5 AS 'Успеваемость(%)' FROM Student
```

(pic)

Данный оператор демонстрирует еще одну технику записи SQL- оператора SELECT. Вероятность того, что SQL-оператор SELECT не влезет в одну строку довольно высока. Согласно определению SQL- оператор может быть многострочным. Поэтому, если оператор длинный и не помещается в одну строку, то его записывают в несколько строк, используя отступы для повышения читабельности самого оператора, как это делается и в обычных программах. При этом предложения записывают друг под другом, а их аргументы с некоторым сдвигом влево, чтобы отделить предложения от аргументов.

Будет выполнен также и такой запрос, то есть связка AS при работе с псевдонимом не обязательна.
```sql
SELECT name 'Ф.И.О.', sr_ball * 100 / 5 'Успеваемость(%)' FROM Student
```

(pic)

оследними опущенными пока параметрами предложения SELECT являются DISTINCT или ALL. Параметр *DISTINCT* удаляет из результирующей таблицы повторяющиеся записи. Параметр *ALL*, который задан по умолчанию, оставляет результирующую таблицу в том виде, в котором она получилась после склейки значений полей:
```sql
SELECT DISTINCT name AS 'Ф.И.О.',
sr_ball * 100 / 5 AS 'Успеваемость (%)'
FROM Student
```
Если предположить, что поле name содержит только фамилию, то такой оператор удалит однофамильцев с одинаковой успеваемостью.

DISTINCT отслеживает, какие значения появились в списке выходных данных, и исключает из него дублирующиеся значения.

Параметр DISTINCT можно задать только один раз для данного предложения SELECT. Если SELECT извлекает множество полей, то он исключает строки, в которых все выбранные поля идентичны. Строки, в которых некоторые значения одинаковы, а другие — различны, включаются в результат. DISTINCT, фактически, действует на всю выходную строку, а не на отдельное поле (исключение составляет его применение внутри агрегатных функций), исключая возможность их повторения.

Размещение	текста	в	выводе	запроса	осуществляется следующим образом
```sql
SELECT DISTINCT name AS 'Ф.И.О.',
stip AS 'Стипендия', ‘грн.’
FROM Student;
```

Вывод этого запроса имеет следующий вид:

| Ф.И.О. | Стипендия | (No column |
|--------|-----------|------------|
| Иванов | 200.80    | грн.       |
| Петров | 250.85    | грн.       |
| …      | …         | …          |

Выводы:
1. Любой SQL-оператор SELECT должен иметь в своем составе предложение SELECT, задающее результирующие поля, и предложение FROM, определяющую набор таблиц, участвующих в запросе.
2. При задании поля можно использовать SQL-выражения и определить для каждого поля его новое имя с помощью выражения AS.
3. С целью сокращения записи оператора и повышения его читабельности, для таблиц можно задать краткие псевдонимы, которые действуют в рамках всего SQL-оператора SELECT.

## 6.3. Предложение WHERE оператора SELECT

Особенности предложения WHERE:
1. Предложение WHERE задает условие извлечения данных из таблиц(ы). Предложение WHERE команды SELECT позволяет определить предикат, то есть условие, которое может быть либо истинным, либо ложным для каждой строки таблицы.
2. Команда извлекает только те строки из таблицы, для которых предикат имеет значение ” истина”.
3. С помощью этой клаузы явным образом задается связь между таблицами базы (условия связи), а так же дополнительные условия (условия выборки), которые требуются для успешной реализации оператора SELECT.

Рассмотрим	предыдущий	пример	с	таблицами	“Groups” и “Student”.  Таблица  “Student”  имеет  в  своем  составе  внешний ключ, который ссылается на первичный ключ таблицы “Groups”. При создании таблиц БД, эта ссылка вылилась в конкретные клаузы оператора CREATE TABLE. СУБД не выполняет автоматически связи между таблицами, связь нужно задавать явным образом при выполнение каждого SQL-оператора SELECT. Только это может гарантировать правильность результата. Таким образом, рассмотренный ранее оператор нужно записать вот так:
```sql
SELECT s.name AS 'Ф.И.О. студента', g.name AS 'Имя группы'
FROM Groups g, Student s WHERE g.id = s.id_group
```
Здесь в оператор SELECT добавлено предложение WHERE, в котором четко определено, что идентификатор группы в таблице “Student” должен совпадать с идентификатором группы в таблице “Groups”. С первого взгляда кажется, что это условие является не нужным. Но его наличие гарантирует нам правильный результат. Ведь отсутствие этого условия дает право СУБД склеить таблицы в порядке создания записей, а не в порядке принадлежности студентов к группе.

Следующим важным моментом этого оператора является использование полей “id” и “id_group” в условии клаузы WHERE при их отсутствии в клаузе SELECT. Право обращаться к этим полям нам дает не их перечисление в клаузе SELECT, а перечисление таблиц, в которые они входят, в предложении FROM. Всегда нужно помнить о том, что предложение SELECT определяет поля, которые будут в результирующей таблице, но не определяет набор полей, который можно использовать в выражениях других клауз SQL-оператора SELECT.
Для задания условий используются следующие операции отношений (реляционные операции сравнения):
1. = - “равно”,
2. < > - “не равно” (или !=),
3. \>     - “больше”,
4. <     - “меньше”,
5. \> =  - “больше или равно”,
6. < =  - “меньше или равно”,
7. ! >  - “ не меньше”,
8. ! <  - “ не больше”.

*Пример*. Запрос на просмотр из БД информации об успеваемости студента Иванова.
```sql
SELECT name AS 'Ф.И.О.',
sr_ball * 100 / 5 AS 'Успеваемость (%)' FROM Student
WHERE name = ‘Иванов’
```
*Пример*. Запрос на просмотр из БД информации о студентах, получающих стипендию.
```sql
SELECT name AS 'Ф.И.О.',
stip AS 'Стипендия' FROM Student
WHERE stip >0
```
Рассмотренные условия принадлежит к типу условий, которые часто называют условиями выборки.

Стандартные булевы операторы SQL, − это AND, OR, NOT. Существуют и другие, более сложные булевы операторы (как, например, ”исключающее ИЛИ”), но их можно построить с помощью трех указанных булевых операторов. Булева логика ”истина/ложь” представляет полный базис для работы цифрового компьютера. Поэтому фактически весь SQL можно свести к булевой логике. Далее перечислены булевы операторы и основные принципы их действия:

- AND (операция “логическое И”) берет два булевых выражения (в виде A AND B) в качестве аргументов и дает в результате истину, если они оба истинны.
- OR (операция “логическое ИЛИ”) два булевых выражения (в виде A OR B) в качестве аргументов и оценивает результат как истину, если хотя бы один из них истинен.
- NOT берет единственное булево выражение (в виде NOT A) в качестве аргумента и изменяет его значение с истинного на ложное или с ложного на истинное.

Операции AND и OR являются бинарными: 

```sql
условие1 AND условие2
условие1 OR условие2
условие1 AND условие2 OR условие3.
```
Операции AND, OR и NOT можно комбинировать в одну последовательность, создавая требуемое условие выборки данных.
*Пример*. Выбрать из таблицы Student студентов, у которых средний балл не ниже 3 и которые принадлежат группе номер 5.
```sql
SELECT name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’, Id_Group FROM Student
WHERE sr_ball >=3 And Id_Group=5
```
*Пример*. Выбрать из таблицы Student студентов, у которых средний балл не ниже 3 и которые не принадлежат группе номер 1.
```sql
SELECT Id, name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’, Id_Group FROM Student
WHERE Not (sr_ball <3 And Id_Group=1)
```
Булевский оператор помещается перед реляционным оператором, на который он действует, а при необходимости расширения действия используются скобки. В этом случае SQL понимает круглые скобки как означающие, что все внутри них будет оцениваться первым и обрабатываться как единое выражение с помощью того оператора, который находится снаружи.

(pic)

(pic)

(pic)

Вернемся к типу условий, которые могут существовать в предложении WHERE. Расширим пример с группами и студентами, добавив к нему отношение “факультет”. Таблица будет называться “Facility” (рисунок 6.2). Поскольку факультет состоит из нескольких групп, которые в свою очередь состоят из студентов, то не трудно понять, что группа связана с факультетом посредством внешнего ключа, который ссылается на первичный ключ факультета. Пусть это поле в таблице “Groups” называется “Id_Facility”.

(pic)

Рисунок 6.2 − Диаграмма таблиц базы данных 

Составим запрос, который выводит списки студентов факультета с именем “ФРТСЛА”. Студенты связаны с факультетом косвенно, через группы, поэтому SQL-оператор SELECT будет выглядеть вот так:
```sql
SELECT f.name AS 'Факультет', s.name AS 'Ф.И.О. Студента' FROM Facility f, Groups g, Student s
WHERE f.id=g.id_facility AND g.id=s.id_groups AND f.name='ФРТСЛА'
```
Данный оператор содержит в предложении WHERE 2 условия связи и одно условие выборки. Все три условия объединяет оператор AND.

Если посмотреть на рисунок взаимодействия таблиц базы данных, то можно увидеть, что линий, которые показывают связи между группами две. Именно поэтому существует два условия связи: первое и второе. Третье условие выполняет фильтрацию данных согласно поставленной задачи.

Если связываются несколько таблиц между собой, то всегда существуют условия связи, которых на одно меньше, чем количество таблиц, участвующих в запросе. Знание этого правила позволяет смотреть на сложные операторы немного по-другому. При создании таких операторов необходимо помнить, что нужно задать условия выборки и некоторое количество условий связи. Причем условия связи формируются автоматически – посчитали количество таблиц (можно так же считать количество линий связи на диаграмме) и создали соответствующие условия, объединив их по “И”. А затем приступаем к размышлениям о том, какие должны быть условия выборки. Хотя можно делать и наоборот – сосредоточиться на условиях выборки, а затем автоматически добавить к ним условия связи. Для группирования условий с целью изменения порядка операций можно использовать круглые скобки:
```sql
SELECT f.name AS 'Факультет', s.name AS 'Ф.И.О. Студента' FROM Facility f, Groups g, Student s
WHERE (f.id=g.id_facility AND g.id=s.id_groups) AND f.name='ФРТСЛА'
```
Порядок приоритета операций − сначала AND, а затем OR. В данном примере использование скобок излишество, но его основная цель – продемонстрировать синтаксическую конструкцию использования круглых скобок.

Вернемся к нашей задаче − вывести список студентов факультета “ФРТСЛА”. Существует еще несколько способов ее решения. Исходя из определения внешнего ключа и правила ссылочной целостности, в поле id_facility таблицы Groups содержится уникальный идентификатор факультета, к которому принадлежит эта группа. Следовательно, если мы его знаем, то можем решить поставленную задачу вот так:
```sql
SELECT s.name AS 'Ф.И.О. Студента' FROM Groups g, Student s
WHERE g.id=s.id_groups AND g.id_facility=5
```
Этот оператор связывает всего две таблицы, но при этом так же решает поставленную задачу.

Однако никто не просил нас вывести вместе с именем студента еще и название факультета, на котором он учится. Очевидно, что данный запрос будет выполняться быстрее чем предыдущий.

В большинстве случаев данный оператор является идеологически неправильным. Почему? Пользователь всегда работает с информационной системой через интерфейс. Задача интерфейса – упросить работу пользователя и сделать ее максимально приближенной к понятиям той предметной области, которую он обслуживает. Студенты “ХАИ” знают, что номер факультета “ФРТСЛА” − 5. Но во всех официальных документах студенты учатся не на 5 факультете, на факультете “ФРТСЛА”. Поэтому интерфейс предоставляет список названий факультетов, а не их первичных ключей. Ни в коем случае нельзя вводить в алгоритм работы системы правило, что первичный ключ связан с другими полями таблицы. Это грубейшее нарушение НФБК. Наоборот, другие поля зависят только от первичного ключа. Поэтому получается следующая картина: пользователь выбирает в списке факультет “ФРТСЛА” и мы автоматически приходим к оператору, который был рассмотрен первым.

Ограничение на работу предложения WHERE. В предложении WHERE нельзя использовать агрегатные функции (если только не применяется подзапрос), поскольку предикаты оцениваются в терминах	единственной	строки,	тогда	как	агрегатные	функции оцениваются в терминах групп строк.

## Контрольные вопросы

1. К каким языкам относится язык SQL?
2. Какие формы языка SQL существуют?
3. Каковы компоненты языка SQL?
4. Каковы основные предложения языка SQL?
5. Каков синтаксис оператора SELECT?
6. Каковы основные особенности использования предложения
SELECT?
7. Каковы основные особенности использования предложения
FROM?
8. Каковы основные особенности использования предложения
WHERE?
9. Каковы особенности использования предложений GROUP BY и HAVING?
10. Каковы основные особенности использования предложения
ORDER BY?
11. Каковы основные правила работы с псевдонимами в SQL?

