---
title: "Лекция 13. Формирование многотабличных запросов"
layout: bookpage
lang: ru
--- 

# Лекция 13. Формирование многотабличных запросов

Работа с нормализованными таблицами - данные распределяются по многочисленным небольшим таблицам в целях устранения повторяющихся данных.

**Объединение** (соединение, многотабличный запрос) полностью предназначено для обеспечения выборки данных из нескольких таблиц и включения этих данных в один результирующих набор.

Одна из наиболее мощных SQL-операций для реляционных БД

С помощью соединений непосредственно связывается информация, содержащаяся:

- в нескольких таблицах,
- между отдельными частями одной таблицы.

Объединение таблиц - три способа:

- предложением UNION (объединение, союз) – внешнее *объединение*,
- с помощью установления связей между таблицами в предикате запроса (в условии организованном предложением WHERE) – *внутреннее объединение*
- оператором объединения JOIN – *внутреннее* и *внешнее объединения*.

Предложение UNION используется для:

- размещения нескольких запросов вместе,
- объединения их вывода.

Предложение UNION объединяет вывод двух или более запросов в единый набор строк и столбцов.

**Пример.** Получить список всех студентов и преподавателей, фамилии которых заключены между буквами "K" и "C".

```sql
SELECT S_FAM AS "Фамилия", S_NAME AS "Имя" FROM STUDENT 
	WHERE S_FAM BETWEEN "K" AND "C"
		UNION
			SELECT T_FAM, T_NAME FROM TEARCHER
				WHERE T_FAM BETWEEN "K" AND "C"

```

**Особенности** работы с UNION:

- в MS SQL Server заголовок столбцов формируется первым запросом;
- при объединении столбцы должны быть *совместимы* для *объединения*, то есть необходимость включения в запросе *одинакового числа столбцов* в одинаковом порядке, должна присутствовать *совместимость типов*, если пустые значения NULL запрещены в каком-либо столбце объединения, то они должны быть запрещены и во всех остальных столбцах;
- предложение UNION автоматически исключает дубликаты строк из вывода (UNION ALL сохраняет дубликаты).
- предложение ORDER BY применяется и для упорядочения выходных данных объединения. Задание упорядочения осуществляется *по номеру столбца*.

```sql
SELECT S_FAM, S_NAME FROM STUDENT
	UNION
SELECT T_FAM, T_NAME FROM TEARCHER
	ORDER BY 2 ASC
```

Число 2 в предложении `ORDER BY` задаёт номер столбца в упорядоченном списке предложения `SELECT`.

## Внутреннее объединение таблиц

### 1. Объединение двух таблиц с помощью установления связей.

**Пример.** Выбрать из таблиц `Teacher` (`id` (код_преподавателя - первичный ключ), `name` (имя_преподавателя), `id_dep` (код_кафедры)) и `Subject` (`id` (код_предмета), `name` (имя_предмета), `id_Teach` (код_преподавателя - внешний ключ)) информацию о преподавателях (ФИО) и дисциплинах (Предмет), которые преподаватель ведет.

```sql
SELECT T.Name AS "ФИО", S.Name AS "Предмет"
	FROM Teacher T, Subject S
		WHERE T.id=S.id_Teach
```

(pic)

### 2. Объединение трёх таблиц.

**Пример.** Вывести список оценок, выставленных тем или иным преподавателем в виде таблицы с полями (ФИО, Предмет, Оценка).

Пусть существуют таблицы `Teacher` (`id`(код_преподавателя), `Name`(имя_преподавателя), `id_dep`(код_кафедры)), `Subject`(`id`(код_предмета), `Name`(имя_предмета), `id_Teach`(код_преподавателя)) и `Usp`(`id`, Num(зачетка), `Ocenka`(оценка), `id_Pred`(код_предмета), `Date`).

```sql

SELECT T.Name AS "ФИО", S.Name AS "Предмет", U.Ocenka AS "Оценка"
	FROM Teacher T, Subject S, Usp U
		WHERE T.id=S.id_Teach AND S.id= U.id_Pred
```

### 3. Объединение двух (или более) копий одиночной таблицы (рефлексивное соединение)

- Объединение таблицы со своей копией – реально копия таблицы **не создаётся**, но SQL выполняет команду так, как будто бы делалось именно это.
- Данный тип объединения не отличается от обычного соединения двух таблиц, за исключением того, что в данном случае таблицы идентичны.
- При объединении таблицы со своей копией для ссылки к столбцам необходимо иметь **два различных имени** для одной и той же таблицы – **псевдонимов**, определяемых в предложении FROM.

**Пример.** Определить студентов, имеющих одинаковые стипендии.

```sql
SELECT First.Name, Second.Name, First.Stip
	FROM Student First, Student Second
		WHERE First.Stip = Second.Stip
```

SQL ведет себя так, как если бы он соединял две различные таблицы с именами First и Second, то есть псевдонимы разрешают одной и той же таблице быть обработанной независимо.

*Логика этого запроса*: из таблицы `Student` выбирается очередная строка и запоминается под первым псевдонимом. После этого SQL начнет проверять ее в комбинации с каждой строкой таблицы `Student` под вторым псевдонимом. Если комбинация строк удовлетворяет предикату, то соответствующие поля из нее выбираются для вывода.

***Особенности работы с псевдонимами:***

- псевдонимы могут использоваться в предложении SELECT до их объявления в предложении FROM,
- псевдонимы таблиц могут совпадать с именами таблиц,
- допускается использование любого числа псевдонимов для одной таблицы в запросе (хотя более двух псевдонимов в запросе – излишество),
- SQL отклонит запрос, если используемые псевдонимы далее не будут определены в предложении FROM,
- псевдоним существует только во время выполнения команды, а после завершения запроса псевдонимы запроса больше не имеют никакого значения,
- псевдонимы используются для упрощения записи при длинных и сложных именах таблиц и для минимизации синтаксических ошибок.

*Недостаток данного запроса* – вывод имеет два значения для каждой комбинации фамилий, причем второй раз в обратном порядке – это связано с тем, что текущее значение в первом псевдониме сначала выбирается в комбинации со значением во втором псевдониме, а затем наоборот, кроме того каждая строка сравнена сама с собой – например, Серов с Серовым.

*Способ устранения* данного недостатка – наложение условия порядка на два значения так, чтобы одно значение могло быть меньше второго или предшествовало ему в алфавитном порядке. Это сделает предикат ассиметричным относительно связи, поэтому те же самые значения в обратном порядке не будут выбраны снова.

```sql
SELECT First.Name, Second.Name, First.Stip FROM Student First, Student Second
	WHERE First.Stip=Second.Stip
		AND First.Name < Second.Name
```

Таким образом:

Операция объединения соединяет информацию из двух (или более) таблиц (одинаковых или разных), формируя пары связанных строк из них.

Объединенную таблицу образуют пары тех строк из различных таблиц, у которых в связанных столбцах содержатся одинаковые значения.

## Конструкция JOIN

*Join* - реализуется внутреннее (*Inner Join* или просто *Join*) и внешнее (*Left \| Right \| Full Outer \| Cross Join*) объединения.

*Внешнее объединение* возвращает все строки из одной таблицы (главной) и только те строки из другой таблицы (подчиненной), для которых условие объединения принимает значение *True*.

Строки второй таблицы, не удовлетворяющие условию объединения (то есть имеющие значение False), получают значение Null и в результирующем наборе не выводятся.

В соединении различаются стороны – левая и правая. Левой считается таблица, указанная в предложении From **первой**, а правой – таблица, указанная **второй**.

Существует **четыре вида** внешнего объединения:

- *левое* внешнее объединение (`Left Join`) – запрос возвращает все строки из левой таблицы и только те из правой таблицы, которые удовлетворяют условию соединения (строки правой таблицы, не удовлетворяющие условию объединения, получают значение Null и в результирующем наборе не выводятся),
- *правое* внешнее объединение (`Right Join`) – все наоборот по отношению к левому внешнему объединению,
- *полное* внешнее объединение (`Full Outer Join`) – запрос возвращает все строки и левой и правой таблиц, но в особом порядке,
- *перекрестное* объединение (`Cross Join`) – запрос возвращает все строки левой таблицы и первую строку правой таблиц, все строки левой таблицы и вторую строку правой таблиц, и так далее.

**Внутреннее объединение**

(pic)

**Левое внешнее объединение**

(pic)

## Функции SQL

СУБД содержат ряд встроенных функций, которые позволяют выполнять различные операции над данными, извлекаемыми из таблиц. Задача: переложить часть работы на сервер СУБД.

Все SQL-функции разделяются на функции двух типов: скалярные и агрегатные.

(pic)

**Агрегатные** функции SQL, предназначены для выполнения действий над множеством значений, например, которые группируются клаузой `GROUP BY` оператора `SELECT`.

- `AVG()` - Возвращает среднее значение элементов столбца
- `MAX()` - Возвращает максимальное значение элементов столбца
- `MIN()` - Возвращает минимальное значение элементов столбца, все NULL- значения игнорируются.
- `SUM()` - Возвращает сумму элементов столбца, все NULL-значения игнорируются.
- `COUNT()` - Возвращает количество значений элементов столбца типа int
- `COUNT(\*)` - Возвращает количество строк в таблице результатов запроса (с учетом всех повторяющихся и NULL значений)
- `COUNT_BIG()` -Возвращает данные о количестве элементов в группе.
- `STDEV()` -Возвращает результата вычисления среднеквадратического отклонения
- `VAR()` - Возвращает результата вычисления дисперсии

*Особенности запросов с агрегатными функциями:*

1. С функциями `SUM` и `AVG` используются только числовые поля, а с `COUNT`, `MAX` и `MIN` могут использоваться числовые или символьныеполя.
2. Функция `COUNT` считает количество значений в столбце или число строк в таблице.

**Пример.** Посчитать число студентов, сдавших учебные предметы.

```sql
SELECT COUNT(DISTINCT Id_Stud) FROM USP;
```

Результат запроса:

```
COUNT(*)
3
```

Пример. Посчитать общее количество строк в таблице USP. 
```sql
SELECT COUNT(*) FROM USP;
```