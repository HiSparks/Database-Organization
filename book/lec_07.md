---
title: "Лекция 7: Группировка и сортировка полей в операторе SELECT"
layout: bookpage
lang: ru
---

# 1. Предложения  GROUP BY  и HAVING
Задача: получить средний бал группы

![](../assets/images/7_01.svg)

```sql
SELECT g.name AS 'Группа', s.sr_ball AS 'Средний балл‘

FROM Groups g, Student s

WHERE g.id = s.id_groups
```

| Таблица "Groups" | 
|--------------------------------------------|
|  id         | Name                |
|  2             | 535                |
|  3           | 535a                 |

| Таблица "Student" | 
|--------------------------------------------|
|  Id         | Name                | sr_ball | id_group |
|  1             | Иванов                | 3,45 | 2 |
|  2           | Сидоров                 | 4,24 | 2 |
|  3             | Иванов                | 4,76 | 3 |
|  4           | Семёнов                 | 4,33 | 3 |

| groups_name | student.sr_ball  |
|----------------------|----------------------|
|  535         | 3,45               |
|  535             | 3,24                |
|  535a           | 4,76                |
|  535a           | 4,33                |

- Что сделать? произвести над sr\_ball, которое не является условием группировки, определенные арифметические действия, результатом которых является одна строка.

- Операции вычисления количества записей (Count), суммы значений (Sum), среднего арифметического (Avg), минимума (Min), максимума (Max).

```sql
SELECT g.name AS 'Группа', AVG(s.sr_ball) AS'Средний балл'

FROM Groups g, Student s

WHERE g.id = s.id_groups

GROUP BY g.name
```

![](../assets/images/7_02.jpg)
- GROUP BY позволяет определять подмножество значений отдельного поля (s.sr\_ball) в терминах другого поля (g.name) и применять функции агрегирования к полученному подмножеству.

- Это дает возможность комбинировать поля и агрегатные функции в одном предложении SELECT.


*Пример*:

- Дана таблица Usp  (Id, Num-номер зачетки, Ocenka-оценка, Id_Sub-код предмета, Date-дата)

- Определить наименьшую оценку, полученную каждым студентом

```sql
SELECT Num, MIN(Ocenka)

FROM Usp

GROUP BY Num;
```

| Num | No column name  |
|----------------------|----------------------|
|  3126         | 4              |
|  3124             | 5              |
|  3125          | 3             |
|  3123           | 4               |

Задание нескольких полей:

- задать поля в предложении SELECT;

- перечислить поля в предложении GROUP BY;

- остальные поля предложения SELECT, которые не участвуют в группировке, д.б.  заданы в качестве параметров агрегатных функций.

- Если заданное в предложении SELECT поле не является частью условия группировки и параметром агрегатной функции, то такой оператор считается ошибочным.

*Пример*.  Определить наименьшую оценку, полученную каждым студентом за каждый день.

```sql
SELECT Num, Date, MIN(Ocenka)

FROM Usp

GROUP BY Num, Date;
```

Предложение  HAVING:

- задает условие внутри группы, которая была получена предложением  GROUP BY;

- должно ссылаться только на агрегатные функции и поля, выбранные в GROUP BY;

- HAVING может иметь только такие аргументы, у которых единственное значение для группы выходных данных;

- для задания условий используются те же операции, что и в предложении  WHERE;

- Отличие HAVING и WHERE: WHERE выполняется *перед группировкой* и, следовательно, с его помощью невозможно задать условие, которое использует результаты группировки.

*Пример*. Получить средний бал групп, но выводить список тех групп, у которых средний балл выше 4,5.

Требуется группировки и затем отсеивания некоторого количества результатов после ее выполнения:

```sql
SELECT g.name AS 'Группа', AVG(s.sr_ball) AS 'Средний балл'

FROM Groups g, Student s

WHERE g.id = s.id_groups

GROUP BY g.name

HAVING AVG(s.sr_ball) > 4,5
```

# 2. Предложение  ORDER BY
ORDER BY - задание набора полей и порядка их сортировки

Синтаксис :

```sql
ORDER BY  имя_поля1 [ASC | DESC] [, имя_поля2 [ASC | DESC], ...]
```

*Пример*. Вывести список студентов отсортированный по возрастанию.

```sql
SELECT name AS 'Ф.И.О.'  FROM Student

ORDER BY name ASC
```

Особенности:

- “имя\_поля” задает поле SELECT, по которому выполняется сортировка

- Поля д. б. указаны в предложении SELECT.

- ASC (*по возрастанию*) и DESC (*по убыванию*) определяют порядок (направление) сортировки.

- Если требуется сортировка по нескольким полям, они перечисляются через запятую

- Если задано несколько полей, то поле, которое идет вначале, обладает преимуществом перед полем, которое задано после него.

- Имена полей можно задавать а) именами столбцов, б) номерами столбцов.

ORDER BY может использоваться с GROUP BY для упорядочения групп. ORDER BY выполняется последней.

*Пример*. Пусть есть таблица Usp  (Id, Num, Mark, Id_Sub, Date). Определить наименьшую оценку, полученную каждым студентом, отсортировать по номерам зачеток.

```sql
SELECT Num, MIN(Mark)

FROM Usp

GROUP BY Num

ORDER BY Num;
```

| Num | Mark  |
|----------------------|----------------------|
|  3123         | 4              |
|  3124             | 5              |
|  3125          | 3             |
|  3126           | 4               |

# 3. Порядок выполнения предложений оператора SELECT
SELECT  WHERE  GROUP BY  HAVING  ORDERBY

- Первым - SELECT, выбирает значения всех полей таблиц, и формирует промежуточную таблицу в 1НФ. [DISTINCT] удаляет повторяющиеся записи.

- Промежуточная таблица поступает в WHERE, где просеивается сквозь условия.

- Просеянная таблица попадает в GROUP  BY, где выявляются группы и заданные действия. Затем HAVING, которое может отсечь еще часть данных.

- Результат сортируется согласно определениям ORDER BY и поступает к пользователю.
# 4. Вложенные запросы
- *Подзапрос* (вложенный запрос) — запрос, содержащийся в выражении предложения WHERE или HAVING другого запроса

- Цель: определение *дополнительных ограничений* на выводимые данные.  Используется для наложения условий на выводимые данные.

- *Скалярный* подзапрос - возвращает единственное значение.

- *Табличный* подзапрос - возвращает множество значений, т.е. значения одного или нескольких столбцов таблицы, размещенные в более чем одной строке.

- *Пример*. Пусть существует таблица USP (Id, Id_Stud, Ocenka, Id_Sub, Date). Из таблицы STUDENT (id, name, sr_ball, id_group, city) известна фамилия студента («Петров»), но неизвестно значение поля Id_Stud  (внешний ключ таблицы USP) для него.

- Требуется извлечь данные обо всех оценках этого студента:
```sql
SELECT * FROM USP WHERE

ID_STUD = (SELECT ID FROM STUDENT WHERE NAME = 'Петров')
```
```sql
SELECT * FROM USP WHERE

ID_STUD = (SELECT ID FROM STUDENT WHERE NAME = 'Петров')
```
- выбирается строка из таблицы USP, имя которой указано во внешнем запросе;

- выполняется подзапрос и полученное значение применяется для анализа этой строки в условии предложения WHERE внешнего запроса;

- по результату оценки этого условия принимается решение о включении или невключении строки в состав выходных данных;

- процедура повторяется для следующей строки таблицы внешнего запроса.

ВАЖНО:

- Приведенный запрос корректен только в том случае, если в результате выполнения указанного в скобках подзапроса возвращается *единственное значение*. Иначе - будет ошибочным (несколько записей со значениями NAME = 'Петров’)

- Необходимо *возвращение одного* и только одного значения. Если в результате выполнения подзапроса получается несколько значений, то это делает невозможной оценку предиката основного запроса на предмет истинности или ложности, что приводит к оценке запроса как ошибочного.

Правила составления подзапросов:

- Подзапрос - в круглые скобки

- Подзапрос может ссылаться только на один столбец в выражении своего ключевого слова SELECT

- ORDER BY нельзя использовать в подзапросе (только GROUP BY)

- Подзапрос, возвращающий несколько строк данных, можно использовать только в операторах, допускающих множество значений, например в IN.

- В списке SELECT не допускаются ссылки на значения типа BLOB, ARRAY, CLOB или  NCLOB.

- Подзапрос нельзя использовать как аргумент допускающий множество значений функции.

- Операцию BETWEEN по отношению к подзапросу использовать нельзя (но можно использовать в самом подзапросе)

*Пример*. Найти разницу  между  средними  баллами  двух  групп
```sql
SELECT

(SELECT AVG(sr_ball) FROM Student Where id_groups=2) -

(SELECT AVG(sr_ball) FROM Student Where id_groups=2)

AS ‘Разность’
```

![](../assets/images/7_02.jpg)

# 5. Операции над множествами
Любая таблица БД – множество

Результат SELECT (данные в виде таблицы в 1НФ), также считается множеством

Некоторые операции с множествами доступны для выполнения с помощью SELECT

Операция “*проекция*”:
```sql
 SELECT b, d, e FROM table1
 ```

| table1 |
|---|---------|-----------|-----------|----------|
| a | b         | c                | d | e |
|  |             |                 |  |  |
|  |            |                 |  |  |

Операция “*выборка*”:
```sql
SELECT * FROM table1 WHERE условие
 ```

 | table1 |
|---|---------|-----------|-----------|----------|
| a | b         | c                | d | e |
|  |             |                 |  |  |
|  |            |                 |  |  |
|  |            |                 |  |  |

Остальные три операции бинарные. В качестве параметров операций используются два SQL-оператора SELECT.

“*объединение*”:
```sql
SELECT f1, f2 FROM table1

UNION

SELECT f3, f5 FROM table2
```

“*пересечение*”:
```sql
SELECT f1, f2 FROM table1

INTERSECT

SELECT f2, f4 FROM table2
```
“*вычитание*”
```sql
SELECT f1, f3 FROM table1

MINUS

SELECT f3, f2 FROM table2;
```

![](../assets/images/7_04.jpg)