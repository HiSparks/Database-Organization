

>   МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ УКРАИНЫ

>   Национальный аэрокосмический университет им. Н. Е. Жуковского

>   «Харьковский авиационный институт»

А.В. Шостак, В.И. Дужий
=======================

>   **ОРГАНИЗАЦИЯ БАЗ ДАННЫХ**

>   Учебное пособие

Харьков «ХАИ» 2011
==================

УДК 004.67

Шостак А.В., Дужий В.И. Организация баз данных: учеб. пособие / А.В. Шостак. –
Х.: Нац. аэрокосм. ун-т “Харьк. авиац. ин-т”, 2011. – 163 с.

Кратко изложены теоретические вопросы, касающиеся организации и проектирования
баз данных. Представлено описание лабораторных работ по курсу “Организация баз
данных”, целью которых является приобретение практических навыков по
проектированию и созданию баз данных.

Для студентов дневной и заочной форм обучения по специальности «Компьютерная
инженерия».

>   Ил. 22. Табл. 22. Библиогр.: 14 назв.

>   Рецензенты: канд. техн. наук, доц. В.Н. Дронов,

>   канд. техн. наук, доц. А.В. Щербаков

>    Национальный аэрокосмический университет им. Н.Е. Жуковского

>   «Харьковский авиационный институт», 2011 г.

>   СОДЕРЖАНИЕ

>   Лабораторная работа 1

Проектирование распределенной базы данных
=========================================

>   Постановка задачи:

Спроектировать структуру БД для выбранной предметной области:

1.  Выбрать предметную область для проектирования БД.

2.  Спроектировать инфологическую модель данных с использованием нотации
    Баркера.

3.  Спроектировать физическую модель данных

(проектирование реализации).

1.  Разработать таблицы физической модели данных и описать их.

2.  Разработать бизнес-правила.

>   Письменный отчет по лабораторной работе должен содержать:

1.  Титульный лист, содержащий – название лабораторной работы, фамилию, имя,
    отчество, номер группы исполнителя, дату сдачи.

2.  Постановку задачи и основные исходные данные для проектирования БД.

3.  Инфологическую модель данных с использованием нотации Баркера.

4.  Физическую модель данных.

5.  Таблицы физической модели данных и их описание.

6.  Описание бизнес-правил.

7.  Выводы по лабораторной работе (в выводах отразить особенности построения
    моделей, и пути дальнейшей модернизации БД).

Пример описания таблицы STUDENT

| Таблица STUDENT |              |               |             |             |          |        |
|-----------------|--------------|---------------|-------------|-------------|----------|--------|
| Поле            | Название     | Тип данных    | PRIMARY KEY | FOREIGN KEY | NOT NULL | UNIQUE |
| ID              | Код          | tinyint       | \*          |             | \*       | \*     |
| FAM             | Фамилия      | nvarchar(10)  |             |             | \*       |        |
| OCENKA          | Оценка       | tinyint       |             |             |          |        |
| ID_GR           | Код группы   | tinyint       |             | \*          | \*       |        |
| YEAR_B          | Год рождения | smalldatetime |             |             |          |        |

>   Контрольные вопросы и задания

1.  Какие модели БД существуют?

2.  В чем достоинства и недостатки реляционного подхода?

3.  Каковы основные понятия реляционных БД?

4.  Каковы свойства отношений?

5.  Как задается отношение?

6.  Какие виды ключей существуют в отношении?

7.  Какие виды целостности существуют в реляционных БД?

8.  Какие типы связей существуют в БД?

9.  Дайте определение функциональной зависимости в БД.

10. Каковы основные цели нормализации отношения?

11. Какие виды нормальных форм существуют?

12. Каковы основные характеристики нормальных форм?

13. Каковы недостатки 1НФ, которые устраняются в результате перехода ко 2НФ?

14. Каковы недостатки 2НФ, которые устраняются в результате перехода к 3НФ?

15. Каковы недостатки 3НФ, которые устраняются в результате перехода к форме
    Бойса-Кодда (BCNF)?

16. Каковы недостатки BCNF, которые устраняются в результате перехода к 4НФ?

17. Какова цель денормализации таблицы? Каковы основные рекомендации по
    денормализация таблиц?

18. Какие типы бинарных связей поддерживаются (не поддерживаются) в базах
    данных?

19. Какие существуют типы обязательности связей?

>   Лекция 1. **Основы использования баз данных**

Определения и основные понятия
==============================

>   Один из ведущих специалистов К. Дж. Дейт называет систему баз данных
>   "компьютеризированной системой хранения записей". Саму же базу данных (БД)
>   можно рассматривать как подобие электронной библиотеки, состоящей из
>   огромного количества карточек или записей, если пользоваться соответствующим
>   термином (БД – (речь идет о реляционной БД) это прежде всего набор
>   взаимосвязанных таблиц.). Основные задачи, возникающие при работе с БД:

1.  хранение записей и таблиц,

2.  управление записями и таблицами.

>   Итак, БД (или более широко - система баз данных) – это набор
>   программно-аппаратных средств, который выполняет задачи

централизованного хранения и обработки данных пользователя. Система баз данных
состоит из следующих компонент:

1.  данные,

2.  аппаратное обеспечение,

3.  программное обеспечение,

4.  пользователи.

Между собственно физической БД и пользователями БД располагается уровень
программного обеспечения, которое так же называется система управления БД
(СУБД).

СУБД – это совокупность языковых и программных средств, предназначенных для
создания, наполнения, обновления и удаления БД.

>   Виды СУБД:

-   промышленные универсального назначения,

-   промышленные специального назначения,

-   разрабатываемые для конкретного заказчика.

По характеру использования СУБД разделяют на персональные и
многопользовательские.

Персональная СУБД обеспечивает возможность создания локальных БД, работающих на
одном компьютере. К персональным СУБД относятся Paradox, dBase, FoxPro, Access и
др.

Многопользовательская СУБД позволяет создавать информационные системы,
функционирующие в архитектуре клиент- сервер. К многопользовательским СУБД
относятся Microsoft SQL Server, Oracle, InterBase, SyBase, Informix и другие
(таблица 1.1).

>   Таблица 1.1 − Доля рынка СУБД (2008 год)

| № | Производители СУБД | Доля рынка СУБД( %) |
|---|--------------------|---------------------|
| 1 | IBM (DB-2)         | 29,9                |
| 2 | Oracle             | 31,1                |
| 3 | Informix           | 4,3                 |
| 4 | Microsoft          | 13,1                |
| 5 | Sybase             | 3,3                 |
| 6 | Другие             | 18,3                |

>   Функции СУБД:

1.  Непосредственное управление данными во внешней памяти.

2.  Управление разделами оперативной памяти с целью увеличения скорости работы
    БД.

3.  Управление транзакциями. Транзакция – это последовательность операций над
    БД, рассматриваемых СУБД как единое целое. Понятие транзакции необходимо для
    поддержания логической целостности БД. Механизм транзакций обеспечивает: -

защиту БД от аппаратных сбоев, - возможность многопользовательского доступа к
данным в удаленных БД.

1.  Журнализация – ведение журнала изменений БД с целью поддержания надежности
    хранения данных в БД. Журнал и архивная копия БД – основные средства для
    восстановления БД.

2.  Подержание языков БД. Языковые средства современных СУБД включают:

    -   язык описания данных (схемы данных) (SDL – Schema Definition Language),
        предназначенный для описания логической структуры БД;

    -   язык манипулирования данными (DML – Data Manipulation Language),
        обеспечивающий выполнение основных операций над данными – ввод,
        модификацию, выборку и удаление;

    -   структурированный язык запросов (SQL – Structured Query Language),
        обеспечивающий управление структурой БД и манипулирование данными, а
        также являющийся стандартным средством доступа к удаленным БД. В
        современных СУБД SQL сочетает средства SDL и DML, то есть позволяет
        определять схему реляционной БД и манипулировать данными;

    -   язык запросов по образцу (QBE – Query By Example),

>   обеспечивающий визуальное конструирование запросов к БД. Пользователей можно
>   разделить на три большие группы:

1.  Прикладные программисты, которые отвечают за написание прикладных программ,
    использующих базу данных.

2.  Конечные пользователи, которые работают с системами баз данных
    непосредственно через рабочую станцию или терминал. Конечный пользователь
    может получить доступ к БД, используя одно из приложений, или же
    воспользоваться интегрированным интерфейсом программного обеспечения самой
    системы базы данных. Такой интерфейс является встроенным в БД. В большинстве
    систем есть, по крайней мере, одно такое приложение, а именно: процессор
    языка запросов, который позволяет пользователю указывать команды или
    выражения высокого уровня для данной СУБД.

3.  Администраторы базы данных. Это люди, которые следят за работой базы данных.
    Они должны обеспечить безопасность данных.

>   Этапы создания БД:

>   Первый этап — базы данных на больших ЭВМ.

>   Особенности этого этапа развития выражаются в следующем:

-   Все СУБД базируются на мощных мультипрограммных ОС (MVS, SVM, RTE, OSRV,
    RSX, UNIX), поэтому в основном поддерживается работа с централизованной БД в
    режиме распределенного доступа.

-   Функции управления распределением ресурсов в основном осуществляются ОС.

-   Поддерживаются языки низкого уровня манипулирования данными, ориентированные
    на навигационные методы доступа к данным.

-   Значительная роль отводится администрированию данных.

-   Проводятся серьезные работы по обоснованию и формализации реляционной модели
    данных, и была создана первая система (System R), реализующая идеологию
    реляционной модели данных.

-   Проводятся теоретические работы по оптимизации запросов и управлению
    распределенным доступом к централизованной БД, было введено понятие
    транзакции.

-   Результаты научных исследований открыто обсуждаются в печати, идет мощный
    поток общедоступных публикаций, касающихся всех аспектов теории и практики
    БД, и результаты теоретических исследований активно внедряются в
    коммерческие СУБД.

>   Второй этап - эпоха персональных компьютеров. Особенности этого этапа
>   следующие:

-   Все СУБД были рассчитаны на создание БД в основном с монопольным доступом.
    Компьютер персональный, он не был подсоединен к сети, и БД на нем
    создавалась для работы одного пользователя. (В редких случаях предполагалась
    последовательная работа нескольких пользователей, например, сначала
    оператор, который вводил бухгалтерские документы, а потом главбух, который
    определял проводки, соответствующие первичным документам.)

-   Большинство СУБД имели развитый и удобный пользовательский интерфейс. В
    большинстве существовал интерактивный режим работы с БД, как в рамках
    описания БД, так и в рамках проектирования запросов. Кроме того, большинство
    СУБД предлагали развитый и удобный инструментарии для разработки готовых
    приложений без программирования. Инструментальная среда состояла из готовых
    элементов приложения в виде шаблонов экранных форм, отчетов, этикеток
    (Labels), графических конструкторов запросов, которые достаточно просто
    могли быть собраны в единый комплекс.

-   Во всех настольных СУБД поддерживался только внешний уровень представления
    реляционной модели, то есть только внешний табличный вид структур данных.

-   При наличии высокоуровневых языков манипулирования данными типа реляционной
    алгебры и SQL в настольных СУБД поддерживались низкоуровневые языки
    манипулирования данными на уровне отдельных строк таблиц.

-   В настольных СУБД отсутствовали средства поддержки ссылочной и структурной
    целостности базы данных. Эти функции

должны были выполнять приложения, однако скудость средств разработки приложений
иногда не позволяла это сделать, и в этом случае эти функции должны были
выполняться пользователем, требуя от него дополнительного контроля при вводе и
изменении информации, хранящейся в БД.

-   Наличие монопольного режима работы фактически привело к вырождению функций
    администрирования БД и в связи с этим — к отсутствию инструментальных
    средств администрирования БД.

-   Сравнительно скромные требования к аппаратному обеспечению со стороны
    настольных СУБД. Вполне работоспособные приложения, разработанные, например,
    на Clipper, работали на PC 286.

>   Третий этап - распределенные БД. Особенности данного этапа:

-   Практически все современные СУБД обеспечивают поддержку полной реляционной
    модели, а именно:

-   структурной целостности — допустимыми являются только данные, представленные
    в виде отношений реляционной модели;

-   языковой целостности, то есть языков манипулирования данными высокого уровня
    (в основном SQL);

-   ссылочной целостности — контроля за соблюдением ссылочной целостности в
    течение всего времени функционирования системы, и гарантий невозможности со
    стороны СУБД нарушить эти ограничения.

-   Большинство современных СУБД рассчитаны на многоплатформенную архитектуру,
    то есть они могут работать на компьютерах с разной архитектурой и под
    разными ОС, при этом для пользователей доступ к данным, управляемым СУБД, на
    разных платформах практически неразличим.

-   Необходимость поддержки многопользовательской работы с БД и возможность
    децентрализованного хранения данных потребовали развития средств
    администрирования БД с реализацией общей концепции средств защиты данных.

-   Потребность в новых реализациях вызвала создание серьезных теоретических
    трудов по оптимизации реализации распределенных БД и работе с
    распределенными транзакциями и запросами с внедрением полученных результатов
    в коммерческие СУБД.

-   Для того чтобы не потерять клиентов, которые ранее работали на настольных
    СУБД, практически все современные СУБД имеют средства подключения клиентских
    приложений, разработанных с использованием настольных СУБД, и средства
    экспорта данных из форматов настольных СУБД второго этапа развития.

>   Четвертый этап - перспективы развития систем управления БД.

-   1. Реляционные системы

-   1.1. Стандартизация языка SQL

-   1.2. Использование мультипроцессорных организаций

-   1.3. Интеграция и интероперабильность

-   2. Постреляционные системы (системы относящиеся к следующему поколению).

-   2.1. Базы сложных объектов, реляционная модель с отказом от первой
    нормальной формы

-   2.2. Активные базы данных (По определению БД называется активной, если СУБД
    по отношению к ней выполняет не только те действия, которые явно указывает
    пользователь, но и дополнительные действия в соответствии с правилами,
    заложенными в саму БД).

-   2.3. Дедуктивные базы данных (По определению, дедуктивная БД состоит из двух
    частей: экстенсиональной, содержащей факты, и интенсиональной, содержащей
    правила для логического вывода новых фактов на основе экстенсиональной части
    и запроса пользователя).

-   2.4. Темпоральные базы данных

-   2.5. Интегрированные или федеративные системы и мультибазы данных

-   2.6. СУБД следующего поколения

-   2.7. Объектно-ориентированные базы данных.

-   3. Распределенные СУБД.

-   3.1. Синхронизация доступа к данным

-   3.2. Управление транзакциями

-   3.3. Поддержание копий данных в нескольких узлах сети

-   3.4. Фрагментация объектов БД

-   3.5. Алгоритмы выполнения реляционных операций

-   4. Системы БД с многоуровневой защитой.

    1.  Архитектуры БД

В зависимости от местоположения отдельных частей СУБД различают локальные
(автономные) БД и удаленные (многопользовательские или сетевые) БД.

К локальным БД относятся Paradox, dBase, FoxPro, Access и др. Локальная
архитектура БД представлена на рисунок 1.1.

В этом случае приложение, СУБД и таблицы БД располагаются на одном компьютере.
Таблицы БД хранятся в локальной файловой системе компьютера.

БД с локальной архитектурой используются в приложениях, обрабатывающих
документацию небольшой фирмы, кадровый состав небольшого предприятия,
бухгалтерскую документацию небольшой фирмы. Каждый пользователь такого
приложения манипулирует

своими собственными данными на своем компьютере. Параллельный доступ к такой БД,
как правило, не используется.

>   Рисунок 1.1 − Локальная архитектура базы данных

К удаленным БД относятся Oracle, MS SQL Server, Informix, InterBase, SyBase и
др.

>   Классификация архитектур удаленных БД:

-   файл-серверная архитектура (рисунок 1.2),

>   Рисунок 1.2 − Файл-серверная архитектура базы данных Сама БД хранится на
>   сетевом файл-сервере в единственном

экземпляре. Для каждого клиента во время работы создается локальная копия БД
(периодически обновляемая), с которой пользователь манипулирует.

Достоинство: возможность одновременной работы нескольких пользователей с одной
БД.

>   Недостатки:

1.  непроизводительная загрузка сети – обновление локальной копии БД. Существует
    блокировка на уровне таблицы.

2.  забота о целостности данных возлагается на программы пользователей, если они
    недостаточно тщательно продуманы, то в БД можно легко занести ошибки.

3.  сложности с организацией защиты информации в БД.

    -   клиент-серверная архитектура (рисунок 1.3),

Удаленная БД размещается на мощном удаленном сервере сети, а приложение,
работающее с этой БД, находится на компьютере пользователя. Информационная
система состоит из двух

неоднородных частей – удаленного сервера сети и клиентов БД

![](media/6b25582aac6f22fb49628fd1fd036d09.png)

(клиент это приложение пользователя).

Запросы-Данные

>   ПК пользователя 1

.
=

**.**

**.**

Удаленный сервер сети

>   ПК пользователя n

>   Запросы-Данные

>   Рисунок 1.3 − Клиент-серверная архитектура базы данных

>   Достоинства архитектуры:

1.  высокая эффективность выполнения приложения за счет использования мощного
    сервера,

2.  низкая нагрузка на сеть, в которой циркулируют только запросы и данные,

3.  безопасность информации, так как обработка запросов всех клиентов
    выполняется единой программой, расположенной на SQL– сервере,

4.  в клиентских приложениях отсутствует код, обеспечивающий управление БД и
    разграничение доступа в ней,

5.  клиент-серверные СУБД допускают блокировку на уровне записи и даже
    отдельного поля, то есть с таблицей могут работать одновременно много
    пользователей, но доступ к функции изменения конкретной записи и поля
    обеспечен только одному из них.

Недостатки архитектуры: не очень высокая надежность (так как по сути сеть
передачи данных логически имеет звездообразную топологию) – если SQL–сервер
выходит из строя, то вся работа БД останавливается.

Для реализации архитектуры клиент-сервер обычно применяют многопользовательские
СУБД – Microsoft SQL Server или Oracle.

-   распределенная (многоярусная) архитектура (рисунок 1.4),

В сети работает несколько удаленных серверов, и таблицы БД распределены между
ними для достижения повышенной эффективности. На каждом сервере функционирует
своя копия СУБД. Кроме того, в такой архитектуре обычно используются специальные
программы, называемые серверы приложений. Они позволяют оптимизировать обработку
запросов большого числа пользователей и

равномерно распределять нагрузку между ПЭВМ сети. Наиболее распространен
трехъярусный вариант архитектуры (трехзвенная архитектура).

>   Достоинства архитектуры:

-   это распределенная архитектура БД,

-   наиболее сложная, надежная, живучая и гибкая организация баз данных.

>   Недостатки архитектуры:

-   сложный и дорогостоящий процесс создания и сопровождения

(администрирования) БД,

-   высокие требования к серверным компьютерам.

>   Рисунок 1.4 − Распределенная архитектура базы данных

На рисунке 1.5 представлены одно-, двух- и трехзвенная архитектуры соединения
клиента с данными.

В однозвенной архитектуре используется единственное звено (клиент),
обеспечивающее необходимую логику управления данными и их визуализацию.

В двухзвенной архитектуре значительную часть логики управления данными берет на
себя сервер БД, в то время как клиент в основном занят отображением данных в
удобном для пользователя виде.

![](media/f522308ee7c70d2a9f43df5431afd4aa.png)

![](media/a99887847f67f4cdbdb13e8b066064bd.png)

![](media/2edb2b0efb2e9e54724004ec76f8f3eb.png)

![](media/5a386761c0683b133734847ef3744417.png)

![](media/63ef8f32f2a191470c6d1d550e5864a5.png)

![](media/2398aba27c259024e76825aa5b2df348.png)

>   Рисунок 1.5 − Архитектуры соединения клиента с данными: - однозвенная, -
>   двухзвенная, - трехзвенная.

В трехзвенных СУБД имеется промежуточное звено – сервер приложений, являющееся
посредником между клиентом и сервером БД. Сервер приложений призван полностью
избавить клиента от каких бы то ни было забот по управлению данными и
обеспечению связи с сервером БД.

-   интернет-архитектура – использование стандартных протоколов Интернета для
    обмена данными.

>   Классификация БД по структуре организации данных

БД содержит данные, используемые некоторой прикладной системой (приложением).
Под моделью данных понимается интегрированный набор понятий для описания данных,
связей между ними и ограничений, накладываемых на данные в некоторой их
организации. В зависимости от вида организации данных различают следующие модели
БД: – иерархическую, – сетевую, – объектно- ориентированную, – реляционную.

1.  В иерархической БД данные представляются в виде древовидной структуры. Такая
    структура БД удобна для работы с данными, упорядоченными иерархически.
    Однако, при оперировании данными со сложными логическими связями данная
    модель оказывается слишком громоздкой.

>   Преимущества иерархической модели:

-   наличие прекрасно показавших себя в работе СУБД;

-   удобство и простота представления данных, которые имеют естественную
    иерархическую структуру.

>   Недостатки иерархической модели:

>   \- сложность операций включения и удаления;

-   взаимосвязь M:M реализуется громоздко с большой избыточностью (как следствие
    сложности поддержки целостности и непротиворечивости);

-   низкий уровень независимости ПП от данных в сравнении с другими моделями.

1.  В сетевой модели каждый узел (набор) БД взаимодействует с другими узлами
    посредством сложной структуры связей. То есть, данные в БД организуются в
    виде графа.

>   Преимущества сетевой модели:

-   возможность непосредственной навигации по связанным данным;

-   возможность использования множественных типов данных для описания атрибутов
    объектов (записей);

-   позволяет наилучше отображать инфологические связи сложных предметных
    отраслей.

>   Недостатки сетевой модели:

-   сложность модели, жесткость ее структуры;

-   отсутствие удачной (универсальной) реализации языка описания данных.

1.  Объектно-ориентированные БД объединяют сетевую и реляционную модели и
    используются для создания крупных БД с данными сложной структуры. В такой БД
    хранятся не только данные, но и методы их обработки в виде программного
    кода. Эта модель пока не получила активного распространения из-за сложности
    создания и применения подобных СУБД.

2.  Реляционная БД (relation – отношение, связь) представляет собой совокупность
    таблиц, связанных отношениями (связями).

Достоинства реляционной модели: – простота, – гибкость структуры, –
теоретическая основа – теория отношений реляционной алгебры, – удобство
реализации на ПЭВМ, – обеспечивает высшую степень логической независимости
данных в сравнении с другими моделями.

Большинство современных БД для ПЭВМ являются реляционными.

Недостаток реляционной модели – производительность существующих реляционных СУБД
ниже, чем в СУБД других типов.

>   Контрольные вопросы

1.  Определение базы данных.

2.  Состав базы данных.

3.  Определение системы управления базой данных и ее основные функции.

4.  Классификация архитектур баз данных.

5.  Основные особенности, достоинства и недостатки клиент- серверной архитектуры
    базы данных.

6.  Основные особенности, достоинства и недостатки распределенной архитектуры
    базы данных.

7.  Классификация баз данных по структуре организации данных.

8.  Основные особенности, достоинства и недостатки реляционной базы данных.

Лекция 2. Основные понятия реляционной модели данных
====================================================

1.  **Отношения и их свойства. Домены**

В реляционной модели используется математическая теория отношений (название
"реляционная" происходит от relation - "отношение", "связь").

>   К числу достоинств реляционного подхода можно отнести:

-   наличие небольшого набора абстракций, которые позволяют сравнительно просто
    моделировать большую часть распространенных предметных областей и допускают
    точные формальные определения, оставаясь интуитивно понятными;

-   наличие простого и в то же время мощного математического аппарата,
    опирающегося главным образом на теорию множеств и математическую логику и
    обеспечивающего теоретический базис реляционного подхода к организации баз
    данных;

-   возможность ненавигационного манипулирования данными без необходимости
    знания конкретной физической организации баз данных во внешней памяти;

-   простота реляционной БД, гибкость её структуры и удобство реализации БД на
    ЭВМ.

>   К числу недостатков реляционного подхода относят:

-   недостаточная эффективность реляционных СУБД;

-   присущая этим системам некоторая ограниченность (прямое следствие простоты)
    при использовании в так называемых нетрадиционных областях (наиболее
    распространенными примерами являются системы автоматизации проектирования),
    в которых требуются предельно сложные структуры данных;

-   невозможность адекватного отражения семантики (смысла)

>   предметной области.

>   Общая характеристика реляционной модели данных. Согласно К. Дейту
>   реляционная модель состоит из трех частей, описывающих разные аспекты
>   реляционного подхода: структурной части, манипуляционной части и целостной
>   части.

В структурной части модели фиксируется, что единственной структурой данных,
используемой в реляционных БД, является нормализованное n-арное отношение.

Целостностная часть описывает ограничения специального вида, которые должны
выполняться для любых отношений в любых реляционных БД. Целостность данных - это
механизм поддержания соответствия базы данных предметной области. В реляционной
модели данных существует два вида целостности: - целостность ссылок; -
целостность сущностей.

В манипуляционной части модели утверждаются два фундаментальных механизма
манипулирования реляционными БД - реляционная алгебра (базируется на теории
множеств) и реляционное исчисление (базируется на аппарате исчисления предикатов
первого порядка).

>   Структурная часть реляционной модели

Основными понятиями реляционных баз данных являются тип данных, домен, атрибут,
кортеж, первичный ключ и отношение.

Отношения удобно представлять в виде таблиц. На рисунке 2.1 представлена таблица
Т (отношение “Сотрудники” степени 5, арность равна 5), содержащая некоторые
сведения о работниках гипотетического предприятия. Строки таблицы соответствуют
кортежам. Каждая строка фактически представляет собой описание одного объекта
реального мира (в данном случае работника), характеристики которого содержатся в
столбцах. Столбцы в таблице, представляющей отношение, называют атрибутами.

>   Типы данных

>   Домены Атрибуты

Кортежи

>   Рисунок 2.1 − Основные компоненты 5-арного реляционного отношения
>   “Сотрудники”

Каждый атрибут определен на домене, поэтому домен можно рассматривать как
множество допустимых значений данного атрибута. Домен это семантическое
(смысловое) понятие. Домен можно рассматривать как подмножество значений
некоторого типа данных,

имеющих определенный смысл.

>   Свойства домена:

-   домен имеет уникальное имя (в пределах БД);

-   домен определен на некотором простом (атомарном) типе данных или на другом
    домене;

-   домен может иметь некоторое логическое условие, позволяющее описать
    подмножество данных, допустимых для данного домена (Домен D, имеющий смысл
    “возраст сотрудника” можно описать как следующее подмножество множества
    натуральных чисел

-   D={n∈N: n≥18 and n≤60}. Условие на строковый тип данных, задающий домен
    “Имя”?);

    -   домен несет смысловую нагрузку.

Несколько атрибутов одного отношения и даже атрибуты разных отношений могут быть
определены на одном и том же домене. На рисунке 2.1 атрибуты "Оклад" и "Премия"
определены на домене "Деньги". Понятие домена имеет смысловую нагрузку: данные
можно считать сравнимыми только тогда, когда они относятся к одному домену. В
рассматриваемом примере сравнение атрибутов "Табельный номер" и "Оклад" является
семантически некорректным, хотя они и содержат данные одного типа.

>   Определение 1. Атрибут отношения есть пара \<имя_атрибута:

имя_домена\>.

Имена атрибутов должны быть уникальны в пределах отношения. Часто имена
атрибутов отношения совпадают с именами соответствующих доменов.

Определение 2. Отношение R, определенное на множестве не обязательно различных
доменов D1, D2,..., Dn, содержит две части: заголовок и тело:

1.  Заголовок содержит фиксированное множество атрибутов или, точнее, пар \<имя-
    атрибута: имя-домена\>: {\<A1: D1\>, ..., \<An: Dn\>}, причем каждый атрибут
    Aj соответствует одному и только одному из лежащих в основе доменов Dj (j =
    1, 2, ..., n). Все имена атрибутов A1, A2, ..., An разные. Заголовок
    отношения статичен, он не меняется во время работы с БД.

Иное название заголовка отношения – схема отношения или заголовок таблицы.

Число атрибутов n называют степенью (или арностью) отношения R ( n=1 - унарное,
n=2 - бинарное, ..., n-арное отношение).

1.  Тело отношения содержит множество кортежей. Каждый кортеж содержит множество
    пар \<имя-атрибута: значение-атрибута\>: {

\<A1:V1\>, ..., \<An:Vn\> }. В каждом таком кортеже есть одна такая пара

\<имя-атрибута: значение-атрибута\>, т.е. \<Aj:Vj\>, для каждого атрибута Aj в
заголовке. Для любой пары \<Aj:Vj\> Vj принадлежит домену Dj, который связан с
атрибутом Aj.

Тело отношения динамично − оно может изменяться во время работы с БД, то есть
кортежи могут изменяться, добавляться и удаляться.

Мощность множества кортежей m называют кардинальным числом (или мощностью)
отношения R.

1.  Отношение обычно записывается в виде

>   R(A1, A2, ..., An) или еще короче R.

Определение 3. Реляционной базой данных называется набор отношений.

Определение 4. Схемой реляционной базой данных называется набор заголовков
отношений (именованных схем отношений), входящих в БД.

Хотя любое отношение можно изобразить в виде таблицы, но нужно понимать, что
отношения не являются таблицами и что не любая таблица может представить
отношение.

Различаются два вида отношения. Это переменная отношения и значение отношения.
Переменная отношения - это обычная переменная, такая же как и в языках
программирования, т.е. именованный объект, значение которого может изменяться со
временим. А значение этой переменной в любой момент времени и будет значением
отношения.

В таблице 2.1 представлены “табличные” синонимы терминов реляционной модели
данных.

>   Таблица 2.1 − “Табличные” синонимы терминов реляционной модели данных

| Реляционный термин                      | ”Табличный” термин                     |
|-----------------------------------------|----------------------------------------|
| База данных                             | Набор таблиц                           |
| Схема базы данных                       | Набор заголовков таблиц                |
| Отношение, сущность                     | Таблица                                |
| Схема отношения                         | Заголовок таблицы                      |
| Домен                                   | Общая совокупность допустимых значений |
| Заголовок отношения                     | Заголовок таблицы                      |
| Тело отношения                          | Тело таблицы                           |
| Атрибут отношения                       | Наименование столбца таблицы           |
| Кортеж отношения                        | Строка (или запись) таблицы            |
| Степень (-арность) отношения            | Количество столбцов таблицы            |
| Мощность отношения (кардинальное число) | Количество строк таблицы               |
| Первичный ключ                          | Уникальный идентификатор               |

>   Фундаментальные свойства отношений

1.  Отсутствие кортежей-дубликатов**.** Из этого свойства вытекает наличие у
    каждого кортежа первичного ключа. Для каждого отношения, по крайней мере,
    полный набор его атрибутов является

первичным ключом. При определении первичного ключа должно соблюдаться требование
"минимальности", т.е. в него не должны входить те атрибуты, которые можно
отбросить без ущерба для основного свойства первичного ключа - однозначно
определять кортеж.

То свойство, что отношения не содержат кортежей-дубликатов, следует из
определения отношения как множества кортежей.

1.  Отсутствие упорядоченности кортежей – следует из определения
    отношения-экземпляра как множества кортежей.

2.  Отсутствие упорядоченности атрибутов. Атрибуты отношений не упорядочены,
    поскольку по определению схема отношения есть множество пар {имя-атрибута :
    имя-домена}. Для ссылки на значение атрибута в кортеже отношения всегда
    используется имя атрибута. Это свойство позволяет, например, модифицировать
    схемы существующих отношений не только путем добавления новых атрибутов, но
    и путем удаления существующих атрибутов.

3.  Атомарность значений атрибутов. Значения всех атрибутов являются атомарными,
    то есть принадлежащими к простым типам данных без внутренней структуры
    (вернее внутренняя структура атрибутов не учитывается). Это следует из
    определения домена как потенциального множества значений простого типа
    данных, т.е. среди значений домена не могут содержаться множества значений
    (отношения).

Из свойств отношений следует, что не каждая таблица может задавать отношение.
Для того, чтобы некоторая таблица задавала отношение, необходимо:

1.  чтобы таблица имела простую структуру (содержала бы только строки и столбцы,
    причем, в каждой строке было бы одинаковое количество полей),

2.  в таблице не должно быть одинаковых строк,

3.  любой столбец таблицы должен содержать данные только одного типа,

4.  все используемые типы данных должны быть простыми.

Таблицу Т на рисунке 2.1 можно рассматривать как изображение отношения (в смысле
определения отношения), если в таблице выполняются следующие условия:

1.  есть некоторые, лежащие в основе столбцов домены;

2.  каждый столбец соответствует только одному из этих доменов;

3.  каждая строка представляет кортеж;

4.  каждое значение атрибута принадлежит соответствующему домену.

Если мы приняли все эти правила интерпретации, то тогда и только тогда можно
говорить, что таблица - это приемлемое изображение отношения.

>   Пример. Таблица 2.2 является отношением, а таблицы 2.3 и 2.4

-   нет.

>   Таблица 2.2

| 25 | Иванов | Иван  |
|----|--------|-------|
| 28 | Петров | Семен |
| 30 | Серов  | Петр  |

>   Таблица 2.3

| 25   | Иван   | Иванов |
|------|--------|--------|
| 28   | Петров | Семен  |
| Петр | Серов  | 30     |

>   Таблица 2.4

| 25 | Иванов     | Иван   |
|----|------------|--------|
| 28 | Семен      | Петров |
| 30 | Серов Петр |        |

Понятие ключа в отношении
=========================

Первичный ключ (PRIMARY KEY, PK) − это просто уникальный идентификатор для
некоторого отношения. Однако первичный ключ на самом деле является частным
случаем более общего понятия потенциального ключа.

Определение 5. Пусть R - некоторое отношение. Тогда потенциальный ключ,
например, K для R - это подмножество множества атрибутов R, обладающее
следующими свойствами:

1.  Свойством уникальности. Нет двух различных кортежей в отношении R с
    одинаковым значением K.

2.  Свойством неизбыточности. Никакое из подмножеств K не обладает свойством
    уникальности.

Таким образом, каждое отношение имеет хотя бы один потенциальный ключ, так как
не содержит одинаковых кортежей, то есть поскольку кортежи уникальны, то, по
крайней мере, комбинация всех атрибутов обладает свойством уникальности и
поэтому возможны два варианта:

1.  Либо эта комбинация обладает свойством неизбыточности, а значит, будет
    потенциальным ключом.

2.  Либо существует по крайней мере одно подходящее подмножество этой
    комбинации, заведомо обладающее свойством уникальности и к тому же
    обладающее свойством неизбыточности.

На практике в качестве первичного ключа используют несколько атрибутов, а не все
атрибуты. Если кортежи идентифицируются только сцеплением значений нескольких
атрибутов, то говорят, что отношение имеет составной ключ.

На практике также очень часто в качестве первичного ключа используют суррогатный
(искусственный) ключ – данный ключ не является свойством сущности, но уникален и
его просто генерировать. Причина важности потенциальных ключей заключается в
том,

что они обеспечивают основной механизм адресации на уровне кортежей в
реляционной системе. Следовательно, единственный гарантируемый способ точно
указать на какой-нибудь кортеж – это указать значение потенциального ключа.

>   Выводы из этого определения можно сделать следующие:

1.  Отношения, которые не имеют потенциальных ключей (т.е. допускающие
    дублирование кортежей), ограничивают отображение нарушений или отклонений от
    нормального режима работы в определенных обстоятельствах.

2.  Система, в которой не используются потенциальные ключи, иногда ограничена в
    возможностях отображения состояния, которое не является действительно
    реляционным, даже если используемые в ней отношения не допускают
    дублирования кортежей.

>   Первичные и альтернативные ключи

Базовое отношение может иметь больше одного потенциального ключа (Базовое
отношение это отношение реально существующее в БД, а не возникающее в результате
выполнения запроса.). В таком случае один из потенциальных ключей должен быть
выбран в качестве первичного ключа в базовом отношении, остальные потенциальные
ключи, если они есть, будут называться альтернативными (возможными) ключами. В
приведенном на рис. 1 примере, в качестве первичного ключа можно выбрать атрибут
"Табельный номер" T\#, поскольку его значение уникально для каждого работника
предприятия. Тогда атрибут "Имя" NAME будет альтернативным ключом.

Следовательно, каждое базовое отношение должно иметь всегда первичный ключ.

Пример. На рисунке 2.2 изображено множество потенциальных ключей некоторого
отношения. Очевидно, что множество потенциальных ключей отношения {K} равно
множеству альтернативных ключей {AltK} объединенному с первичным ключем

{PK}, то есть {K}={AltK}∪{PK}.

>   Рисунок 2.2 − Множество потенциальных ключей отношения {K}

>   Внешние ключи

![](media/1d28f0a8e7104fdbb29e013228cff72e.png)

Для отражения связей между кортежами разных отношений используется дублирование
их ключей. Пример, содержащий сведения о подразделениях предприятия и работающих
в них сотрудниках, применительно к реляционной модели будет иметь вид (рисунок
2.3):

>   Рисунок 2.3 − База данных о подразделениях и сотрудниках предприятия
>   (фрагмент)

Связь между отношениями ОТДЕЛ и СОТРУДНИК создается путем копирования первичного
ключа "Номер_отдела" из первого отношения во второе. Таким образом:

-   для того, чтобы получить список работников данного отдела, необходимо:

1.  из таблицы ОТДЕЛ установить значение атрибута

"Номер_отдела", соответствующее данному "Наименованию_отдела"

1.  выбрать из таблицы СОТРУДНИК все записи, значение атрибута "Номер_отдела"
    которых равно полученному на предыдушем шаге.

    -   для того, чтобы узнать в каком отделе работает сотрудник, нужно
        выполнить обратную операцию:

2.  определяем "Номер_отдела" из таблицы СОТРУДНИК

3.  по полученному значению находим запись в таблице

ОТДЕЛ.

Атрибуты, представляющие собой копии ключей (потенциальных или, как правило,
первичных ключей) других отношений, называются внешними ключами (FOREIGN KEY,
FK).

В реляционной модели подразумевается, что внешние ключи могут ссылаться точно на
первичные ключи и ни как не иначе.

Определение внешнего ключа: Пусть *R*2 - базовое отношение. Тогда внешний ключ
*FK* в отношении *R*2 – это подмножество множества атрибутов R2, такое что:

1.  существует базовое отношение *R*1 с потенциальным ключом

>   *CK* (*CK* − вторичный ключ);

1.  каждое значение *FK* в текущем значении *R*2 всегда совпадает со значением
    *CK* некоторого кортежа в текущем значении *R*1.

Внешний ключ должен принадлежать к тому же домену, что и первичный ключ. Не
первичный ключ может быть внешним ключом. Ключ *CK* называют вторичным ключом.
Ключ *CK* и внешний ключ *FK* называют полями связи отношений *R*1 и *R*2.
Вторичный и первичный ключ в общем случае могут не совпадать.

>   Отношение *R*1 называют родительским, а отношение *R*2 –

дочерним.

Ссылочная целостность
=====================

Целостность данных - это механизм поддержания соответствия базы данных
предметной области. В реляционной модели данных существует два вида целостности:

-   целостность ссылок;

-   целостность сущностей.

Требование к БД состоит в том, что любой кортеж любого отношения БД должен быть
отличим от любого другого кортежа этого отношения, то есть, любое отношение
должно обладать первичным ключом. Это требование автоматически удовлетворяется,
если в системе не нарушаются базовые свойства отношений.

>   Целостность сущностей

>   Требование целостности сущностей заключается в следующем: каждый кортеж
>   любого отношения должен отличаться от любого другого кортежа этого отношения
>   (т.е. любое отношение должно обладать первичным ключом).

>   Вполне очевидно, что если кортежи в рамках одного отношения не уникальны, то
>   в БД может храниться противоречивая информация об одном и том же объекте.
>   Поддержание целостности сущностей обеспечивается средствами СУБД. Это
>   осуществляется с помощью двух ограничений:

-   при добавлении записей в таблицу проверяется уникальность их первичных
    ключей;

-   не позволяется изменение значений атрибутов, входящих в первичный ключ.

Определитель NULL (логическая величина "неизвестно") указывает, что значение
атрибута в настоящий момент неизвестно или неприемлемо для этого кортежа.
Другими словами, либо это значение не входит в область определения некоторого
кортежа, либо никакое значение еще не задано. Ключевое слово *NULL* представляет
собой способ обработки неполных или необычных данных.

Целостность сущностей – в базовом отношении ни один атрибут первичного ключа не
может содержать значений, обозначаемых определителем *NULL*. Если допустить
присутствие определителя *NULL* в любой части первичного ключа, это равноценно
утверждению, что не все его атрибуты необходимы для уникальной идентификации
кортежей, что противоречит определению первичного ключа.

>   Целостность ссылок

Объекты реального мира представляются в реляционной БД в виде кортежей
нескольких отношений, связанных между собой. При этом:

1.  Связи между данными отношения описываются в терминах функциональных
    зависимостей.

2.  Для отражения функциональных зависимостей между кортежами разных отношений
    используется дублирование первичного ключа одного отношения (родительского)
    в другое (дочернее). Атрибуты, представляющие собой копии ключей
    родительских отношений, называются внешними ключами.

Требование целостности по ссылкам (ссылочной целостности) состоит в следующем:
для каждого значения внешнего ключа, появляющегося в дочернем отношении, в
родительском отношении должен найтись кортеж с таким же значением первичного
ключа (рисунок 2.4).

![](media/0c62f6170b7a7e79be2e1c682be98181.png)

>   Родительское отношение

| ОТДЕЛ |             |
|-------|-------------|
| 3     | Бухгалтерия |

>   Первичный ключ

>   Дочернее отношение

| СОТРУДНИК |   |        |
|-----------|---|--------|
| 1         | 3 | Петров |

![](media/e71b503fe317dced4efa8cc8dbc7dc08.png)

>   …

| 4 | 3 | Иванов |
|---|---|--------|


>   …

| 12 | 3 | Сидорова |
|----|---|----------|


>   Первичный ключ Внешний ключ

>   Рисунок 2.4 − Связь между отношениями “ОТДЕЛ” и

“СОТРУДНИК” типа “один ко многим” (1:M)

Или иначе, требование ссылочной целостности означает, что БД не должна содержать
несогласованных значений внешних ключей. Несогласованное значение означает
значение внешнего ключа, для

которого не существует отвечающего ему значения соответствующего потенциального
ключа в соответствующем родительском отношении. Проще говоря, если *B* ссылается
на *A*, тогда *A* должно существовать. Поэтому, когда говорят – поддержка
внешних ключей и поддержка ссылочной целостности, то подразумевают одно и то же.

Как правило, поддержание целостности ссылок также возлагается на СУБД. Например,
она может не позволить пользователю добавить запись, содержащую внешний ключ с
*NULL-* значением.

Требование целостности по ссылкам (или согласованного внешнего ключа) состоит в
том, что для каждого значения внешнего ключа, появляющегося в ссылающемся
отношении, в отношении, на которое ведет ссылка, должен найтись кортеж с таким
же значением первичного ключа, либо значение внешнего ключа должно быть
неопределенным (т.е. ни на что не указывать). Для примера (рис. 2.4) это
означает, что если для сотрудника указан номер отдела, то этот отдел должен
существовать.

При обновлении ссылающегося отношения (вставке новых кортежей или модификации
значения внешнего ключа в существующих кортежах) достаточно следить за тем,
чтобы не появлялись некорректные значения внешнего ключа. Но как быть при
удалении кортежа из отношения, на которое ведет ссылка?

Здесь существуют три подхода, каждый из которых поддерживает целостность по
ссылкам.

1.  Запрещается производить удаление кортежа, на который существуют ссылки (т.е.
    сначала нужно либо удалить ссылающиеся кортежи, либо соответствующим образом
    изменить значения их внешнего ключа).

2.  При удалении кортежа, на который имеются ссылки, во всех ссылающихся
    кортежах значение внешнего ключа автоматически становится неопределенным.

3.  При удалении кортежа из отношения, на которое ведет ссылка, из ссылающегося
    отношения автоматически удаляются все ссылающиеся кортежи (каскадное
    удаление).

В реляционных СУБД обычно можно выбрать способ поддержания целостности по
ссылкам для каждой отдельной ситуации определения внешнего ключа.

Корпоративные ограничения целостности **–** дополнительные правила поддержки
целостности данных, определяемые пользователями БД. Например, учебным отделом в
соответствии с учебной нагрузкой определена численность преподавателей каждой из
кафедр, превысить которую нельзя, но можно взять двух преподавателей по пол
ставки на одну должность.

>   Контрольные вопросы:

1.  Обосновать место реляционных баз данных среди других типов баз данных.

2.  Каковы достоинства реляционных баз данных?

3.  Каковы недостатки реляционных баз данных?

4.  Перечислить и дать определения основным понятиям реляционных баз данных
    (отношение, домен, атрибут, кортеж, схема базы данных, арность отношения,
    мощность отношения, кардинальное число, потенциальный ключ, первичный ключ,
    альтернативный ключ, внешний ключ).

5.  Что такое реляционная модель и перечислить основные её части?

6.  Что такое целостность сущностей и целостность ссылок?

7.  Что такое корпоративные ограничения целостности?

>   Лекция 3. **Нормальные формы отношений**

Функциональные зависимости
==========================

Реляционная база данных содержит как структурную, так и семантическую
информацию. Структура базы данных определяется числом и видом включенных в нее
отношений, и связями типа "один ко многим", существующими между кортежами этих
отношений. Семантическая часть описывает множество функциональных зависимостей,
существующих между атрибутами этих отношений.

Концепция функциональной зависимости, является фундаментальной в теории
реляционных базах данных. По сути, функциональная зависимость является связью
типа многие-к-одному между множествами атрибутов внутри данного отношения. Но
стоит разделять понятия значение отношения и набор всех возможных значений.
Сначала дадим определение функциональной зависимости для значения отношения.

>   Определение: Функциональная зависимость

В отношении R атрибут Y функционально зависит от атрибута X (X и Y могут быть
составными) в том и только в том случае, если каждому значению X соответствует в
точности одно значение Y: R **.** X

1.  R **.** Y.

Другими словами: если даны два атрибута X и Y некоторого отношения, то говорят,
что Y функционально зависит от X, если в любой момент времени каждому значению X
соответствует ровно одно значение Y.

Функциональная зависимость обозначается X → Y (и читается либо как X
функционально определяет Y, либо как X стрелка Y).

Можно сказать, что функциональные зависимости представляют собой связи типа
"один ко многим", существующие внутри отношения.

Некоторые функциональные зависимости могут быть нежелательны.

Иначе говоря, если два кортежа отношения R совпадают по значению X, они так же
совпадают и по значению Y.

>   Рассмотрим отношение SCP, представленное в таблице 3.1.

>   Таблица 3.1 − Отношение SCP

| SCP                    |              |             |      |
|------------------------|--------------|-------------|------|
| S\# - номер поставщика | CITY - город | P\# - товар | QTY- |
| S1                     | Харьков      | Р1          | 100  |
| S1                     | Харьков      | Р2          | 100  |
| S2                     | Киев         | Р1          | 200  |
| S2                     | Киев         | Р2          | 200  |
| S3                     | Киев         | Р2          | 300  |
| S4                     | Харьков      | Р2          | 400  |
| S4                     | Харьков      | Р4          | 400  |
| S4                     | Харьков      | Р5          | 400  |

>   количество товара в поставке

Отношение SCP удовлетворяет приведенной ниже функциональной зависимости,
поскольку все кортежи отношения с одинаковым значением атрибута S\# имеют
одинаковое значение атрибута CITY:

>   { S\# } → { CITY }

На самом деле это отношение удовлетворяет нескольким функциональным
зависимостям:

>   { S\#, P\# } → { QTY }

>   { S\#, P\# } → { CITY }

>   { S\#, P\# } → { CITY, QTY }

>   { S\#, P\# } → { S\# }

>   { S\#, P\# } → { S\#, P\#, CITY, QTY }

>   { S\# } → { QTY }

>   { QTY } → { S\# }

Левая и правая стороны символической записи функциональной зависимости иногда
называют детерминантом и зависимой частью соответственно. Как говорится в
определении, детерминант и зависимая часть являются множествами атрибутов. Когда
множество содержит один атрибут, оно называется одноэлементным множеством,
скобки опускают и символическая запись принимает вид: S\# → CITY

Как было замечено ранее, эти функциональные зависимости относятся к значениям
отношения. Однако при рассмотрении переменных отношения, например, базовых
отношений, интерес представляет не столько функциональные зависимости для
определенного в некоторый момент времени значения, сколько функциональные
зависимости, выполняющиеся для всех возможных значений данной переменной.
Например, в случае отношения SCP функциональная зависимость S\# → CITY
выполняется для всех возможных значений SCP, поскольку в любой момент времени
данному поставщику соответствует в точности один город; таким образом любые два
кортежа отношения SCP в один и тот же момент времени и с одним и тем же номером
поставщика должны соответствовать одному и тому же городу. Практически
утверждение, что данная функциональная зависимость выполняется всегда, является
ограничением целостности для отношения SCP, поскольку при этом накладываются
определенные ограничения на все допустимые значения.

Определение. Функциональная зависимость для набора всех возможных значений
отношений

Пусть R является переменной отношения, а X и Y - произвольными подмножествами
множества атрибутов отношения R. Тогда Y функционально зависимо от X, что в
символическом виде записывается так: X→Y

тогда и только тогда, когда для любого допустимого значения отношения R каждое
значение X связанно в точности с одним значением Y.

Иначе говоря, для любого допустимого значения отношения R, когда бы два кортежа
отношения R ни совпадали по значению X, они также совпадают и по значению Y.

Следовательно, более правильно использовать термин функциональная зависимость в
последнем безотносительном ко времени смысле.

Вот некоторые безотносительные зависимости для переменной отношения SCP:

>   { S\#, P\# } → QTY

>   { S\#, P\# } → CITY

>   { S\#, P\# } → { CITY, QTY }

>   { S\#, P\# } → S\#

>   { S\#, P\# } → { S\#, P\#, CITY, QTY } S\# → CITY

Обратите внимание, что часть функциональных зависимостей в данном случае не
выполняются:

>   S\# → QTY QTY → S\#

Иначе говоря, например, такое утверждение, как число деталей (товара) для каждой
поставки данного поставщика одинаково, истинно для значений таблицы,
представленной на рисунке, но не верно для всех возможных допустимых значений
отношения SCP.

Следует отметить, что если X является потенциальным ключом отношения R, например
X является первичным ключом, то все атрибуты Y отношения R должны быть
обязательно функционально зависимы от X.

Одной из важных целей является сокращения до минимума числа функциональных
зависимостей внутри отношения. Одна из причин, этого состоит в том, что
функциональные зависимости являются ограничениями целостности, поэтому при
каждом обновлении данных в СУБД все они должны быть проверены. Следовательно,
для заданного множества функциональных зависимостей S желательно найти такое
множество T, которое было бы гораздо меньшего размера, чем множество S, причем
каждая функциональная зависимость множества S могла быть заменена функциональной
зависимостью множества T. Поэтому задача поиска подходящего множества Т
представляет большой практический интерес.

Определение. Взаимно независимые атрибуты – два или более атрибута взаимно
независимы, если ни один из этих атрибутов не является функционально зависимым
от других.

>   Определение. Избыточная функциональная зависимость Избыточная функциональная
>   зависимость – зависимость,

заключающая в себе такую информацию, которая может быть получена на основе
других зависимостей, имеющихся в базе данных.

1, 2 и 3-я нормальные формы и НФ Бойса-Кодда
============================================

Очевидно, что для одной и той же предметной области реляционные отношения можно
спроектировать множеством различных способов. Например, можно спроектировать
несколько отношений с большим количеством атрибутов, или, наоборот, разнести все
атрибуты по большому числу мелких отношений. Как определить, по каким признакам
нужно помещать атрибуты в те или иные отношения? Какие отношения “хорошие”, а
какие – “плохие”?

Понятие нормализации введено Коддом Э.Ф. в начале 70-х годов. В настоящее время
под нормализацией реляционной БД понимают формальный процесс удаления избыточных
данных, основанный на определенных математических понятиях реляционной теории.

Корректной считается такая схема базы данных, в которой отсутствуют избыточные
функциональные зависимости. В противном случае приходится прибегать к процедуре
декомпозиции (разложения)

имеющегося множества отношений. Суть декомпозиции заключается в том, что
отношение разбивается, например, на два отношения по значению определенного
атрибута. (Декомпозиция должна быть выполнена без потерь информации в БД.) При
этом порождаемое множество содержит большее число отношений, которые являются
проекциями отношений исходного множества.

Обратимый пошаговый процесс замены данной совокупности отношений другой схемой
отношений с устранением избыточных функциональных зависимостей называется
нормализацией.

Условие обратимости требует, чтобы декомпозиция сохраняла эквивалентность схем
при замене одной схемы на другую, т.е. в результирующих отношениях:

-   не должны появляться ранее отсутствовавшие кортежи;

-   на отношениях новой схемы должно выполняться исходное множество
    функциональных зависимостей.

Нормализация – это разбиение таблицы на две или более таблицы, обладающие
лучшими свойствами при включении, изменении и удалении данных. Окончательная
цель нормализации сводится к получению такого проекта базы данных, в котором
каждый факт появляется лишь в одном месте, т.е. исключена избыточность
информации.

>   Нормализация выполняется с целью:

-   исключения возможной противоречивости хранимых данных

(основная цель),

-   минимизации занимаемой данными памяти,

-   оптимизации затрат на выполнение различных операций над данными БД.

Каждая таблица в реляционной БД удовлетворяет условию, в соответствии с которым
в позиции на пересечении каждой строки и столбца таблицы всегда находится
единственное атомарное значение, и никогда не может быть множества таких
значений. Любая таблица, удовлетворяющая этому условию, называется
нормализованной. Фактически, ненормализованные таблицы, т.е. таблицы, содержащие
повторяющиеся кортежи, даже не допускаются в реляционной БД.

Существует 6 нормальных форм, в которых могут находиться отношения внутри БД
(рисунок 3.1).

Именно в таком отношении (рис. 1) и находятся между собой все формы. То есть
нормальная форма более низкого порядка является подмножеством нормальной формы
более высокого порядка. Как правило большинство современных баз данных находятся
в нормальной форме Бойса-Кодда (НФБК). Дальнейшая нормализация является часто
просто невыполнимой или ненужной из-за избыточности, которую она дает.

>   Рисунок 3.1 − Взаимосвязь нормальных форм

>   Основные свойства нормальных форм:

-   каждая следующая нормальная форма в некотором смысле лучше предыдущей;

-   при переходе к следующей нормальной форме свойства предыдущих нормальных
    форм сохраняются.

В основе процесса проектирования БД лежит метод нормализации – декомпозиция
отношения, находящегося в предыдущей нормальной форме, в два или более
отношения, удовлетворяющих требованиям следующей нормальной формы. Декомпозиция,
является главным инструментом при нормализации. При нормализации должна
производится декомпозиция отношения без потерь информации.

>   Пример декомпозиции с потерями и без потерь. Рассмотрим отношение
>   поставщиков S, имеющее вид:

| S   |        |         |
|-----|--------|---------|
| S\# | STATUS | CITY    |
| S3  | 30     | Киев    |
| S5  | 30     | Полтава |

Над таким отношением можно провести следующие декомпозиции:

>   1.

>   2.

>   32

Суть декомпозиции заключается в том, что отношение разбивается на два отношения
по значению определенного атрибута. В первом случае это атрибут S\#, во втором –
STATUS.

В первом случае информация не утрачивается, поскольку отношения SST и SC все еще
содержат данные о том, что поставщик S3 имеет статус 30 и находится в Киеве, а
поставщик S5 имеет статус

30 и находится в Полтаве. Иначе говоря, первая декомпозиция является
декомпозицией без потерь.

Во втором случае, наоборот некоторая информация утрачивается, поскольку оба
поставщика имеют статус 30, но при этом нельзя сказать, какой из них в каком
городе находится. Другими словами вторая декомпозиция не является декомпозицией
без потерь. Именно, для того чтобы декомпозиция была выполнена правильно, нужно
учитывать свойство функциональной зависимости

отношений.

>   Определение первой нормальной формы:

Отношение находится в 1NF если значения всех его атрибутов атомарны (неделимы).

Первая нормальная форма (1НФ) – это обычное отношение. В реляционной БД любое
отношение автоматически находится в 1НФ.

>   Свойства 1НФ (это и свойства отношения):

-   в отношении нет одинаковых кортежей,

-   кортежи не упорядочены,

-   атрибуты не упорядочены и отличаются по наименованию,

-   все значения атрибутов атомарны.

>   Пример. Рассмотрим отношение First (пусть поставщик находится в одном
>   городе) (таблица 3.2).

>   Таблица 3.2 − Отношение First

| First                  |                            |              |       |                                   |
|------------------------|----------------------------|--------------|-------|-----------------------------------|
| S\# - номер поставщика | STATUS – статус поставщика | CITY - город | P\# - | QTY- количество товара в поставке |
| S1                     | 20                         | Харьков      | P1    | 300                               |
| S1                     | 20                         | Харьков      | P2    | 200                               |
| S1                     | 20                         | Харьков      | P3    | 400                               |
| S1                     | 20                         | Харьков      | P4    | 200                               |
| S1                     | 20                         | Харьков      | P5    | 100                               |
| S1                     | 20                         | Харьков      | P6    | 100                               |
| S2                     | 10                         | Киев         | P1    | 300                               |
| S2                     | 10                         | Киев         | P2    | 400                               |
| S3                     | 10                         | Киев         | P2    | 200                               |
| S4                     | 20                         | Харьков      | P2    | 200                               |
| S4                     | 20                         | Харьков      | P4    | 300                               |
| S5                     | 30                         | Cумы         | P5    | 400                               |

>   товар

Отношение First имеет следующие функциональные зависимости:

>   В этом примере имеется функциональная зависимость CITY→STATUS - статус
>   поставщика определяется его местоположением.

Такое универсальное отношение First имеет следующие недостатки:

1.  Избыточность. Данные хранятся с большой избыточностью –

повторяются города, статусы поставщиков, виды товара и т.п.

1.  Аномалии обновления (Update). Названия, например, городов (статусов,
    товаров) повторяются во многих кортежах, поэтому если поставщик меняет
    город, то такое изменение необходимо одновременно выполнить во многих
    местах, иначе отношение станет некорректным. Следовательно, при обновлениях
    необходимо просматривать всю таблицу для нахождения и изменения всех
    соответствующих кортежей

2.  Аномалии включения (Insert). В БД не может быть записан новый поставщик (S6,
    30, Полтава, Р2), если продукт (Р2) им пока не поставляется. Другими словами
    в базу нельзя занести, например, информацию о поставщике, не указав какой
    товар и сколько товара он поставил.

3.  Аномалии удаления (Delete). При удалении некоторых данных может произойти
    потеря другой важной информации. Например проблема возникает при
    необходимости удаления товара (Р5). При таком удалении будут утрачены
    сведения о поставщике этого товара (S5).

Следовательно, есть необходимость перехода ко второй нормальной форме.

>   Определение. Полная функциональная зависимость

Неключевой атрибут функционально полно зависит от составного ключа если он
функционально зависит от всего ключа в целом, но не находится в функциональной
зависимости от какого-либо из входящих в него атрибутов. (Функциональная
зависимость R.X (r)

1.  называется полной, если атрибут Y не зависит функционально от любого точного
    подмножества X.)

В отношении First неключевой атрибут CITY зависит от части ключа S\#.

>   Определение второй нормальной формы:

Отношение R находится во второй нормальной форме (2NF) в том и только в том
случае, когда оно находится в 1NF, и каждый неключевой атрибут полностью зависит
от первичного ключа.

Для того чтобы перевести наше отношение во вторую нормальную форму, необходимо
провести его декомпозицию на два отношения SECOND

>   и SP следующим образом: SECOND { S\#, STATUS, CITY } SP { S\#, P\#, QTY }

что дает следующие новые отношения:

| SECOND |        |         |
|--------|--------|---------|
| S\#    | STATUS | CITY    |
| S1     | 20     | Харьков |
| S2     | 10     | Киев    |
| S3     | 10     | Киев    |
| S4     | 20     | Харьков |
| S5     | 30     | Сумы    |

Отношение SECOND имеет следующие функциональные зависимости:

>   S\# - первичный ключ, неключевые атрибуты CITY и STATUS взаимно зависимы.

>   Отношение SP имеет следующие функциональные зависимости:

>   Значения атрибута QTY

>   должны определяться составным первичным ключом S\# P\#.

>   Достоинства:

1.  Теперь в операциях вставки в отношение SECOND можно включить информацию о
    том, что поставщик находится, например, в Изюме, даже если он не поставляет
    никаких товаров.

2.  Операции удаления позволяют удалить информацию о поставке, в которой сведены
    все сведения о поставщике S3 и товаре P2, удаляя соответствующий кортеж из
    отношения SP, при этом информация о том, что поставщик S3 находится в Киеве,
    не утрачивается.

3.  В переработанной структуре название города для каждого поставщика
    встречается всего один раз, поскольку существует только один кортеж для
    данного поставщика в отношении SECOND. Иначе говоря, избыточность данных S\#
    - CITY устранена. Благодаря этому теперь можно раз и навсегда изменить в
    соответствующем кортеже

отношения SECOND название города для поставщика S1, например, вместо Харьков
задать Полтава.

Однако, несмотря на то, что исключена избыточность, отношение SECOND обладает
некоторыми недостатками:

Аномалии включения (Insert) - нельзя включить данные о некотором городе,
обладающим некоторым статусом, например, нельзя указать, что все поставщики из
Ровно обладают статусом 50, до тех пор пока в этом городе не существует
некоторого конкретного поставщика.

Аномалии удаления (Delete) - при удалении из отношения SECOND кортежа для
некоторого города будет удалена не только информация о данном поставщике, но
также информация о том, каким статусом обладал этот город. Например, при
удалении из отношения SECOND кортежа для поставщика S5 будет утрачена информация
о том, что для Cум был задан статус 30.

Аномалии обновления (Update) - в отношении SECOND статус для каждого города
повторяется несколько раз. Таким образом, при изменении значения статуса Харьков
с 20 на 30 возникнет либо проблема необходимости поиска в отношении SECOND всех
кортежей для Харьков, либо проблема получения несовместимого результата.

>   Для решения этой проблемы переходим к 3 нормальной форме. Определение.
>   Взаимно независимые атрибуты

Два или более атрибута взаимно независимы, если ни один из этих атрибутов не
является функционально зависимым от других.

>   В отношении SECOND атрибут STATUS зависит от атрибута

CITY.

Определение. Неключевой атрибут – это атрибут, который не входит в состав ключа
(в том числе и первичного ключа).

>   Определение третьей нормальной формы:

Отношение R находится в 3-ей НФ в том и только в том случае, когда оно находится
во 2NF, и все неключевые атрибуты взаимно независимы.

Для того чтобы перевести отношение SECOND в 3НФ необходимо выполнить следующую
декомпозицию:

>   SC { S\#, CITY }, CS { CITY, STATUS }

>   Получим такие таблицы:

На практике 3НФ схем отношений достаточна в большинстве случаев, и приведением к
3НФ процесс проектирования реляционной

базы данных обычно заканчивается. Однако в случае сложных отношений полезно
продолжить процесс нормализации.

Отношения SC и CS имеют следующие функциональные зависимости:

Все выше перечисленные формы нормализации и декомпозиция отношений были сделаны
исходя из определения, что каждое отношение имеет только один потенциальный ключ
(а именно первичный ключ), и рассматривается достаточно общий случай. Однако
существуют более сложные отношения вот с такими условиями:

1.  Отношение имеет два или более потенциальных ключа.

2.  Два потенциальных ключа являются сложными.

3.  Они перекрываются (т.е. имеют, по крайней мере, один общий атрибут).

Заметим, что на практике отношения с такими условиями встречаются достаточно
редко (для всех прочих отношений 3NF и BCNF эквивалентны).

Поэтому оригинальное определение 3НФ было впоследствии заменено более строгим
определением Бойса-Кодда, для которого было принято отдельное название –
нормальная форма Бойса-Кодда (НФБК). Эта нормальная форма вводит дополнительное
ограничение по сравнению с 3НФ.

>   Определение нормальной формы Бойса-Кодда(BCNF):

Отношение R находится в BCNF тогда и только тогда, если оно находится в 3НФ и
когда детерминанты всех функциональных зависимостей являются потенциальными
ключами. (\* Отношение находится в НФБК, если любая функциональная зависимость
между его полями сводится к полной функциональной зависимости от возможного
ключа [5].)

Стоит отметить также, что определение НФБК (\*) концептуально проще, чем
определение ЗНФ, поскольку в нем нет явных ссылок на 1НФ и 2НФ.

На практике НФ Бойса-Кодда лежит в основе современных методологий анализа, когда
с помощью некоторого абстрактного инструмента, который определяет правила
изображения законов работы и потоков информации в исследуемой предметной
области, в проектируемые отношения специально вносят атрибут, который выполняет
только роль первичного ключа и только от которого функционально зависят
остальные атрибуты отношения. Таким образом, проектировщик не ищет первичный
ключ в множестве атрибутов, а искусственно вводит атрибут, назначая ему роль
первичного ключа. Такой подход очень упрощает работу с БД и формализует подход к
их проектированию.

Таким образом основная идея процедуры нормализации состоит в систематическом
приведении отношения R (отношение R обладает функциональными зависимостями,
многозначными зависимостями и зависимостями соединения) к набору меньших
отношений, который в некотором заданном смысле эквивалентен отношению R, но
более предпочтителен. Каждый этап процесса приведения состоит из разбиения на
проекции отношений, полученных на предыдущем этапе. При этом заданные
ограничения используются на каждом шаге процедуры нормализации для выбора
проекций на следующем этапе.

>   Алгоритм нормализации (приведения к НФБК):

1.  (приведение к 1НФ). Задается одно или несколько отношений, отображающих
    понятия предметной области. По модели предметной области (а не по
    отношениям) выписываются обнаруженные функциональные зависимости. Все
    отношения автоматически находятся в 1НФ.

2.  (приведение к 2НФ). Если в некоторых отношениях обнаружена зависимость от
    части составного ключа, то проводим декомпозицию этих отношений на несколько
    отношений следующим образом – те атрибуты, которые зависят от части сложного
    ключа выносятся в отдельное отношение вместе с этой частью ключа. В исходном
    отношении остаются все ключевые атрибуты.

3.  (приведение к 3НФ). Если в некоторых отношениях обнаружена зависимость
    некоторых неключевых атрибутов от других неключевых атрибутов, то проводим
    декомпозицию этих отношений следующим образом – те неключевые атрибуты,
    которые зависят от других неключевых атрибутов, выносятся в отдельное
    отношение. В новом отношении ключом становится детерминант функциональной
    зависимости.

4.  (приведение к НФБК). Если имеются отношения, имеющие несколько потенциальных
    ключей, то необходимо проверить, имеются ли функциональные зависимости,
    детерминанты которых не являются потенциальными ключами. Если такие
    функциональные зависимости имеются, то необходимо провести дальнейшую
    декомпозицию отношений. Те атрибуты, которые зависят от детерминантов, не
    являющихся потенциальными ключами, выносятся в отдельное отношение вместе с
    детерминантами.

Правила 1-4 могут быть сконцентрированы в одном: "Исходное отношение следует
разбить на проекции для исключения всех функциональных зависимостей, в которых
детерминанты не являются потенциальными ключами".

После приведения таблиц БД к НФБК можно сделать вывод, что любое изменение
информации приведет к изменению только одной записи таблицы. Это и является
результатом нормализации: множество таблиц, которые обновляются максимально
легким способом, с помощью всего одного фрагмента данных.

4-я и 5-я нормальные формы
==========================

>   Многозначные зависимости и 4-ая НФ (4NF).

4НФ касается отношений, в которых имеются многозначные зависимости. В этом
случае используют декомпозицию, основанную на многозначных зависимостях.

Определение многозначной зависимости: Пусть R – отношение и X, Y, Z – некоторые
из его атрибутов (или непересекающиеся множества атрибутов). Тогда атрибуты Y и
Z многозначно зависят от X (обозначается X→→Y\|Z) тогда и только тогда, когда из
того, что в отношении R содержатся кортежи r1=(x, y, z1) и r2=(x, y1, z)
следует, что в отношении R содержится также и кортеж r3=(x, y, z).

Многозначная зависимость является обобщением функциональной зависимости и
рассматривает соответствия между множествами значений атрибутов.

Очевидно, что каждая функциональная зависимость является многозначной, но не
каждая многозначная зависимость является функциональной.

Определение четвертой нормальной формы: Отношение R находится в 4-ой НФ (4NF) в
том и только в том случае, когда оно находится в НФБК и если в случае
существования многозначной зависимости A→→B\|С все остальные атрибуты R
функционально зависят от A. (Или другими словами: Отношение находится в 4NF если
оно находится в BCNF и в нем отсутствуют многозначные зависимости, не являющиеся
функциональными зависимостями.)

>   Зависимости по соединению и 5-ая НФ (5NF)

До сих пор мы предполагали, что единственной операцией, необходимой для
устранения избыточности в отношении, была декомпозиция его на две проекции.
Однако, существуют отношения, для которых нельзя выполнить декомпозицию без
потерь на две проекции, но которые можно подвергнуть декомпозиции без потерь на
три (или более) проекций. Этот факт получил название зависимости по соединению,
а такие отношения называют 3-декомпозируемые отношения (ясно, что любое
отношение можно назвать "n- декомпозируемым", где n \>= 2).

Отношения, в которых имеются зависимости по соединению, не являющиеся
одновременно ни многозначными, ни функциональными, также характеризуются
аномалиями обновления. Поэтому, вводится понятие 5НФ.

>   Определение пятой нормальной формы:

Отношение R находится в 5-ой НФ (нормальной форме проекции-соединения - PJ/NF) в
том и только в том случае, когда

любая зависимость соединения в R следует из существования некоторого возможного
ключа в R.

5-ая НФ – это последняя НФ, которую можно получить путем декомпозиции. Ее
условия достаточно нетривиальны, и на практике 5НФ не используется. Заметим, что
зависимость соединения является обобщением как многозначной зависимости, так и
функциональной зависимости.

Как нормализация является процессом организации данных в манере, позволяющей
вносить изменения в БД без излишних операций, так денормализация представляет
собой обратный процесс, преднамеренно вносящий эту избыточность. С теоретической
точки зрения денормализация никогда не должна выполняться. Однако на практике
иногда денормализировать данные нужно в интересах производительности. Чрезмерно
нормализованная БД замедляет работу, так как из-за многочисленных связей между
таблицами серверу приходится выполнять большое число операций. Причем, проход по
связям между таблицами является для сервера одной из самых трудоемких операций.

>   Рекомендации по денормализация таблиц:

1.  если модель нормализованных данных содержит таблицы с составными первичными
    ключами (в ключе 4 и более полей), целесообразно денормализировать данные,
    введя произвольные суррогатные ключи;

2.  если в запросах очень часто используются вычисляемые значения (максимальные,
    минимальные и так далее), то средством денормализации данных может являться
    вставка этих вычисляемых данных в сами таблицы;

3.  разбиение экстремально больших таблиц на множество избыточных таблиц, в
    которые вынесены либо отдельные столбцы, либо отдельные строки (редко
    используемые) исходной таблицы;

4.  если запросы к некоторой таблице часто используют столбец (фрагмент) из
    другой таблицы, то можно внести в эту таблицу копию этого столбца
    (фрагмента).

Для денормализации таблиц должны существовать веские причины и денормализация в
обязательном порядке должна документироваться и обосновываться.

Типы связей
===========

Одно из основных требований к организации реляционной БД – это обеспечение
возможности поиска одних кортежей по значениям других, для чего необходимо
установить между отношениями связи.

Связь (relationship) – поименованная ассоциация между двумя отношениями
(сущностями), значимая для рассматриваемой предметной области. Связь – это
ассоциация между отношениями

(сущностями), при которой, как правило, каждый кортеж одного отношения,
называемого родительским отношением, ассоциирован с произвольным (в том числе
нулевым) количеством кортежей второго отношения, называемого
отношением-потомком, а каждый кортеж отношения-потомка ассоциирован в точности с
одним кортежем отношения-родителя.

Наибольшее распространение получили бинарные связи между отношениями. Бинарная
связь – это связь, в которую вступают ровно две сущности.

>   Связь обладает следующими характеристиками:

1.  степень связи (кардинальное число связи),

2.  обязательность (модальность) связи.

Важнейшее свойство связи – кардинальное число связи (мощность или степень
связи). Оно описывает максимально возможное количество связей для каждого
экземпляра сущностей, участвующих в связи.

>   Существуют следующие основные типы бинарных связей:

1.  Один-к-одному – в каждый момент времени каждому кортежу отношения А
    соответствует 0 или 1 кортеж отношения В.

>   1 1

>   1 1 Работник получает одну зарплату.

Классическим примером этого типа связи является связь муж- жена для тех стран,
где не разрешено многоженство.

1.  Один-ко-многим – каждому кортежу отношения А соответствует несколько
    кортежей отношения В.

>   1 М

>   1 М В доме проживает много жильцов.

Примеры этого типа связей – группа-студент, бригада-рабочий, поезд-вагон,
автобус-место и т.д.

>   Пример.

Исходя из значений атрибутов отношений “Группа” и “Студент” можно сказать, что
Группа1 состоит из Студент1, Студент2, Группа2 – из Студент3, Студент4, а
Группа3 – Студент5.

Многие-к-одному – множеству кортежей отношения А соответствует один кортеж
отношения В.

>   М 1

>   Несколько студентов

>   М 1 представляют собой группу.

1.  Многие-ко-многим – множеству кортежей отношения *А* соответствует множество
    кортежей отношения *В*. (Этот тип связи в реляционных БД непосредственно не
    поддерживается)

>   М М

>   М М

>   Например, студент-предмет, книга-читатель и т.д.

Реляционная модель не позволяет описать связи многие-ко- многим непосредственно,
а только с помощью промежуточного преобразования. Суть преобразования
заключается в разбиении связи многие-ко-многим на две связи один-ко-многим через
промежуточное отношение. Возьмем к примеру связь Предмет- Студент. Получается,
что один предмет может изучатся несколькими студентами и наоборот, несколько
студентов могут изучать один предмет. Для того, чтобы преобразовать это
отношение на два один- ко-многим вводится дополнительное отношение
Предмет_Студент, которое фактически определяет какой предмет, каким студентом
изучается:

Исходя из данных этих отношений видно, что Предмет1 изучается студентами
Студент1, Студент2 и Студент5. При этом можно сказать, что Студент1 изучает
предметы Предмет1, Предмет2. Характерной чертой этого преобразования является
возможность указать такие данные в отношениях, которые в данный момент времени
не связаны между собой, например, Предмет4 не изучается ни одним из студентов. А
Студент7, Студент6 и Студент3 не изучают предметов.

Вторым параметром связи может быть ее обязательность, называемая также
модальностью связи, или классом принадлежности.

>   Каждая из связей может иметь одну из двух модальностей:

1.  Модальность “может” соответствует необязательному классу принадлежности –
    экземпляр сущности может быть связан с одним или несколькими экземплярами
    другой сущности, а может и не связан ни с одним экземпляром другой сущности.

2.  Модальность “должен” соответствует обязательному классу принадлежности –
    каждый экземпляр сущности обязан быть связан с не менее чем одним
    экземпляром другой сущности.

>   Контрольные вопросы

1.  Что такое функциональная зависимость в значении отношения? Что такое
    функциональная зависимость для набора всех возможных значений отношений?

2.  Перечислить и дать определения наиболее распространенным в практике
    проектирования БД нормальным формам отношений, перечислить шаги перехода от
    более низкой нормальной формы к более высокой.

3.  Каковы недостатки 1НФ, которые устраняются в результате перехода ко 2НФ?

4.  Каковы недостатки 2НФ, которые устраняются в результате перехода к 3НФ?

5.  Каковы недостатки 3НФ, которые устраняются в результате перехода к форме
    Бойса-Кодда (BCNF)?

6.  Каковы недостатки BCNF, которые устраняются в результате перехода к 4НФ?

7.  Какова цель денормализации таблицы? Каковы основные рекомендации по
    денормализация таблиц?

8.  Какие типы бинарных связей поддерживаются (не поддерживаются) в базах
    данных?

9.  Какие существуют типы обязательности связей?

Лекция 4. Логическая и физическая модели базы данных
====================================================

>   Основные цели моделирования системы:

1.  скрыть неинтересные, несущественные детали моделируемой системы,

2.  заменить значительные по объему компоненты компактным символами,

3.  подчеркнуть важные (убрать незначительные) символы и связи,

4.  способствовать пониманию системы в целом.

При разработке реляционной БД обычно выделяется несколько уровней (этапов)
моделирования, с помощью которых происходит переход от предметной области к
конкретной реализации БД средствами конкретной СУБД.

>   Можно выделить следующие этапы моделирования реляционной

БД:

1.  Концептуальное моделирование.

>   Под концептуальной моделью понимается модель предметной

области – наши знания о предметной области, выраженные, например, в вербальном
виде (должностные инструкции, правила ведения дел в фирме и т.п.).

Под предметной областью понимается часть реального мира, данные о которой
необходимо отразить в БД.

1.  Логическое моделирование. Логическая модель данных (ЛМД) предметной области
    описывает понятия предметной области, их взаимосвязь, а также ограничения на
    данные, налагаемые предметной областью. Основное средство разработки ЛМД –
    различные варианты ER-диаграмм (Entity-Relationship, диаграммы
    сущность-связь). Чем больше атрибутов имеют отношения, разработанные в ходе
    ЛМД, тем медленнее будут выполняться операции обновления данных за счет
    затрат времени на перестройку большого количества индексов, создаваемых для
    таблиц. Увеличение числа отношений приводит к замедлению выполнения операций
    выборки данных с помощью SQL-запросов, так как операция соединения таблиц,
    выполняемая при выборке данных из БД с большим числом взаимосвязанных
    отношений, является одной из самых дорогостоящих операций в БД.

2.  Физическое моделирование. Физическая модель данных описывает данные
    средствами конкретной СУБД. Ограничения, имеющиеся в ЛМД, реализуются
    различными средствами СУБД, например, с помощью декларативных ограничений
    целостности, триггеров, хранимых процедур. Решения, принятые в процессе
    логического моделирования, влияют на качество физическая модели и скорость
    работы БД.

После разработки физической модели данных создается собственно база данных и
приложения, то есть БД реализуется на конкретной программно-аппаратной основе.

>   Особенности проектирования БД:

-   основной упор делается на отражение предметной области,

-   основное внимание – на нормализацию отношений,

-   в отношения могут быть добавлены дополнительные атрибуты,

-   проектировщик никогда не работает со значениями отношений, а только с
    отношениями,

-   при проектировании как правило не делается никаких предположений о данных,
    которые хранятся в отношениях,

Главная цель проектирования - это выявление всех атрибутов и нормализация всех
отношений, входящих в БД.

Логическая модель базы данных
=============================

>   Основными компонентами логической модели являются:

-   сущности (нормализованные отношения),

-   атрибуты сущностей,

-   связи между сущностями.

Сначала рассмотрим пример проектирования в “лоб”. В качестве примера возьмем
предметную область - преподаватели, студенты, занятия, аудитории.

Построим первую нормальную форму БД, что позволит определить все необходимые
атрибуты (таблица 4.1).

>   Таблица 4.1 − Таблица БД в 1НФ

| Факультет | Группа | ФИО |
|-----------|--------|-----|


>   студента

Номер аудитории

Предмет

ФИО

>   преподавателя

Имя кафедры

| РТСЛА | 535   | Ст1 | 118 | ОБД | Преп 1 | КСС |   |   |
|-------|-------|-----|-----|-----|--------|-----|---|---|
| РТСЛА | 535 а | Ст2 | 118 | ОБД | Преп 2 | КСС |   |   |
| РТСЛА | 535 б | Ст3 | 235 | ОБД | Преп 3 | КСС |   |   |

>   Недостатки данного отношения:

1.  Данные хранятся с большой избыточностью.

2.  Аномалии обновления, включения и удаления.

3.  Наличие нежелательных функциональных зависимостей в БД.

Попытаемся перейти ко 2 и 3 нормальным формам. Для этого выявим существующие
функциональные зависимости и постараемся от них избавиться.

![](media/9d654bc8b4ae9df5ff38314faaa371a9.png)

Функциональные зависимости исходного отношения. Из-за того, что группа учится на
определенном факультете, то между атрибутами “Группа” и “Факультет” существует
зависимость (Группа→Факультет), которая приводит к многократному повторению
имени факультета. То же самое можно сказать и о зависимости между именем группы
и Ф.И.О. студента (Группа→Ф.И.О. студента). Таким образом, в результате первой
декомпозиции мы получаем следующие отношения (рисунок 4.1).

>   Имя

>   Рисунок 4.1 − Отношения БД после первой декомпозиции Первая строка каждой
>   таблицы определяет ее имя. Все

остальные строки – атрибуты. Линия, которая соединяет таблицы между собой
отражает, что они связаны, а так же показывает тип связи и поля, которые
участвуют в связи. Двойная стрелка на конце линии обозначает сторону “многие”,
одинарная - “один”.

Согласно определениям нормальных форм видно, что таблицы “Факультет” и “Группа”
находятся в 3 нормальной форме (Отношение R находится в 3-ей НФ в том и только в
том случае, когда оно находится во 2NF, и все неключевые атрибуты взаимно
независимы.). Таблица “Занятие” упростилась, но продолжает представлять 1
нормальную форму.

Рассмотрим функциональные зависимости существующие в таблице “Занятие”.
Существует зависимость между атрибутами “Имя_кафедры” и “Ф.И.О. преподавателя”
(Имя_кафедры→ Ф.И.О. преподавателя). Атрибут “Имя_кафедры” также функционально
зависит от атрибута “Факультет” (Факультет→Имя_кафедры). Имя_студента,
Номер_Аудитории и Предмет так же стоит вынести в отдельные таблицы. В результате
после декомпозиции получается следующая структура (рисунок 4.2).

| **Преподаватель** |
|-------------------|
| Имя_кафедры       |
| Имя               |

>   Рисунок 4.2 − Отношения БД в 3 НФ

![](media/7c2b16d068a7160a3c745f7b70bbe9c6.png)

![](media/a41f2be387995c6d0c3deaf68587247b.png)

![](media/f45ca6295a079d5e47cd2cee5afecebe.png)

Теперь все таблицы находятся в 3-ей НФ и БД можно считать нормализованной.

>   Данная структура обладает некоторыми недостатками.

1.  в качестве первичных ключей выбраны не детерминанты. Имя_факультета,
    имя_группы и т.д. – идентификаторы из “жизни” и несмотря на то, что они
    приняты атомарными, правила их составления все же существуют.

Для того, чтобы перевести наши таблицы в нормальную форму Бойса-Кодда требуется
ввести в каждую таблицу дополнительный атрибут, который будет выполнять только
роль первичного ключа, будет детерминантом и не будет изменяться в течении всей
жизни таблицы.

1.  неполное покрытие спроектированной структурой предметной области. Например,
    мы знаем аудиторию, где проводятся занятия, по какому предмету и каким
    преподавателем, но не знаем день недели и время проведения занятий. Чтобы
    пример не получился слишком сложным остановимся на полученной
    функциональности и будем считать, что БД создана и нормализована.

>   Существует большое количество информационных моделей:

-   модель, построенная с использованием языка Universal Modeling Language (UML)
    фирмы Rational Software,

-   модель, построенная с использованием диаграмм "сущность-

связь" (ERD - Entity-Relationship).

Нотация ERD была впервые введена в 1976 г. Питером Ченом и получила дальнейшее
развитие в работах Баркера (сase-метод Баркера, нотации Баркера, логическая
модель Баркера). Аналогом CASE-метода Баркера является метод IDEF1,
разработанный Т. Рэмей, и также основанный на подходе П. Чена. IDEF1Х-диаграммы

используются в частности такими CASE-средствами как ERWin, Design/IDEF.

Цель модели Баркера – снижение числа ошибок в БД и ускорение процесса
проектирования.

Информационная модель Баркера является логической и создает сущности, которые
находятся в 3-ей нормальной форме. Поэтому ключевой атрибут, формирующий связь,
не показывается ни на одной сущности, которая входит в связь. Наличие самой
линии говорит о том, что существуют ключевые атрибуты, которые формируют связь.

Важным компонентом, который гарантирует правильное проектирование, является
постоянная проверка сделанного проекта. Для этого модель Баркера требует, чтобы
связи подписывались. Например, “группа состоит из студентов” и наоборот
“студенты учатся в группе”. Если подобрать слова не удается, то это явный
признак того, что сущности не могут быть связанны между собой напрямую.

Последним атрибутом связи, который изображается как перечеркнутая в любом месте
под 90 градусов линия связи, является признак обязательности.

Пример обязательной связи – группа обязательно состоит из студентов.

Пример необязательной связи. Существует некоторое количество спортивных секций,
одну из которых может посещать студент.

>   Логическая модель Баркера для нашей задачи имеет вид

(рисунок 4.3).

>   состоит из

принадлежит

>   состоит из

>   посещает

>   располагается на

>   проводится для

>   проводится

>   проводит

>   используется для по

>   изучается на

>   работают на

>   Рисунок 4.3 − Логическая модель БД

Данная схема (рисунок 4.3) называется логической моделью и представляет
логические сущности и связи между ними. При задании имен сущностей и их
атрибутов используются символы и слова того языка, который наиболее удобен.

>   Ключевые атрибуты сущностей обозначаются символом “\#”.

>   Еще одним важным моментом является появление в сущности

“Занятие” новых атрибутов “день_недели” и “номер_пары”.

В данной модели некоторые связи являются необязательными. Это связь –
Преподаватель-занятие. Если в текущем семестре преподаватель не читает своих
предметов, то это значит, что он не проводит занятия. Поэтому связь является
необязательной. Аналогично можно сказать и про связи Группа-Занятие, Аудитория-
Занятие и Предмет-Занятие.

Физическая модели базы данных
=============================

Модель Баркера является полностью логической. То есть в ней отсутствуют такие
понятия, как тип данных, множество значений и т.д., которые присущи полям таблиц
баз данных как объектам управления. Поэтому следующим шагом проектирования
является переход к физической модели. На данном этапе логические сущности
преобразуются в конкретные таблицы СУБД. При этом используется те термины,
которые присущи данной СУБД.

>   Основным компонентами физической модели являются:

-   таблицы, поля таблиц, типы данных (с названиями, присущими конкретной СУБД),

-   ключи (первичные и внешние),

-   бизнес-правила,

-   SQL-скрипт – набор SQL-операторов для создания таблиц БД.

>   Алгоритм преобразования модели Баркера в физическую модель

(гарантирована по крайней мере 3НФ):

1.  каждой сущности ставится в соответствие отношение;

2.  каждый атрибут сущности становится атрибутом отношения, которому приписывают
    тип данных и свойство допустимости/недопустимости для него значения NULL (не
    определен);

3.  компоненты уникального идентификатора сущности (первичный ключ сущности)
    становятся первичным ключом отношения (PRIMARY KEY) (или в качестве
    первичного ключа используется суррогатный ключ), атрибуты, входящие в
    первичный ключ, получают свойство обязательности (NOT NULL) и уникальности
    (UNIQUE);

4.  атрибуты сущности, участвующие в организации связи “один-ко- многим” и
    “один-к-одному”, становятся внешними ключами (у подчиненных отношений
    добавляются в качестве атрибута внешние ключи (FOREIGN KEY), которые обычно
    являются первичными ключами родительских отношений);

5.  индексы создаются для первичного ключа, внешних ключей и атрибутов, которые
    предполагается часто использовать в запросах.

Фрагмент рассмотренной ранее структуры, состоящий из двух сущностей
Группа-Студент, имеет вид

| **Группа** |
|------------|


>   \# имя

состоит из

**Студент**

>   \# ФИО

>   Год поступления Возраст

>   Средняя_оценка

|          |   |   |   |   |   |   |
|----------|---|---|---|---|---|---|
|          |   |   |   |   |   |   |
| учится в |   |   |   |   |   |   |

![](media/bd1ce2a70ea73da7b45c04bf90fd0fca.png)

и преобразуется вот в такую физическую структуру:

Поскольку существует связь между сущностями “Группа” и “Студент”, то для ее
реализации требуется введение дополнительного поля Id_Group в таблице Student.
Поле Id таблицы Groups является первичным ключом.

Поле id_Group таблицы Student является внешним ключом, который определяет какие
студенты учатся в какой группе. Связь между этими полями показывается на рисунке
с помощью линии и стрелок - со стороны “один” стрелка одна, а со стороны
“многие” их две.

С учетом этих особенностей перехода от логической модели к физической модели
базы данных последняя примет вид (рисунок 4.4).

Приведенная структура (рисунок 4.4) описывает имена таблиц, названия их полей и
указывает связи между таблицами. Но она не дает описания типов данных и
дополнительных характеристик полей. Это делается с помощью вот таких таблиц:

Таблица Facility:

| Атрибут | Тип данных   | PKEY | FKEY | NOT NULL | UNIQUE |
|---------|--------------|------|------|----------|--------|
| id      | tinyint      | \*   |      | \*       | \*     |
| name    | nvarchar(20) |      |      | \*       | \*     |

>   Столбец с типом данных tinyint может хранить значения от 0 до

255 или Null. Тип данных занимает 1 байт памяти.

Столбец с типом данных nvarchar предназначен для хранения строковых данных
переменной длины таблицы Unicode. Максимальный размер столбца nvarchar – 4000
символов.

| **Room** |
|----------|
| Id       |
| Num      |

![](media/20e030c2eee2b016d3e652ea7122a874.png)

![](media/4afe5592c3d3e507187ad287e39518e7.png)

>   Рисунок 4.4 − Физическая модель БД

Таблица Groups:

| Атрибут     | Тип данных  | PKEY | FKEY         | NOT NULL | UNIQUE |
|-------------|-------------|------|--------------|----------|--------|
| id          | tinyint     | \*   |              | \*       | \*     |
| name        | nvarchar(5) |      |              | \*       | \*     |
| id_facility | tinyint     |      | Facility(id) | \*       |        |

Таблица Student:

| Атрибут      | Тип данных     | PKEY | FKEY       | NOT NULL | UNIQUE |
|--------------|----------------|------|------------|----------|--------|
| id           | int            | \*   |            | \*       | \*     |
| name         | nvarchar(40)   |      |            | \*       |        |
| Enter_Year   | tinyint        |      |            |          |        |
| Age          | tinyint        |      |            |          |        |
| id_Group     | tinyint        |      | Groups(id) | \*       |        |
| Average_Mark | numeric (5, 2) |      |            |          |        |

Формат numeric используется для хранения дробных чисел. Диапазон значений от
(-1038-1) до (1038-1). Эти данные содержат два параметра: точность и масштаб.
Точность – общее количество цифр, которое может храниться в поле. Масштаб -
количество цифр справа от десятичной точки (222.11 – точность равна 5, а масштаб
равен 2).

Таблица Department:

| Атрибут     | Тип данных   | PKEY | FKEY         | NOT NULL | UNIQUE |
|-------------|--------------|------|--------------|----------|--------|
| id          | tinyint      | \*   |              | \*       | \*     |
| name        | nvarchar(20) |      |              | \*       | \*     |
| id_facility | tinyint      |      | Facility(id) | \*       |        |

Таблица Teacher:

| Атрибут  | Тип данных   | PKEY | FKEY           | NOT NULL | UNIQUE |
|----------|--------------|------|----------------|----------|--------|
| id       | tinyint      | \*   |                | \*       | \*     |
| name     | nvarchar(20) |      |                | \*       |        |
| id\_ dep | tinyint      |      | Department(id) | \*       |        |

Таблица Room:

| Атрибут | Тип данных  | PKEY | FKEY | NOT NULL | UNIQUE |
|---------|-------------|------|------|----------|--------|
| id      | tinyint     | \*   |      | \*       | \*     |
| name    | nvarchar(5) |      |      | \*       | \*     |

Таблица Subject:

| Атрибут | Тип данных   | PKEY | FKEY | NOT NULL | UNIQUE |
|---------|--------------|------|------|----------|--------|
| id      | tinyint      | \*   |      | \*       | \*     |
| name    | nvarchar(30) |      |      | \*       | \*     |

Таблица Lesson:

| Атрибут    | Тип данных | PKEY | FKEY        | NOT NULL | UNIQUE |
|------------|------------|------|-------------|----------|--------|
| id         | tinyint    | \*   |             | \*       | \*     |
| id_group   | tinyint    |      | Groups(id)  | \*       |        |
| id_room    | tinyint    |      | Room(id)    | \*       |        |
| id_subject | tinyint    |      | Subject(id) | \*       |        |
| id_teacher | tinyint    |      | Teacher(id) | \*       |        |
| week_day   | tinyint    |      |             | \*       |        |
| lesson_num | tinyint    |      |             | \*       |        |

>   Рассмотрим более подробно поля приведенных таблиц.

Колонка “атрибут” задает имя атрибута, чьи свойства мы описываем.

Колонка “тип данных” определяет тип данных атрибута. Эта колонка оперирует
типами данных СУБД, которые используются для хранения информации.

Колонка “PKEY” говорит о том, что данный атрибут является первичным ключом, если
он состоит из одного атрибута или же частью первичного ключа, если он состоит из
нескольких атрибутов. Для обозначения признака принадлежности к первичному ключу
используется символ “ **\*** ”.

Колонка “FKEY” описывает внешние ключи. Наличие информации в ней, говорит о том,
что данный атрибут является внешним ключом. При описании внешнего ключа
указывают сущность, на которую ссылается данный внешний ключ, и имя её
первичного ключа.

Колонка “NOT NULL” является признаком того, что поле не может содержать значение
NULL. Значение NULL говорит о том, что данное поле может не содержать никакого
значения. Так пусть у студента нет телефона, и тогда у пользователя есть
возможность просто не задавать это значения, а СУБД предоставляет ему способ
сохранения такой информации.

Колонка “UNIQUE” говорит о том, что значение атрибута является уникальным в
рамках всей таблицы. Уникальность поля контролируется автоматически СУБД.
Попытка поместить в базу запись с значением поля, которое уже существует,
приведет к ошибке выполнения операции вставки записи. Для того чтобы понять
важность атрибута UNIQUE вернемся к определениям информационной модели Баркера.

Ключевые атрибуты сущностей в логической модели БД обозначаются символом “\#”.
Одно из свойств ключевого атрибута – его неповторяемость. При этом после
перехода от логической модели к физической мы добавляем в базу специальные поля,
которые используются для связи сущностей между собой. Таким образом, появляется
первичный ключ и может появиться внешний. Создается впечатление, что о ключевых
атрибутах сущностей, которые присутствовали в модели Баркера мы просто забыли.
Это конечно не верно. Существование свойства UNIQUE и его поддержка языком
определения данных позволяет нам одновременно сохранять таблицы в нормальной
форме Бойса-Кодда и при этом сохранить свойство уникальности для тех полей,
которые являются ключами в жизни информационной системы.

Теперь на основании информации, которая храниться в этих таблицах, можно
создавать конкретные таблицы, которые хранят информацию в определенной СУБД.
Физическая модель таблиц поможет в дальнейшем при написании серверной части БД.

Следует обратить особое внимание на многократное повторение одной и той же
информации. Сначала мы описываем логическую модель. Потом переходим от нее к
физической, затем описываем каждую таблицу отдельно. И каждый раз мы
повторяемся, когда речь идет об атрибутах таблиц, о связях, первичных и внешних
ключах. Это сделано специально. По причине огромной цены ошибки, которая не
выявляется в процессе проектирования структуры базы данных.

Если ошибка не была выявлена и проявила себя уже в процессе кодирования
программного обеспечения, то ее ценой может быть частичный или полный пересмотр
структуры всего программного комплекса. А это требует времени и усилий
конкретных исполнителей. В качестве примера рассмотрим набор SQL-операторов,
которые создают таблицы нашей предметной области. Помещенный в файл,

такой набор представляет объект, который называется SQL-скрипт:

CREATE TABLE FACILITY (

ID tinyint IDENTITY NOT NULL PRIMARY KEY, NAME nvarchar(20) NOT NULL UNIQUE

)

Свойство поля таблицы IDENTITY (seed, increment) (ID entity – идентификационный
номер сущности) разрешает автоматическую нумерацию поля – в поле IDENTITY
таблицы автоматически обеспечивается вставка уникального значения, монотонно
увеличивающегося при вставке каждой новой строки. Первоначальное значение
указывается с помощью аргумента seed (по умолчанию seed=1), а шаг приращения – с
помощью аргумента increment (по умолчанию increment=1). Свойство IDENTITY может
быть установлено только для столбцов с типом данных int, smallint, tinyint,
decimal(p, 0) и numeric(p, 0). В пределах одной таблицы можно создать только
один столбец с установленным свойством IDENTITY. Определение значения по
умолчанию для столбца с установленным свойством IDENTITY невозможно.

CREATE TABLE GROUPS (

ID tinyint IDENTITY NOT NULL,

NAME nvarchar(5) NOT NULL UNIQUE,

ID_FACILITY tinyint NOT NULL,

>   CONSTRAINT FK_GROUPS /\*имя ограничения\*/ FOREIGN KEY (ID_FACILITY)
>   REFERENCES FACILITY(ID) ON

>   DELETE CASCADE ON UPDATE No Action

)

>   Если сразу не определен РК для поля таблицы, то возможно два

пути выхода из этой ситуации:

-   удалить существующую таблицу и создать новую с РК в соответствующем поле,

-   использовать команду для вставки ограничения РК на поле таблицы.

/\*если сразу не введено ограничение “первичный ключ”\*/ ALTER TABLE GROUPS

>   ADD CONSTRAINT PK_GROUPS /\* имя ограничения\* / PRIMARY KEY (ID) /\* вид
>   ограничения\* / В таблице 4.2 представлены опции ссылочной целостности.

>   Таблица 4.2 − Настройки опции ссылочной целостности

| Настройка   | Параметр Delete Rule                                                                                                                                                                                                                               | Параметр Update Rule                                                                                                                                                                                                                             |
|-------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| No Action   | Нельзя удалить в родительской таблице строку, на которую ссылается строка во внешней таблице.                                                                                                                                                      | Нельзя вставить во внешнюю таблицу строку, для которой нет соответствующей записи в родительской таблице.                                                                                                                                        |
| Cascade     | Если в родительской таблице будет удалена строка, на которую ссылается строка во внешней таблице, то строка во внешней таблице также будет удалена.                                                                                                | Если обновляется ключевое значение в родительской таблице, то это значение будет обновлено во всех строках внешней таблице.                                                                                                                      |
| Set Null    | Если в родительской таблице будет удалена строка, на которую ссылается строка во внешней таблице, то значениям столбцов, формирующих внешний ключ, будет присвоено значение Null.                                                                  | Если в родительской таблице обновляется строка, на которую ссылается строка во внешней таблице, то значениям столбцов, формирующих внешний ключ, будет присвоено значение Null.                                                                  |
| Set Default | Если в родительской таблице будет удалена строка, на которую ссылается строка во внешней таблице, то значения в столбцах внешнего ключа примут значения по умолчанию. В этом случае все столбцы внешнего ключа должны иметь значения по умолчанию. | Если в родительской таблице обновляется строка, на которую ссылается строка во внешней таблице, то значения в столбцах внешнего ключа примут значения по умолчанию. В этом случае все столбцы внешнего ключа должны иметь значения по умолчанию. |

Формирование бизнес-правил предметной области
=============================================

Вернемся вновь к таблицам, которые подробно описывают структуру таблиц базы.
Если внимательно присмотреться, то возникает законный вопрос, почему длина поля
Name в таблице Facility 20 символов, а в таблице Groups 5 символов? Что
послужило причиной такой разницы.

Вопрос будет висеть в воздухе пока мы не создадим еще один документ, описывающий
бизнес-правила нашей предметной области.

Бизнес-правила (пользовательская целостность, бизнес- целостность) - это
правила, по которым строится функционирование всей предметной области и которые
полностью или частично не могут быть заданы языком описания данных (это правила,
которые не входят в иные виды целостности). Ярким примером такого правила может
быть ограничение на минимально возможную заработную плату сотрудника. Для
хранения этой величины используется тип данных numeric (6, 2), который
представляет число с фиксированной точкой. С точки зрения хранения информации
значение (-1000,85 грн.) является правильным. Но с точки зрения успешного
функционирования информационной системы данный размер зарплаты является
абсурдным. Поэтому бизнес-правила ограничивают возможности стандартных типов
данных. Это первый тип бизнес-правил. Как правило, их очень трудно описать с
помощью языка описания данных, и требуется дополнительные усилия программистов
для задания их логики работы.

Бизнес-правило “студент принадлежит определенной группе” представляет второй тип
бизнес-правил, которые уточняют свойства связей. Как правило, такое
бизнес-правило реализуется языком описания данных и автоматически поддерживается
СУБД. Существование такого механизма очень важно. Во-первых, описанное
бизнес-правило является следствием правила ссылочной целостности. Во-вторых,
СУБД берет на себя часть работы, которую должен реализовать программист.
Возможность переложить часть функциональности на другую подсистему является
очень удобной, потому что сокращает число возможных ошибок программы и время ее
разработки.

Третий тип бизнес-правил, так же относится к уточнению использования стандартных
типов данных. Если мы на основании анализа предметной области говорим, что
максимальная длина имени группы 5 символов, то это должно быть записано и
является отправной точкой при определении максимальной длины строки, которая
хранит имя группы. На основании правил этого типа в таблице были заданы длины
всех символьных атрибутов.

В большинстве случаев лучше всего поддерживать бизнес- правила на уровне
сервера. Если поместить бизнес-правила на сторону клиента, то их придется
дублировать во всех клиентских приложениях.

Бизнес-правила влияют не только на базу данных. Некоторые из них реализовываются
и в интерфейсе пользователя. Наиболее простой иллюстраций этого является
возможность задания максимальной длины строки в стандартном интерфейсном
компоненте “поле ввода символов”. Если в диалоговом окне создания новой

группы студентов ограничить количество символов в поле ввода, то это приведет к
автоматическому контролю бизнес-правила на уровне ресурса операционной системы.

Для нашей предметной области можно определить следующие бизнес-правила:

1.  Максимальная длина наименования факультета 20 символов.

2.  Максимальная длина имени группы 5 символов.

3.  Группа должна принадлежать факультету.

4.  Максимальная длина имени студента 40 символов.

5.  Студент обязательно учится в группе.

6.  Максимальная длина названия кафедры 20 символов.

7.  Кафедра обязательно находится на факультете.

8.  Максимальная длина имени преподавателя 40 символов.

9.  Преподаватель всегда работает на кафедре.

10. Максимальная длина наименования аудитории 5 символов.

11. Максимальная длина наименования предмета 30 символов.

12. Занятие обязательно проводится в аудитории по предмету преподавателем для
    группы.

13. Для обозначения дней недели используются следующие константы: 1 –
    понедельник, 2 – вторник, 3 – среда, 4 – четверг, 5 – пятница, 6 – суббота,
    7 – воскресенье.

14. Для обозначения номера пары используются следующие константы: 1 – первая, 2
    – вторая, 3 – третья, 4 – четвертая, 5 – пятая.

Как видите большинство бизнес-правила довольно нудные. Но их определение – это
еще один шаг проверки правильно составленной информационной модели.

>   Контрольные вопросы

1.  Каковы цели моделирования базы данных?

2.  Каковы этапы моделирования реляционной базы данных?

3.  Что понимается под концептуальной моделью базы данных?

4.  Каковы особенности логической модели базы данных?

5.  Каковы особенности физической модели базы данных?

6.  Каковы основные компоненты физической модели базы данных?

7.  Каков алгоритм преобразования логической модели базы данных в физическую?

8.  Какие опции ссылочной целостности используются при создании таблиц в MS SQL
    Server?

9.  Определение и особенности формирования бизнес-правил предметной области.

>   Лабораторная работа 2

Создание структуры распределенной базы данных
=============================================

>   Постановка задачи:

>   На основании таблиц физической модели данных и бизнес- правил предметной
>   области создать:

1.  Скрипт создания таблиц БД.

2.  Скрипт модификации таблиц БД.

3.  Диаграмму БД.

4.  Скрипт удаления таблиц БД.

5.  Скрипт занесения информации в таблицы БД.

6.  Скрипт изменения информации в таблицах БД.

7.  Скрипт удаления информации из таблиц БД.

>   Для создания указанных скриптов использовать следующие команды языка
>   определения данных DDL:

| Создать объект | Удалить объект | Модифицировать объект |
|----------------|----------------|-----------------------|
| CREATE TABLE   | DROP TABLE     | ALTER TABLE           |

>   А также команды языка манипулирования данными DML:

| Изменяют данные таблиц |
|------------------------|
| INSERT                 |
| DELETE, TRUNCATE       |
| UPDATE                 |

Введение ограничений на столбцы и таблицы осуществлять с использованием
следующих предложений - NOT NULL, UNIQUE, PRIMARY KEY, CHECK, DEFAULT,
CONSTRAINT, FOREING KEY.

>   Письменный отчет по лабораторной работе должен содержать:

1.  Титульный лист, содержащий – название лабораторной работы, фамилию, имя,
    отчество, номер группы исполнителя, дату сдачи.

2.  Скрипт создания таблиц БД.

3.  Скрипт изменения таблиц БД.

4.  Диаграмму БД.

5.  Скрипт удаления таблиц БД.

6.  Скрипт занесения информации в таблицы БД.

7.  Скрипт обновления информации в таблицы БД.

8.  Скрипт удаления информации из таблиц БД.

9.  Примеры таблиц с данными, таблиц после изменения данных и т.п.

10. Выводы по лабораторной работе (в выводах отразить особенности построения
    модели, скриптов, и пути дальнейшей модернизации БД).

>   Контрольные вопросы и задания

1.  К каким языкам относится язык SQL?

2.  Какие формы языка SQL существуют?

3.  Каковы компоненты языка SQL?

4.  Каковы основные предложения компонент языка SQL?

5.  Какие действия можно выполнить с помощью предложений DDL?

6.  Каковы основные типы данных СУБД MS SQL Server?

7.  Какие действия выполняет команда CREATE TABLE?

8.  Каков синтаксис команда CREATE TABLE?

9.  Каким образом с помощью команды CREATE TABLE

поддерживается правило ссылочной целостности БД?

1.  Как осуществляется изменение существующей таблицы БД?

2.  Как осуществляется удаление таблицы БД?

3.  Какие бывают и как вводятся ограничения на столбец в БД?

4.  Какие бывают и как вводятся ограничения на таблицу в БД?

5.  Как осуществляется вставка данных в таблицу БД?

6.  Как осуществляется удаление данных из таблицы БД?

7.  Как осуществляется изменение данных в таблице БД?

Лекция 5. Операторы создания, модификации и удаления таблиц базы данных
=======================================================================

>   **Основные понятия языка SQL**

Структурированный язык запросов (SQL) был разработан IBM в конце 1970-х годов. С
тех пор в язык вносились изменения и усовершенствования, но его принципы
остались прежними. Прежде всего, SQL – непроцедурный язык высокого уровня.
Прикладная программа не сообщает Машине БД, как выполнить задачу, а формулирует,
что должно содержаться в результате (декларативный подход).

В отличие от процедурных языков, которые также могут быть использованы для
работы с БД, SQL ориентирован не на записи, а на множества. Это означает
следующее: в качестве входной информации для формулируемого на языке SQL запроса
к БД используется множество записей одного или нескольких отношений. В
результате выполнения запроса образуется множество записей результирующей

таблицы. То есть, в SQL результатом любой операции над отношениями также
является отношение. SQL-запрос задает не процедуру (последовательность действий,
необходимых для получения результата), а условия, которым должны удовлетворять
кортежи результирующего отношения, сформулированные в терминах входного (или
входных) отношения (рисунок 5.1).

>   Входная информация в SQL–запросе: Выходная информация в SQL–запросе:

![](media/f6c97beeacd1b53e1979d5e51feff8c1.png)

>   Рисунок 5.1 − Структура входной и выходной информаций в SQL-

>   запросе

Первый стандарт языка SQL был принят в 1989 году. Все известные коммерческие
продукты в настоящее время поддерживают этот продукт. В 1992 году был принят
второй стандарт SQL, в котором, в частности, были реализованы напрямую
теоретико-множественные операции реляционной алгебры (РА) (до этого их можно
было моделировать на основе аналогии РА с реляционным исчислением (РИ), а РИ с
SQL). Третий стандарт SQL, направленный на сближение языка с ОО подходом, был
принят в 1998 году. Различные производители БД вносят в синтаксис SQL небольшие
изменения. Однако, как правило, стандартный запрос SQL без труда переносится на
различные платформы.

С помощью SQL можно не только обрабатывать информацию запросами, но и управлять
данными (вставка, модификация, удаление записей, сортировка), а также
осуществлять сопровождение БД (описание типов данных и структуры таблиц,
удаление и изменение таблиц, индексирование, управление правами доступа к
данным).

Имеются две формы SQL: - интерактивный SQL, - вложенный SQL. Обе формы SQL
работают практически одинаково, но используются различно.

Интерактивный SQL используется для функционирования непосредственно в БД. В этой
форме языка введенная команда тотчас же выполняется и результат (если он
существует) немедленно отображается.

Вложенный SQL состоит из команд языка, помешенных внутри программ, которые
обычно написаны на некотором другом языке (C\#,

С++, РНР и т. д., часто СУБД предоставляет свое процедурное расширение – язык
Transact SQL от MS SQL Server или PL/SQL от ORACLE). Это делает программы более
мощными и эффективными. Однако, допуская другие языки, приходится иметь дело со
структурой SQL и стилем управления данными, который требует некоторых расширений
к интерактивному SQL.

Команды SQL делятся на следующие категории (компоненты SQL):

-   Предложения Языка Определения Данных - Data Definition Language (DDL). DDL
    (в ANSI он называется Языком Описания Схем – Shema Definition Language)
    состоит из тех команд, которые создают объекты (таблицы, представления,
    индексы) в БД. Также DDL предложения используются для определения
    характеристик БД, их изменения и удаления БД.

-   Предложения Языка Манипулирования Данными - Data Manipulation Language
    (DML). DML состоит из предложений (команд), определяющих, какие данные
    находятся в таблицах в любой момент времени. DML предложения предназначены
    для манипулирования данными в структурах данных, определенных DDL
    предложениями.

-   Предложения Языка Управления Данными - Data Control Language (DCL). DCL
    состоит из предложений, определяющих, может ли пользователь выполнить
    отдельное действие. Согласно ANSI, DCL является частью DDL.

>   Речь идет не о различных языках как таковых, а о разделах команд одного
>   языка, сгруппированных в соответствии с их функциональным назначением.

Основные команды *SQL*
======================

Предложения DDL:

| Создать объект   | Удалить объект | Модифицировать объект |
|------------------|----------------|-----------------------|
| CREATE DATABASE  | DROP DATABASE  | ALTER DATABASE        |
| CREATE INDEX     | DROP INDEX     | ALTER INDEX           |
| CREATE PROCEDURE | DROP PROCEDURE | ALTER PROCEDURE       |
| CREATE TABLE     | DROP TABLE     | ALTER TABLE           |
| CREATE TRIGGER   | DROP TRIGGER   | ALTER TRIGGER         |
| CREATE VIEW      | DROP VIEW      |                       |

>   DDL базируется на трех командах SQL:

-   CREATE (создать) – позволяет определять и создавать объекты БД,

-   DROP (удалить) – позволяет удалять существующий объект БД,

-   ALTER (изменить) – позволяет изменять определение объекта БД.

>   С помощью операторов DDL можно:

-   создать новую БД,

-   определить структуру новой таблицы и создать эту таблицу,

-   изменить определение существующей таблицы,

-   удалить существующую таблицу,

-   определить представление данных,

-   обеспечить условия безопасности БД,

-   создать индексы для доступа к таблицам,

-   управлять размещением данных на устройствах хранения.

Предложения DML:

| Изменяют данные таблиц | Не изменяют данные таблиц |
|------------------------|---------------------------|
| INSERT                 | SELECT                    |
| DELETE                 |                           |
| UPDATE                 |                           |

Предложения DCL:

В SQL привилегии даются и отменяются двумя командами

-   GRANT (допуск) и REVOKE (отмена).

Пример. Пользователь SA владеет таблицей STUD и желает позволить пользователю SB
выполнить запрос (произвести вставку, обновление) к ней. Пользователь SA должен
в этом случае выполнить следующую команду:

>   GRANT SELECT ON STUD TO SB GRANT INSERT ON STUD TO SB

>   GRANT UPDATE (FAM) ON STUD TO SB //позволено

модифицировать только поле FAM

REVOKE DELETE, INSERT ON STUD TO SB //отмена привилегий на удаление и вставку

>   Диалог с СУБД осуществляется только с помощью SQL-

операторов, вне зависимости от того, хотим мы создать таблицу,

поместить в нее данные, создать пользователя СУБД или же получить информацию о
загрузке процессора. Но этот класс операторов не выделяют отдельно. Потому что
их реализация зависит от производителя СУБД и не всегда понятно, что реально
делает оператор. Так, например, для создания пользователя необходимо запустить
соответствующий оператор, который создает объект СУБД. Следовательно, можно
сказать, что этот оператор принадлежит к DDL. Но для того, чтобы посмотреть
загрузку процессора требуется обратиться к определенной системной таблице СУБД.
А для этого используется оператор SQL. По этой причине все множество операторов
работы с реляционной СУБД называется SQL.

SQL-оператор создания таблицы CREATE TABLE
==========================================

В MS SQL Server инструментально существует три способа создания объектов БД:

1.  С помощью средств языка SQL.

2.  С помощью инструментальных средств интегрированной среды Management Studio
    (в этом случае сервер все равно генерирует SQL-скрипт).

3.  С использованием первого и второго способов.

Язык DDL, как видно из названия, применяется для определения таблиц, полей,
индексов и прочих объектов, которые располагаются в СУБД и, как правило, хранят
данные или облегчают их обработку.

Таблицы базы данных создаются с помощью команды CREATE TABLE. Эта команда:

-   создает пустую таблицу, то есть таблицу, не имеющую строк,

-   значения в эту таблицу вводятся с помощью команды INSERT,

-   определяет имя таблицы и множество поименованных столбцов в указанном
    порядке (каждая создаваемая таблица должна иметь, по крайней мере, один
    столбец),

-   для каждого столбца должен быть определен тип данных и размер,

-   для каждого столбца могут быть определены различные ограничения (PRIMARY
    KEY, FOREING KEY, Not Null, Unique, Default, Check, Constraint).

Синтаксис оператора CREATE TABLE выглядит вот так: CREATE TABLE имя_таблицы (

поле1 тип1 [NOT NULL] [UNIQUE] [PRIMARY KEY],

поле2 тип2 [NOT NULL] [UNIQUE],

. . .

полеN типN [NOT NULL] [UNIQUE],

[FOREING KEY (поле) REFERENCES таблица(поле)

[ON DELETE { No Action \| CASCADE \| SET NULL \| Set Default }]

[ON UPDATE { No Action \| CASCADE \| SET NULL \| Set Default

}]]

)

Поскольку пробелы используются для разделения частей команды SQL они не могут
быть частью имени столбца или таблицы (или любого другого объекта БД). В
операторе CREATE TABLE определения полей перечисляются через “запятую”.

Пример. Создание таблицы STUDENT (STUDENT (ID – номер зачетки, FAM – фамилия,
STIP – стипендия, OCENКА - оценка, GR – группа, CITY – город, BIRTHDAY – год
рождения ))

CREATE TABLE STUDENT

(ID SMALLINT IDENTITY NOT NULL PRIMARY KEY,

FAM NVARCHAR(10), STIP NUMERIC (6, 2), OCENКА TINYINT, GR NVARCHAR(5),

CITY NVARCHAR(15), BIRTHDAY SMALLDATETIME)

Порядок расположения полей в таблице определяется тем, в какой
последовательности они указаны в команде создания таблицы.

Когда создается таблица или изменяется ее структура, можно устанавливать
ограничения на значения, которые могут быть введены в поля. Если это сделано,
СУБД будет отвергать любые значения, которые нарушают оговоренные критерии.

>   Имеются следующие типы ограничений (constraint) целостности

БД:

-   ограничение поля (атрибута) (применяется только к

определенному полю),

-   ограничение таблицы (отношения) (применяется к группам из одного и более
    полей),

-   ограничение ссылочной целостности (применяется для определения внешнего
    ключа).

>   Ограничения на уровне поля:

-   ограничения неопределенных значений (NOT NULL - запрет неопределенных
    значений) (NULL — это специальный маркер, обозначающий тот факт, что поле
    пусто или неопределенно, значение NULL вводится по умолчанию),

-   ограничения уникальности столбца (UNIQUE) (ограничение UNIQUE применяется
    только совместно с ограничением NOT NULL),

-   ограничения первичного ключа (PRIMARY KEY, что эквивалентно NOT NULL UNIQUE)
    (Если ключ состоит из нескольких атрибутов, тогда используется немного
    другое определение.),

-   ограничения внешнего ключа (ограничения столбца по ссылке) (FOREING KEY),

-   ограничения проверки на допустимость значения (CHECK),

-   ограничения заданных по умолчанию значений (DEFAULT).

Эти ограничения иногда называют ограничениями семантической целостности – для
возможности смыслового описания данных.

Пример. Неопределенное значение не может быть установлено для поля FAM.

CREATE TABLE STUDENT

>   (**…**

FAM NVARCHAR(10) NOT NULL,

>   **…**)

Пример. Необходимо гарантировать, что все значения, введенные в поле FAM,
отличаются друг от друга. При этом СУБД отклонит любую попытку ввода в это поле
значения, которое уже имеется в другой строке. Это ограничение применяется к
полям, для которых ранее было объявлено ограничение NOT NULL. Если такое поле не
является первичным ключом, то оно является альтернативным ключом.

CREATE TABLE STUDENT

>   (**…**

FAM NVARCHAR(10) NOT NULL UNIQUE,

>   **…**)

Пример. Объявление группы из двух полей уникальными (ограничение таблицы) c
присваиванием этому ограничению таблицы уникального имени.

CREATE TABLE STUDENT

>   (**…**

FAM NVARCHAR(10) NOT NULL, NAME NVARCHAR(10) NOT NULL,

…
=

UNIQUE (FAM, NAME))

Или так … CONSTRAINT UN_FAM_NAME UNIQUE (FAM, NAME)… .

Ограничениям таблиц можно присваивать уникальные имена. Преимущество явного
задания имени ограничения состоит в том, что в этом случае при выдаче системой
сообщения о нарушении установленного ограничения будет указано его имя, что
упрощает обнаружение ошибок. Для присвоения имени ограничению используется
несколько измененный синтаксис команд CREATE TABLE и ALTER TABLE.

В этом запросе UN_FAM_NAME — это имя, присвоенное указанному ограничению
таблицы.

Пример. Объявление cоставного первичного ключа (ограничение таблицы). Любое
поле, используемое в ограничении PRIMARY KEY, должно уже быть объявлено NOT
NULL. Первичный ключ состоит из двух полей.

CREATE TABLE STUDENT

>   (**…**

FAM NVARCHAR(10) NOT NULL,

NAME NVARCHAR(10) NOT NULL,

…
=

PRIMARY KEY (FAM, NAME))

Или так … CONSTRAINT PK\_ STUDENT PRIMARY KEY(FAM, NAME)… .

Условие проверки на допустимость значения: CHECK(\<булево выражение\>).

>   Особенности работы с ограничением целостности CHECK:

1.  основные конструкции, используемые в CHECK - \<, \>, =, !=, And, Or, IN,
    Between, Like,

2.  ограничение может относиться к одному столбцу,

3.  ограничение может быть распространено на всю таблицу, в смысле, что проверка
    значений в одном столбце осуществляется на сновании значений другого столбца
    (при условии, что столбцы принадлежат одной таблице и берутся из одной и той
    же обновляемой или вставляемой строки),

4.  на основании CHECK может быть выполнена проверка того, соответствует ли
    некоторое сочетание значений столбцов заданному критерию,

5.  правила составления CHECK аналогичны правилам составления конструкции WHERE,

6.  проверка CHECK позволяет достичь более высокой производительности по
    сравнению с проверками с помощью правил и триггеров.

Пример. Введение ограничений на поле оценка OCENКА (ограничение проверки на
допустимость значения).

CREATE TABLE STUDENT

>   (**…**

OCENКА TINYINT CHECK (OCENКА \<=5),

>   **…**)

Или так … OCENКА TINYINT CHECK IN (2, 3, 4, 5) … .

Или так … OCENКА TINYINT CHECK (OCENКА BETWEEN 2 AND 5)

… . Или так … CONSTRAINT CH\_ OCENКА CHECK (OCENКА \<=5)… .

>   Пример. Введение ограничений на поля оценка OCENКА и дата

TDATE (ограничение таблицы). CREATE TABLE STUDENT

>   (**…**

OCENКА TINYINT, TDATE SMALLDATETIME,

…
=

CHECK (OCENКА \<5 AND TDATE \> 31/03/2010))

Или так … CONSTRAINT CH_STUD CHECK (OCENКА \<5 AND TDATE \> 31/03/2010)

Значение по умолчанию: [DEFAULT {\<значение\>\|USER\|NULL}] – здесь ключевое
слово USER означает, что при заполнении столбца ему будет присвоена символьная
строка, содержащая имя текущего пользователя.

Значение DEFAULT не ограничительного свойства, оно определяет, что должно
случиться, если не введено любое из явных допустимых значений. Использовать
значение по умолчанию – это альтернатива для NULL.

Пример. Введение ограничений на поле оценка OCENКА и задание значения 5 по
умолчанию.

CREATE TABLE STUDENT

>   (**…**

OCENКА TINYINT CHECK IN (2, 3, 4, 5) DEFAULT 5,

>   **…**)

Ограничение столбца по ссылке: объявление поля внешним ключом.

FOREIGN KEY (\<поле\>) REFERENCES \<имя_основной_таблицы\>
(\<имя_первичного_ключа_основной_таблицы\>)

[ON DELETE { No Action \| CASCADE \| SET NULL \| Set Default }] [ON UPDATE { No
Action \| CASCADE \| SET NULL \| Set Default }]

На рисунке 5.2 приведена иллюстрация связи один-ко-многим между полями таблиц
GROUPS и STUDENT.

>   Рисунок 5.2 − Связь один-ко-многим между полями таблиц GROUPS и

>   STUDENT

>   Пример. Объявление поля внешнего ключа

CREATE TABLE STUDENT ( **…**

ID_GROUP TINYINT NOT NULL,

…
=

>   CONSTRAINT FK_STUD FOREIGN KEY (ID_GROUP) REFERENCES GROUPS(ID) ON DELETE
>   CASCADE ON UPDATE

CASCADE)

>   Особенности задания ограничения столбца по ссылке:

1.  Основная таблица должна быть описана до подчиненной.

2.  Все поля, используемые в качестве внешних ключей, должны в родительской
    таблице иметь ограничения PRIMARY KEY или NOT NULL и UNIQUE.

3.  Для определения поля, которое является внешним ключом, сначала его нужно
    определить - описать его наименование, тип данных и прочие атрибуты.

4.  После определения всех полей может следовать одно или несколько определений
    FOREIGN KEY, которые задают поле внешнего ключа и определяют таблицу и поле,
    на которое ссылается внешний ключ.

5.  Несколько определений FOREIGN KEY перечисляются через запятую.

Правило ссылочной целостности говорит, что внешний ключ не может ссылаться на
несуществующий первичный ключ. Ссылочная целостность обозначает поддержку
внешних ключей с возможностью выбора одного из следующих принципов удаления
связанных кортежей:

-   ON DELETE CASCADE - кортежи подчиненного отношения уничтожаются при удалении
    связанных с ними кортежей основного отношения (если мы хотим удалить
    первичный ключ, то предварительно мы должны явно удалить все записи
    подчиненных таблиц, внешние ключи которых ссылаются на этот первичный ключ)
    (Определение “ON DELETE CASCADE” включает механизм каскадного удаления. При
    наличии “ON DELETE CASCADE” СУБД автоматически удаляет все записи, которые
    ссылаются на этот первичный ключ.),

-   ON DELETE SET NULL - кортежи подчиненного отношения модифицируются в NULL
    при удалении связанных с ними кортежей основного отношения,

-   ON DELETE No Action - запрет на удаление кортежа основного отношения при
    наличии кортежей подчиненного отношения, связанных с ним.

В качестве примера рассмотрим набор SQL-операторов, которые создают таблицы
нашей предметной области. Помещенный в файл, такой набор представляет объект,
который называется SQL-скрипт: CREATE TABLE STUDENT (

ID INT IDENTITY NOT NULL PRIMARY KEY, NAME NVARCHAR (40) NOT NULL, ENTER_YEAR
TINYINT,

AGE TINYINT,

ID_GROUP TINYINT NOT NULL, AVERAGE_MARK NUMERIC (5, 2),

FOREIGN KEY (ID_GROUP) REFERENCES GROUPS(ID) ON DELETE CASCADE ON UPDATE NO
ACTION

)

CREATE TABLE DEPARTMENT (

ID TINYINT IDENTITY NOT NULL PRIMARY KEY, NAME NVARCHAR (20) NOT NULL UNIQUE,
ID_FACILITY TINYINT NOT NULL,

FOREIGN KEY (ID_FACILITY) REFERENCES FACILITY(ID) ON DELETE CASCADE ON UPDATE NO
ACTION

)

CREATE TABLE TEACHER (

ID TINYINT IDENTITY NOT NULL PRIMARY KEY, NAME NVARCHAR (40) NOT NULL,

ID_DEP TINYINT NOT NULL,

FOREIGN KEY (ID_DEP) REFERENCES DEPARTMENT(ID) ON DELETE CASCADE ON UPDATE NO
ACTION

)

CREATE TABLE ROOM (

ID TINYINT IDENTITY NOT NULL PRIMARY KEY, NAME NVARCHAR (5) NOT NULL UNIQUE

)

CREATE TABLE SUBJECT (

ID TINYINT IDENTITY NOT NULL PRIMARY KEY, NAME NVARCHAR (30) NOT NULL UNIQUE,

)

CREATE TABLE LESSON (

ID TINYINT IDENTITY NOT NULL PRIMARY KEY, ID_GROUP TINYINT NOT NULL,

ID_ROOM TINYINT NOT NULL, ID_SUBJECT TINYINT NOT NULL, ID_TEACHER TINYINT NOT
NULL, WEEK_DAY TINYINT NOT NULL, LESSON_NUM TINYINT NOT NULL,

FOREIGN KEY (ID_GROUP) REFERENCES GROUPS(ID) ON DELETE CASCADE ON UPDATE NO
ACTION,

FOREIGN KEY (ID_ROOM) REFERENCES ROOM(ID) ON DELETE CASCADE ON UPDATE NO ACTION,

FOREIGN KEY (ID_SUBJECT) REFERENCES SUBJECT(ID) ON DELETE CASCADE ON UPDATE NO
ACTION,

FOREIGN KEY (ID_TEACHER) REFERENCES TEACHER(ID) ON DELETE CASCADE ON UPDATE NO
ACTION

)

Важным является понимание того, что правило ссылочной целостности реализовано не
только в операциях работы с данными, но и в операциях создания объектов, которые
эти данные хранят. Другими словами, до тех пор, пока вы не создадите таблицу с
первичным ключом, вы не сможете создать таблицу с внешним ключом, который на
него ссылается. То есть порядок создания таблиц существует.

Приведенный скрипт учитывает это свойство. Если посмотреть на скрипт, то можно
увидеть явную корреляцию определений полей и той информации, которую мы
создавали, когда описывали таблицы

при проектировании. Конечно структура таблицы, использованная при
проектировании, специально выбрана таким образом, чтобы эта корреляция имела
место. Цель одна – уменьшить количество ошибок за счет многократного определения
сущностей в базе.

SQL-оператор изменения существующей таблицы
===========================================

>   **ALTER TABLE**

Для модификации структуры и параметров существующей таблицы используется команда
ALTER TABLE. Синтаксис команды ALTER TABLE для добавления столбцов в таблицу
имеет вид

ALTER TABLE \<имя таблицы\> ADD (\<имя столбца\> \<тип данных\>

\<размер\>)

По этой команде для существующих в таблице строк добавляется новый столбец, в
который заносится NULL-значение. Этот столбец становится последним в таблице.
Можно добавлять несколько столбцов, в этом случае их определения в команде ALTER
TABLE разделяются запятой.

Оператор ALTER TABLE не действует, когда таблица должна быть переопределена,
однако при разработке БД не стоит исключать необходимость этого действия.

Пример. Добавление к таблице STUDENT двух полей для хранения информации о курсе
и специальности студента.

ALTER TABLE STUDENT ADD СOURS TINYINT, SPEC NVARCHAR(10)

Пример. Удаление из таблицы STUDENT поля курс СOURS. ALTER TABLE STUDENT DROP
COLUMN СOURS

>   Упрощенная версия синтаксиса для оператора ALTER TABLE

приведена ниже: ALTER TABLE \<имя\> {

[ALTER COLUMN \<определение_столбца\>] \| [ADD \<определение_столбца\>] \|

[DROP COLUMN \<имя_столбца\>] \|

[ADD [WITH NOCHECK] CONSTRAINT \<ограничение_для_таблицы\>]}

Ключевые слова CHECK (подразумевается) и NOCHECK перед ограничением таблицы,
предписывают SQL Server тестировать или не тестировать имеющиеся в таблице
данные с учетом нового ограничения. WITH NOCHECK используется лишь в крайне
редких случаях.

Ниже представлено несколько ограничений для фразы ALTER COLUMN. Столбец не может
быть изменен, если он:

-   имеет тип данных text, image, ntext или timestamp;

-   является вычисляемым столбцом или используется в вычисляемом столбце;

-   является реплицированным;

-   используется в индексе – если только столбец не имеет тип данных varchar,
    nvarchar или varbinary; тип данных не изменяется и размер столбца не
    уменьшается;

-   используется в статистике, генерируемой оператором

>   CREATE STATISTIC;

-   используется в ограничении PRIMARY KEY;

-   используется в ограничении FOREIGN KEY;

-   используется в ограничении CHECK;

-   используется в ограничении UNIQUE;

-   указывается как DEFAULT.

>   Возможно изменение описания столбцов. Часто это связано с изменением
>   размеров столбцов, добавлением или удалением ограничений, накладываемых на
>   их значения. Синтаксис команды в этом случае имеет вид:

>   ALTER TABLE \<имя_таблицы\> ALTER \<имя_столбца\> \<тип данных\>

>   \<размер/точность\>

>   Пример. Модификация типа данных поля ID_NUM в таблице

>   USP.

>   ALTER TABLE USP ALTER ID_NUM TINYINT

>   Следует иметь в виду, что изменение характеристик столбца

>   может осуществляться не в любом случае, а с учетом следующих ограничений:

-   изменение типа данных возможно только в том случае, если столбец пуст;

-   для незаполненного столбца можно изменять размер/точность;

-   для заполненного столбца размер/точность можно увеличить, но нельзя
    понизить;

-   ограничение NOT NULL может быть установлено, если ни одно значение в столбце
    не содержит NULL. Опцию NOT NULL всегда можно отменить;

-   разрешается изменять значения, установленные по умолчанию.

>   Изменение структуры таблицы в тот момент, когда она находится в
>   использовании, чревато потерей информации – например, запрос может потерпеть
>   неудачу по той причине, что некоторого поля в таблице уже не существует.
>   Таким образом, лучше разрабатывать БД так, чтобы использовать ALTER TABLE
>   только в крайнем случае.

SQL-оператор удаления таблиц DROP TABLE
=======================================

>   SQL-оператор DROP TABLE предназначен для удаления таблиц.

>   Общий вид синтаксиса оператора DROP TABLE следующий: DROP TABLE
>   \<имя_таблицы1\>, \<имя_таблицы2\>, … Особенности оператора DROP TABLE:

1.  Для того чтобы иметь возможность удалить таблицу, пользователь должен быть
    ее собственником, то есть создателем.

2.  Перед удалением желательно произвести очистку таблицы от данных, что
    позволяет избежать случайной и невосполнимой потери информации.

3.  Операция удаления выполняется вне зависимости от того, существуют в таблице
    данные или нет.

4.  После удаления таблицы ее восстановление не возможно. После выполнения этой
    команды, имя таблицы больше не распознается, и нет таких действий, которые
    могли быть выполнены с этим объектом.

5.  Для избегания многих трудностей (например, удаление таблицы было ошибкой),
    рекомендуется создавать резервную копию БД перед удалением из нее объектов.
    Впоследствии при необходимости можно восстановить необходимые объекты из
    резервной копии.

6.  Правило ссылочной целостности реализовано и здесь. Нельзя удалить таблицу,
    содержащую первичный ключ, пока не будет удалена связанная с ней таблица
    (или ее ограничения целостности), которая содержит внешний ключ, ссылающийся
    на поле удаляемой таблицы. Это приводит к тому, что последовательность
    удаления таблиц обратна последовательности их создания.

Рассмотрим скрипт удаления таблиц для нашей задачи: DROP TABLE lesson, subject;

DROP TABLE room;

DROP TABLE teacher; DROP TABLE department; DROP TABLE student; DROP TABLE
groups; DROP TABLE facility;

При разработке программного продукта иногда требуется полное удаление базы
вместе с последующим её восстановлением. Именно поэтому создают скрипты создания
и удаления таблиц базы. Кроме того, процесс создания таблиц БД является частью
инсталляции программного обеспечения.

SQL-оператор вставки данных в таблицу INSERT
============================================

SQL-оператор INSERT используется для вставки данных в таблицу БД.

>   Оператор INSERT имеет следующий синтаксис:

INSERT INTO \<имя_таблицы\| представление\> [(имя_поля1,

имя_поля2, ...)] VALUES \<(значение1, значение2, ...)\>\| \<подзапрос\>

>   Существует две формы оператора INSERT:

-   первая форма позволяет вставлять в таблицу новые строки путем
    непосредственного задания значения каждого поля,

-   вторая форма базируется на данных, которые передаются в оператор INSERT
    посредством запроса на выборку данных SELECT.

Первая форма оператора INSERT имеет следующий синтаксис: INSERT INTO
\<имя_таблицы\| представление\> [(имя_поля1, имя_поля2, ...)] VALUES
\<(значение1, значение2, ...)\>

>   Особенности работы оператора INSERT:

1.  Оператор вставляет только одну запись в таблицу с именем “имя_таблицы”.
    Таблица, в которую производится вставка, должна быть предварительно
    определена оператором CREATE TABLE.

2.  Если поля для вставки вообще не указаны, то их последовательность задается
    оператором CREATE TABLE. Значения в списке полей для вставки вводятся в
    таблицу в том порядке, в котором они записаны в команде.

Пример. Вставить в таблицу Teacher (id (код_преподавателя), name
(имя_преподавателя), id_dep (код_кафедры)) новую запись – 1234, Иванов, 503.

INSERT INTO TEACHER (id, name, id_dep) VALUES (1234, ‘ Иванов’, 503);

1.  Если в операторе заданы не все поля для вставки, то в отсутствующие поля
    помещается значение “NULL”. При этом нужно учитывать возможность наличия
    условия NOT NULL.

2.  Чтобы присвоить значения не всем полям записи или изменить порядок ввода
    значений, следует явно задавать список полей после имени таблицы.

Пример. Вставить в таблицу Teacher новую запись – Петров, код_преподавателя –
1237.

>   INSERT INTO Teacher (name, id) VALUES (‘ Петров’, 1237);

В поле id_dep (код_кафедры) будет автоматически вставлено значение NULL.

1.  Рекомендуется указывать вставляемые поля таблицы явным образом. Это связанно
    с тем, что последовательность полей, которую задает оператор CREATE TABLE
    можно просто забыть. Существует также возможность добавления новых полей в
    таблицу после создания БД.

2.  Вставка даты/времени в таблицу БД (таблица 5.1).

>   Таблица 5.1 − Типы данных даты/времени в SQL Server 2005

| Имя типа данных | Размер в байтах | Описание                                                                                                                                        |
|-----------------|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| DateTime        | 8               | Данные о дате и (или) времени, которые относятся к периоду с 1 января 1753 года по 31 декабря 9999 года,                                        |
|                 |                 | определяемые с точностью до 3–х сотых секунды.                                                                                                  |
| SmallDateTime   | 4               | Данные о дате и (или) времени, которые относятся к периоду с 1 января 1900 года по 06 июня 2079 года, определяемые с точностью до одной минуты. |

Преобразование строки в дату при вставке может выполняться двумя способами:

-   неявно – присваивая символьную строку значению переменной даты-времени
    (рискованный вариант),

-   явно – с помощью встроенных функций Cast и CONVERT (наиболее
    предпочтительный вариант).

Пример. Вставка в таблицу “Успеваемость” USP (ID - первичный ключ, ID_NUM -
номер зачетки, OCENKA - оценка, ID_PREDM – код предмета, CDATE – дата оценки
типа smalldatetime), дата вставляется неявно.

>   INSERT INTO USP(ID, ID_NUM, OCENKA, ID_PREDM, CDATE ) VALUES(1, 3001, 3, 1,
>   '2010/05/19') --(формат ‘YYYY/MM/DD’)

>   Или так … VALUES(… , '2010-05-19') -- (формат ‘YYYY-MM-DD’).

>   Или так … VALUES(… , '2010.05.19') -- (формат ‘YYYY.MM.DD’).

>   Или так … VALUES(… , '05.19.2010') -- (формат ‘MM.DD.YYYY’).

>   Или так … VALUES(… , '05.19.10') (формат ‘MM.DD.YY’).

Однако вставка даты в формате VALUES(… , '09.05.19') будет выполнена, но даст
результат 2019-09-05 00:00:00, т.е. '09.05.19' это формат 'месяц.день.год'.

Ошибка преобразования (Conversion failed when converting character string to
smalldatetime data type.) возникнет в случае:

>   … VALUES ('05 19 2010')

В таблице 5.2 приведены основные функции для работы со значениями даты/времени в
SQL Server 2005.

>   Таблица 5.2 − Функции для работы со значениями даты/времени в

>   SQL Server 2005

| № | Функция    | Характеристика                                                                                                                                                                                                              |
|---|------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1 | DAY        | Возвращает целое число, представляющее часть даты \<date\> и соответствующее дню месяца. Синтаксис: DAY (\<date\>).                                                                                                         |
| 2 | YEAR       | Возвращает целое число, соответствующее числовому значению года. Синтаксис: YEAR (\<date\>).                                                                                                                                |
| 3 | MONTH      | Возвращает целое число, соответствующее                                                                                                                                                                                     |
|   |            | номеру месяца года. Синтаксис: MONTH (\<date\>). Select id, DAY(tdate) As 'День', MONTH(tdate) As 'Месяц', YEAR(tdate) As 'Год' From TTime Столбец tdate имеет тип smalldatetime.                                           |
| 4 | GETDATE    | Возвращает текущую системную дату и время. INSERT INTO TTime (tdate) VALUES (GETDATE()) При выводе получится значение 2010-05-17 10:07:00.                                                                                  |
| 5 | DATENAME   | Возвращает строку со значением даты/времени (или фрагмент даты/времени).                                                                                                                                                    |
| 6 | DATEPART   | Возвращает целое число со значением даты/времени (или фрагмент даты/времени).                                                                                                                                               |
| 7 | DATEADD    | Складывает значение даты \<date\> с интервалом \<number\> и возвращает новое значение даты. Параметр \<datepart\> определяет единицу измерения интервала. Синтаксис: DATEADD (\<datepart\>, \<number\>, \<date\>).          |
| 8 | DATEDIFF   | Возвращает результат вычисления разности между датами в указанных единицах измерения времени. Параметр \<datepart\> определяет единицу измерения интервала. Синтаксис: DATEDIFF (\<datepart\>, \<startdate\>, \<enddate\>). |
| 9 | GETUTCDATE | Возвращает текущее значение всеобщего скоординированного времени (UTC – Universal Coordinated Time) (всемирного гринвического среднего времени).                                                                            |

>   Синтаксис: DATENAME (\<datepart\>, \<date\>).

Select id,tdate, DATENAME(DY, tdate) As 'День года' From TTime

(DY – шаблон номера дня с начала года)

>   Синтаксис: DATEPART (\<datepart\>, \<date\>).

Select id,tdate, DATEPART (WK, tdate) As 'Неделя года' From TTime

(WK – шаблон номера недели года)

В таблице 5.3 приведены основные компоненты и шаблоны для обозначения
даты/времени в SQL Server 2005.

>   Таблица 5.3 − Компоненты и шаблоны для обозначения даты/времени

| №  | Компонент даты          | Шаблон даты |
|----|-------------------------|-------------|
| 1  | Год                     | yy, yyyy    |
| 2  | Квартал                 | qq, q       |
| 3  | Месяц                   | mm, m       |
| 4  | Номер дня с начала года | dy, y       |
| 5  | Сутки                   | dd, d       |
| 6  | Неделя                  | wk, ww      |
| 7  | День недели             | dw          |
| 8  | Час                     | hh          |
| 9  | Минута                  | mi, n       |
| 10 | Секунда                 | ss, s       |
| 11 | Миллисекунда            | ms          |

>   Функции Cast и Convert для преобразования типов Функции Cast и Convert
>   выполняют почти что одинаковые

действия по преобразованию типов (если преобразование не осуществляется неявно),
однако функция Cast совместима со стандартом ANSI, а функция Convert не
предусмотрена стандартом ANSI.

>   Синтаксис функций преобразования: Cast (expression As data_type) Convert
>   (data_type, expression [, style])

-   expression – выражение для преобразования,

-   data_type – тип в который происходит преобразование,

-   style – опция форматирования преобразования (вид результата).

Пример. Преобразовать дату (tdate) в строку. TTime(id (первичный ключ) smallint
IDENTITY(1,1) NOT NULL, tdate (дата) smalldatetime NOT NULL).

Select id, ('дата '+ tdate) As 'Date' From TTime

Данный оператор Select не выполнится, будет ошибка преобразования:

Msg 295, Level 16, State 3, Line 1

Conversion failed when converting character string to smalldatetime data type.

>   Пример использования функции Cast

Select id, ('дата '+ Cast (tdate As varchar)) As 'Date' From TTime

>   Результат имеет вид: дата May 17 2010 10:07AM

Select id, ('дата '+ Cast (tdate As varchar(12))) As 'Date' From TTime

>   Результат имеет вид: дата May 17 2010

>   Пример использования функции CONVERT

Select id, ('дата '+ CONVERT(VARCHAR(12), tdate, 111)) As 'Date' From TTime

-   style=111 – стиль японского стандарта вывода даты в виде - 2010/05/17

-   style=100 – стиль стандарта вывода даты в виде - May 17 2010

>   Результат имеет вид: дата 2010/05/17

1.  Предложение VALUES задает в круглых скобках значения, которые будут помещены
    в таблицу или эти значения формируются посредством подзапроса. Обязательным
    является требование совместимости типов данных полей и типов данных
    значений, которые в них помещаются.

2.  Значения, которые задаются в VALUES, являются скалярными и не могут быть
    вычисляемыми выражениями.

3.  Сама команда INSERT никакого вывода не производит.

Вторая форма оператора вставки INSERT имеет следующий синтаксис:

INSERT INTO \<имя_таблицы \| представление\> [(имя_поля1,

имя_поля2, ...)] \<подзапрос\>

Применение оператора INSERT с подзапросом позволяет загружать сразу несколько
строк в одну таблицу, используя информацию, выбранную SQL-оператором SELECT из
другой таблицы этой же или другой БД. INSERT с подзапросом добавляет в таблицу
столько строк, сколько извлекает подзапрос из другой таблицы.

>   Особенности работы оператора INSERT:

1.  Требуется полная совместимость таблицы, которую возвратит SQL-оператор
    SELECT, с полями таблицы, которые заданны в SQL-операторе INSERT. Другими
    словами, количество полей, порядок их следования и типы данных должны
    совпадать.

2.  Предложение FROM подзапроса не должно содержать ссылок на таблицу, в которую
    вставляют строки, то есть нельзя использовать коррелированные подзапросы.

3.  В INSERT можно использовать подзапросы внутри любого запроса, причем эти
    подзапросы могут быть и соотнесенные (связанные, коррелированные).

Пример. Вставить в таблицу Excellent записи о студентах отличниках, которые
необходимо выбрать из таблицы Usp.

>   INSERT INTO EXCELLENT

>   SELECT \* FROM USP WHERE OCENKA=5

Для того чтобы не произошло ошибки, таблица EXCELLENT должна уже быть создана и
иметь тоже количество столбцов и типы данных в столбцах, что и в таблице USP (в
общем случае – что возвращает запрос).

С помощью указания имен столбцов при вставке можно переупорядочивать добавляемую
информацию.

Пример. Вставить в таблицу RAITING информацию о среднем балле каждого студента.

>   INSERT INTO RAITING (Id_Stud, AVG_Ocenka)

>   SELECT Id_Stud, AVG(Ocenka) FROM USP

>   GROUP BY Id_Stud

Необходимо чтобы имена столбцов таблицы RAITING, а значит, последовательность
данных во вставляемом списке, совпадали с порядком следования полей в
предложении SELECT.

Таблицы USP и RAITING никак не связаны между собой. Если в дальнейшем оценки
студентов, а значит и средний балл, будут меняться, то эти изменения, внесенные
в таблицу USP, не затронут таблицы RAITING. Если необходимо, чтобы в таблице
оперативно поддерживалась информация, следует использовать возможности
представления.

Вторая форма оператора часто используется для решения задач “упаковки” таблиц
путем сохранения результирующих данных в других таблицах с удалением более
подробной информации, которая являлась источником. Такая задача в ряде систем
является очень острой.

Пример. Пусть существует БД городской АТС, в которой регистрируются все звонки
абонентов. Для каждого звонка сохраняется его дата, длительность, номер абонента
с которым был разговор. Таким образом, в течении месяца создается некоторое
количество записей для каждого абонента АТС. В конце месяца на основании этой
информации абоненту распечатывается и отсылается счет за услуги связи, в котором
проставлено только общее время пользования телефоном. После того, как абонент
рассчитался за услуги и не требует предоставить ему полную распечатку,
информация о звонках становится не нужной и более того потенциально опасной.
Опасность заключается в ее количестве. Обычная АТС содержит в своем составе
несколько десятков тысяч номеров. Следовательно, каждые несколько секунд в базу
поступает информация о сделанных абонентами звонках. За год работы АТС объем
информации, будет громадным. Это скажется на скорости работы информационной
системы, поскольку при построении отчета используется вся информация, которая
хранится за год, хотя фактически требуется за последний месяц. Построение
промежуточных отчетов позволяет руководству видеть картину загрузки АТС в
течении заданного промежутка времени и одновременно отсылать отчеты абонентам.
Таким образом, этот пример демонстрирует как можно повысить производительность
информационной системы за счет грамотного проектирования ее частей.

SQL-операторы удаления данных из таблицы DELETE и
=================================================

>   **TRUNCATE**

SQL Server предоставляет два оператора для удаления строк из таблицы или
представления: оператор DELETE и оператор TRUNCATE TABLE. Оператор TRUNCATE
TABLE безо всяких условий удаляет все строки в таблице. Оператор DELETE
обеспечивает большую гибкость и дает возможность удалять только избранные строки
с помощью фразы WHERE, которая может включать дополнительные таблицы и
представления.

>   Оператор DELETE имеет следующий синтаксис:

DELETE [FROM] таблица_или_представление

[FROM источники_таблиц] [WHERE условие_отбора]

>   Особенности оператора DELETE:

1.  Первая фраза FROM является необязательной и используется для
    удобочитаемости.

2.  Список столбцов в операторе DELETE не указывается, поскольку при удалении
    строки удаляются также все столбцы.

3.  Необязательная фраза WHERE дает возможность указывать, какие строки следует
    удалить.

4.  Если фраза WHERE опущена, удаляются все строки в указанной таблице или
    представлении.

5.  Необязательная вторая фраза FROM позволяет задавать дополнительные источники
    (таблицы или представления), которые будут использоваться в условии отбора в
    фразе WHERE.

6.  Подобный синтаксис оператора может ввести в заблуждение, поскольку строки не
    будут удаляться из таблиц и представлений, указанных во второй фразе FROM.

7.  Если во второй фразе FROM указывается более одной таблицы или представления,
    их имена следует отделять запятыми.

>   Пример. Удаление данных из таблицы STUDENT.

DELETE FROM STUDENT - удаление всего содержимого таблицы

STUDENT.

DELETE FROM STUDENT WHERE OCENKA=5 DELETE FROM STUDENT WHERE TDATE\<=31/03/2010

Результат выполнения оператора TRUNCATE TABLE идентичен результату выполнения
оператора DELETE, для которого не указано условие WHERE, т.е. из таблицы
удаляются все строки.

>   Пример. TRUNCATE TABLE STUDENT

Оператор TRUNCATE TABLE работает более эффективно, чем аналогичный оператор
DELETE, так как последний удаляет по одной строке за один проход и вносит в
журнал транзакций отдельные записи для каждой из них. Оператор TRUNCATE TABLE
удаляет все

строки путем очищения страниц, назначенных для таблицы, и в журнал транзакций
записываются только эти освобождения.

>   Особенности оператора TRUNCATE TABLE:

1.  При использовании TRUNCATE TABLE автоинкрементный счетчик обнуляется, при
    добавлении следующей строки будет использовано исходное начальное значение
    для этого столбца. Инструкция DELETE сохраняет значение счетчика.

2.  Оператор TRUNCATE TABLE нельзя использовать для таблиц, на которую есть
    ссылки внешнего ключа из других таблиц. В этом случае надо использовать
    DELETE.

3.  Удаления, выполненные посредством TRUNCATE TABLE, не активизируют триггеры
    удаления. Это, по сути, обход инстукции DELETE.

4.  Если таблица является частью индексированного представления, то в ней не
    удастся использовать инструкцию TRUNCATE TABLE.

>   Чтобы ... Синтаксис оператора SQL

Удалить все строки с DELETE таблица_или_представление использованием оператора

DELETE

Удалить избранные строки с DELETE таблица_или_представление использованием фразы
WHERE (условие_отбора)

WHERE

Удалить избранные строки с DELETE таблица_или_представление использованием
условия на FROM источники_таблиц WHERE

основе другой таблицы (условие_отбора)

Удалить все строки с TRUNCATE TABLE использованием оператора
таблица_или_представление TRUNCATE TABLE

SQL-оператор модификации данных в таблице UPDATE
================================================

SQL-оператор UPDATE представляет операцию изменения уже существующих данных в
таблице.

Синтаксис оператора модификации UPDATE следующий: UPDATE \<имя_таблицы\>

SET\<имя_поля1\>=\<значение1\|выражение\>[,\<имя_поля2\>=\<значение2

>   \|выражение\>,...] [FROM \<имя_таблиц(ы)_источника\>] [ WHERE \<условие
>   ограничения \> ]

За ключевым словом SET следует перечень подлежащих обновлению столбцов,
отделяемых запятыми, а также их новые значения. Форма записи при этом следующая:
имя_столбца =

новое_значение. Новое значение может быть константой, выражением, которое также
может ссылаться на сам столбец, DEFAULT или NULL. Например, выражение STIP =
STIP \* 1.10 будет увеличивать значения в столбце STIP на 10 процентов.

Фраза WHERE является необязательной. Если она имеется, то должна задавать
строки, подлежащие обновлению. Если фраза WHERE в операторе UPDATE отсутствует,
будут модифицироваться все строки в таблице.

>   Особенности работы оператора UPDATE:

1.  Оператор UPDATE работает только с одной таблицей.

2.  Предложение SET определяет набор полей и значений, которые будут им
    присвоены.

3.  Если условие WHERE отсутствует, то изменения вносятся во все строки таблицы.

>   Пример. Изменить в таблице USP оценки всех студентов на 5.

UPDATE USP SET OCENKA=5

1.  Предложение WHERE задает условие, определяющее множество записей, в которых
    в указанные поля будут помещены соответствующие значения.

Пример. Изменить в таблице USP оценки на 5 по предмету с кодом 503.

UPDATE USP SET OCENKA=5 WHERE Id_Predm=503

1.  В предложении можно использовать выражения, располагая их в списке для того
    поля, которое необходимо изменить.

Пример. В таблице STUDENT увеличить стипендию на 50% тем студентам, у которых
стипендия не превышает 75.

UPDATE STUDENT SET Stip = Stip \* 1.5 WHERE Stip \<= 75

1.  Так как предложение не является предикатом, то можно обычным образом вводить
    NULL значения.

Пример. Изменить в таблице USP оценки на NULL по предмету с кодом 503.

UPDATE USP SET OCENKA = NULL WHERE Id_Predm=503

1.  В предложении WHERE оператора UPDATE допустимо использовать подзапросы.
    Запрещены ссылки во вложенных запросах к таблице, которая модифицируется
    командой UPDATE.

Пример. В таблице STUDENT увеличить стипендию в два раза тем студентам, у
которых имеются оценки по крайней мере по двум предметам.

UPDATE STUDENT

>   SET Stip=Stip\*2 WHERE 2\<=

>   (SELECT COUNT(Id_Predm) FROM USP

>   WHERE STUDENT.Id_Predm=USP.Id_Predm

>   AND OCENKA IS NOT NULL)

Здесь внутренний запрос подсчитывает количество записей с оценками в таблице
успеваемости USP для каждого студента, и, если оно 2 или более, то предикат
основной функции становится истинным, а размер стипендии модифицируется.

Пример. Увеличить значение размера стипендии на 50 в записях студентов, сдавших
экзамены на 4 и 5.

UPDATE STUDENT

>   SET STIP = STIP + 50 WHERE 4 \<=

>   (SELECT MIN(OCENKA) FROM USP

>   WHERE USP. ID_STUD = STUDENT. ID_STUD)

1.  К существенному недостатку UPDATE стоит отнести невозможность из команды
    модификации UPDATE сослаться на таблицу, используемую в подзапросе.

Пример. Невозможно одной командой выполнить такое действие, как модификация
оценок студентов, у которых оценки ниже средней. Для выполнения этого действия
сначала надо вычислить среднюю оценку

SELECT AVG(OCENKA) FROM USP

>   А затем результат этого запроса (пусть это будет 4.3)

использовать для модификации.

>   UPDATE USP

>   SET OCENKA = OCENKA -1 WHERE OCENKA\<=4.3

Пример. Пусть средний бал студента с именем “Иванов” был посчитан не верно и
требуется обновить информацию в поле avg_mark таблицы STUDENT.
Последовательность операторов будет выглядеть вот так:

1.  SELECT id FROM STUDENT WHERE name='Иванов';

2.  сохранить поле id

3.  UPDATE STUDENT SET avg_mark=4.8 WHERE id=сохр_поле;

Можно задать вопрос: если используется имя студента для получения его первичного
ключа, то нельзя ли вместо 3 действий воспользоваться одним, и записать оператор
обновления информации так:

UPDATE STUDENT SET avg_mark=4.8 WHERE name='Иванов';

Ответ, конечно, можно. Но такой оператор таит в себе потенциальную опасность,
связанную с тем, что в базе может храниться информация об однофамильцах или
родственниках. Тогда такой оператор изменит содержимое в нескольких записях.
Именно по этой причине более правильным является первая последовательность,
которая состоит из 3 операторов. Как и в случае с SQL-оператором DELETE
последовательность разнесена во времени. Первые два оператора выполняются для
обеспечения пользователя необходимой информацией через интерфейс, а третий,

только тогда, когда он изменяет информацию. Задачей программиста здесь является
извлечение первичного ключа вместе с информацией, которая отображается
пользователю на экран, и сохранение его значения для дальнейшего использования.

>   Чтобы... Синтаксис оператора SQL

Модифицировать все строки в таблице

Модифицировать избранные строки в таблице

Модифицировать строки с использованием фразы FROM

>   UPDATE таблица_или_представление SET объекты_изменения Объекты_изменения
>   представляют собой список отделяемых запятыми элементов вида

>   столбец = значение, столбец = значение,

>   ...

>   UPDATE таблица_или_представление

>   SET объекты_изменения

>   WHERE условие

>   UPDATE таблица_или_представление

>   SET объекты_изменения

>   FROM таблица_или_представление оператор_связывания условие_связывания

>   [WHERE (условие_ограничения)]

>   Контрольные вопросы

1.  Какие существуют формы языка SQL?

2.  Какие существуют компоненты языка SQL?

3.  Какие основные предложения входят в состав DDL, DML и DCL?

4.  Назначение, синтаксис и особенности оператора CREATE TABLE?

5.  Какие существуют типы ограничений целостности базы данных?

6.  Какие существуют виды ограничений целостности базы данных на уровне поля? С
    помощью каких операторов они реализуются?

7.  Каковы особенности задания ограничения столбца по ссылке?

8.  Как обеспечивается ссылочная целостность при удалении связанных кортежей?

9.  Каковы назначение, синтаксис и особенности оператора ALTER TABLE?

10. Каковы назначение, синтаксис и особенности оператора

DROP TABLE?

1.  Каковы назначение, синтаксис и особенности оператора

INSERT? Две формы оператора INSERT.

1.  Каковы назначение, синтаксис и особенности оператора

DELETE?

1.  Каковы назначение, синтаксис и особенности оператора

TRUNCATE?

1.  Каковы назначение, синтаксис и особенности оператора

UPDATE?

>   Лабораторная работа 3

Создание простых запросов к базе данных
=======================================

>   Постановка задачи:

На основании таблиц физической модели данных, бизнес-правил предметной области и
скриптов создания таблиц БД создать:

1.  Создать скрипт создания тестовых данных в БД (оператор INSERT) (минимум по
    5-7 записей в каждой таблице).

2.  Создать оператор SELECT, который извлекает данные из одной таблицы и
    сортирует их по двум полям в разных направлениях.

3.  Создать оператор SELECT с использованием условия на основе оператора LIKE.

4.  Создать операторы SELECT с использованием условия на основе операторов
    BETWEEN, IN, IS NULL.

5.  Создать оператор SELECT, который использует агрегатные функции и содержит
    группировку (GROUP BY и HAVING).

6.  Создать скрипт изменения тестовых данных в БД (оператор UPDATE) (минимум к 3
    различным таблицам).

7.  Создать скрипт удаления тестовых данных в БД (оператор DELETE) (минимум в 3
    различных таблицах).

Для создания указанных скриптов и запросов использовать команды языка
манипулирования данными DML.

>   Письменный отчет по лабораторной работе должен содержать:

1.  Титульный лист, содержащий – название лабораторной работы, фамилию, имя,
    отчество, номер группы исполнителя, дату сдачи.

2.  Диаграмму БД.

3.  Скрипт занесения информации в таблицы БД.

4.  SQL-операторы SELECT для работы с БД.

5.  Скрипт изменения информации в таблицах БД.

6.  Скрипт удаления информации из таблиц БД.

7.  Привести примеры работы основных операторов в соответствии с постановкой
    задачи (в виде − оператор + результат его работы).

8.  Выводы по лабораторной работе (в выводах отразить особенности занесения и
    модификации информации в БД, SQL- операторов SELECT и пути дальнейшей
    модернизации БД).

>   Контрольные вопросы и задания

1.  К каким языкам относится язык SQL?

2.  Какие формы языка SQL существуют?

3.  Каковы компоненты языка SQL?

4.  Каковы основные предложения языка SQL?

5.  Каков синтаксис оператора SELECT?

6.  Каковы основные особенности использования предложения

SELECT?

1.  Каковы основные особенности использования предложения

FROM?

1.  Каковы основные особенности использования предложения

WHERE?

1.  Каковы особенности использования предложений GROUP BY и HAVING?

2.  Каковы основные особенности использования предложения

ORDER BY?

1.  Каковы особенности использования операторов BETWEEN, IN, IS NULL, LIKE?

2.  Каковы основные правила работы с псевдонимами в SQL?

>   Лекция 6. **Оператор выборки данных SELECT** (1)

Общие сведения об операторе выборки данных SELECT
=================================================

>   SQL-оператор SELECT является одним из самых важных в БД. Основной задачей
>   оператора является извлечение данных из таблиц согласно условию, которое
>   поставил пользователь. Современные информационные системы оперируют столь
>   большим числом записей, что производительность SQL-оператора SELECT является
>   одной из важнейших характеристик СУБД.

>   Оператор SELECT состоит из нескольких предложений или клауз (термин “клауза”
>   – от английского слова clause – предложение), каждая из которых выполняет
>   определенные действия. Порядок следования предложений и их формат четко
>   определены, но только несколько предложений являются обязательными,
>   остальные можно использовать по необходимости.

>   Вот общий вид SQL-оператора SELECT:

>   SELECT [ ALL \| DISTINCT ] определение_полей

>   FROM определение таблиц

>   [ WHERE условие ]

>   [ GROUP BY условие_группировки [ HAVING условие ] ] [ ORDER BY
>   условие_сортировки ]

>   Как обычно необязательная часть выделяется квадратными скобками.

>   Оператор SELECT может содержать 6 предложений:

1.  SELECT – определяет набор полей, которые требуется получить в результате
    запроса (ALL - повторяющиеся строки присутствуют, DISTINCT - отсутствуют).

2.  FROM – определяет набор таблиц, откуда извлекается результат.

3.  WHERE – определяет условие извлечения данных.

4.  GROUP BY – определяет условие группировки данных.

5.  HAVING – определяет условие внутри группировки.

6.  ORDER BY – определяет поля и порядок сортировки.

Предложение SELECT оператора SELECT определяет набор полей, которые будут
формировать результирующую таблицу. В качестве поля могут быть заданы:

1.  поля таблиц;

2.  простейшее выражение или SQL-выражение;

3.  агрегатная функция, где в качестве аргумента, используется поле или
    SQL-выражение.

Для задания полей могут быть использованы следующие нотации:

1.  “\*” – все поля всех таблиц, которые участвуют в запросе;

2.  имя_поля – обозначает поле с именем “имя_поля”;

3.  имя_таблицы.имя_поля – обозначает поле с именем “имя_поля”

таблицы “имя_таблицы” (или псевдоним.имя_поля);

1.  SQL-выражение – SQL-выражения, куда входят поля таблиц. Каждый производитель
    СУБД определяет термин “SQL-

выражение” по своему, но в соответствии со стандартом ANSI SQL

понятие SQL-выражения определено так.

>   SQL-выражениями являются:

1.  выражения с арифметическими операциями “плюс”, “минус”, “умножить”,
    “разделить”, где в качестве аргументов используются поля таблиц БД или
    константы.

2.  SQL-функция, в качестве аргумента которой используется поле таблицы базы,
    константа или их комбинация с помощью арифметических операций.

3.  комбинации с помощью арифметических операций полей таблиц и вызовов
    SQL-функций.

>   Примеры SQL-выражений.

a+b

SIN(a + b) SIN(a) + SIN(b) SIN(1)

SIN(a) + 1

В данном примере a и b – являются полями некоторой таблицы БД. SIN и COS –
функции получения синуса и косинуса.

COS(a) + SIN(b) + a + 1

Любая современная СУБД содержит в своем составе большое количество стандартных
функций, которые могут быть использованы в

операторе SELECT при извлечении данных из БД. Использование таких функций в ряде
случаев оказывается очень эффективным, потому что экономит время при разработке
ПО и значительно ускоряет процесс получения конечного результата, за счет того,
что SQL-оператор SELECT выполняется на сервере, который, как правило, обладает
значительно большей мощностью, чем рабочая станция пользователя. Позже будет
рассмотрен набор стандартных функций СУБД.

Предложение FROM оператора SELECT
=================================

Предложение SELECT рассматривать не закончили, но продолжать не можем, потому
что самый простой SQL-оператор SELECT всегда содержит в своем составе и
предложение FROM, которое задает таблицы, участвующие в запросе.

В SQL-операторе SELECT может быть задано столько таблиц, сколько необходимо для
выполнения текущей задачи извлечения данных, что позволяет создавать эффективные
операторы SELECT, которые сильно упрощают работу по обработке данных.

>   Форма задания одной таблицы следующая: FROM имя_таблицы [псевдоним]

Если необходимо извлечь данные из нескольких таблиц, то они перечисляются через
запятую:

>   FROM имя_таблицы1 [ псевдоним1], имя_таблицы2 [

псевдоним2], ...

Для каждой таблицы можно определить ее псевдоним, который действует в рамках
всего SQL-оператора SELECT. Псевдоним позволяет сократить определение полей,
поскольку при проектировании базы правильным считается задание такого имени
таблицы, которое бы отражало сущность хранимых в ней данных. Так если необходимо
хранить информацию о студентах, то логично назвать таблицу именем “Student”.
Однако при дальнейшем использовании этого имени SQL-оператор SELECT значительно
увеличивается в размерах, что приводит к трудностям при его прочтении и, как
следствие, ведет к ошибкам. Поэтому для такой таблицы в рамках данного оператора
вводится псевдоним, например “S”:

>   SELECT S.name FROM Student S

Данный оператор извлекает из таблицы “Student” имена студентов не сортируя их.
SQL-оператор INSERT всегда вставляет данные в БД в порядке их поступления с
целью снижения расходов связанных с помещением данных на накопитель информации.
SQL- оператор SELECT всегда обрабатывает данные в том порядке, в котором они
были сохранены.

Рассмотренный оператор содержит некоторое количество избыточных конструкций. В
одной таблице не может существовать несколько полей с одинаковыми именами,
следовательно, явное указанием имени таблицы при задании поля в предложении
SELECT не требуется, точно так же как и использование псевдонима имени таблицы.
Следовательно, приведенный выше оператор можно записать так:

>   SELECT name FROM Student

>   Обе приведенные версии являются абсолютно правильными.

Рассмотрим использование специальной нотации “\*” при задании полей таблиц.
Символ “\*”, указанный в клаузе SELECT, обозначает все поля всех таблиц, которые
указаны в предложении FROM. Таким образом, чтобы получить содержимое всей
таблицы “Student” достаточно написать так:

>   SELECT \* FROM Student - просмотр всех полей таблицы

“Student”

Такая форма оператора используется только при разработке программного
обеспечения. При написании программы правильным стилем является явное указание
всех полей, которые формируют результирующую таблицу SQL-оператора SELECT. Это
связанно с возможным расширением набора полей таблицы в будущем. Если такое
произойдет, то неверное задание SQL-операторов может привести к большим
трудностям при доработке программного обеспечения. Порядок следования полей в
таком операторе определяется порядком следования полей в SQL-операторе CREATE
TABLE.

Предложение SELECT позволяет задавать несколько полей, перечисляя их через
запятую.

Пример. Получить информацию о том, у какого студента какой средний бал (поле
sr_ball).

>   SELECT name, sr_ball FROM Student Пример. Перестановка выводимых столбцов.
>   SELECT sr_ball, name FROM Student

![](media/069594de045d2a063a984563357d5387.png)

Пример - иллюстрирует преимущества задания псевдонимов для таблиц запроса.
Предположим, что существует таблица “Groups”, которая содержит информацию о
группах студентов (рисунок 6.1). В таблице “Student” существует внешний ключ,
связанный с первичным ключом таблицы “Groups”. Если поле отображает имя группы,
то соответственно мы называем его “name”. Но точно так же мы называем поле,
которое хранит имя студента.

>   Рисунок 6.1 − Модель БД из двух таблиц

Теперь пусть необходимо получить информацию о том, какой студент учится в какой
группе. Вот так написать запрос нельзя:

>   SELECT name, name FROM Groups, Student

потому что сервер БД не сможет понять поля “name” каких таблиц необходимо
получить в результате. В таком случае на помощь приходит форма явного задания
имени таблицы при задании поля в предложении SELECT:

>   SELECT Student.name, Groups.name FROM Groups, Student

Недостатком данного оператора является длинная запись. Здесь становиться
очевидным преимущество использования псевдонимов при задании имени таблицы. Тот
же самый оператор можно записать и так:

>   SELECT s.name, g.name FROM Groups g, Student s

Такой оператор выглядит несколько короче и при этом не потерял своего
читабельного вида. Не должно смущать то, что определение псевдонимов для таблиц
идет после предложения SELECT, в которой эти псевдонимы уже используются. Разбор
SQL- оператора SELECT СУБД выполняет таким образом, что псевдонимы уже
определены на этапе проверки предложения SELECT. Поэтому приведенная запись
является абсолютно правильной.

Какой псевдоним выбирать для какой таблицы – дело личного вкуса и предпочтений.
Псевдоним может состоять из любого количества символов. На практике, при работе
с большой базой используют двухбуквенные обозначения, чтобы псевдонимы все-таки
отражали таблицы и оператор не потерял читабельности. В простых операторах
достаточно и одного символа, чтобы покрыть все имена таблиц запроса.

Рассмотренный запрос демонстрирует еще одно важное свойство оператора SELECT –
возможность задания и использования нескольких таблиц. В данном случае
использованы 2 таблицы, но можно задать и большее число таблиц. Все зависит от
конкретной операции над данными. И сразу возникает вопрос, ведь никто не
требует, чтобы таблицы “Groups” и “Student” содержали одинаковое количество
данных. Тогда каким образом будет выглядеть результат предыдущего запроса?

Пусть в таблице “Groups” хранится информация о двух группах – в первой с именем
“535” 2 студента, а во второй с именем “535а” тоже 2 студента. Пусть таблица
“Groups”имеет вид:

![](media/b258c923b83df32fcd1ea09c6e7f13ca.png)

>   Пусть таблица “Student”имеет вид:

![](media/78472c2a7f16109f76f73156008ced68.png)

>   При выполнении SQL-оператора

>   Select s.name,g.name From Groups g, Student s

база данных “склеит” данные таблиц таким образом, чтобы в результате получилась
таблица в первой нормальной форме. Такая “склейка” выполняется после
многократного повторения информации одной таблицы, в которой записей меньше, с
другой, в которой записей больше. Таким образом, будет получен вот такой
результат выполнения данного оператора Select:

| name    | name |
|---------|------|
| Иванов  | 535  |
| Петров  | 535  |
| Сидоров | 535  |
| Семенов | 535  |
| Иванов  | 535а |
| Петров  | 535а |
| Сидоров | 535а |
| Семенов | 535а |

>   Очевидно, что такой результат не отвечает требованию -

получить информацию о том, какой студент учится в какой группе.

На самом деле результат работы этого оператора может быть совсем другой. Для
решения поставленной задачи вывода информации о том, в какой группе какой
студент учится, нужно явным образом с помощью предложения WHERE задать условие
связи таблиц “Groups” и “Student” и тогда оператор выведет действительно ту
информацию, которая нам необходима. Но как это делается, рассмотрим чуть позже.

Оператор SELECT допускает использование в целевом списке вычисляемых полей. Если
требуется вычислить значение какого-либо выражения, даже не связанного с БД,
может быть использован оператор SELECT.

>   Пример. SELECT exp(3.1) - возвращает значение 22,1979….

Теперь рассмотрим еще одну сознательно опущенную опцию задания полей в
предложении SELECT. Попробуем решить следующую задачу. Если таблица “Student”
имеет поле “sr_ball”, которое содержит средний бал студента, то можно вывести
для каждого студента не значение этого среднего бала, а показатель его
успеваемости в процентах. Пусть “отлично” - это 100%. Путем нехитрых вычислений
можно вывести вот такую формулу, которая позволит оценить успеваемость студента:

>   усп = sr_ball \* 100 / 5

Данная формула является классическим SQL-выражением. А это значит, что можно
написать SQL-оператор SELECT, который даст информацию об успеваемости студента:

>   SELECT name, sr_ball \* 100 / 5 FROM Student

Поскольку мы работаем с одной таблицей, то при задании имени поля указывать имя
таблицы не нужно.

Но возникает следующий вопрос, какое имя будет иметь поле, содержащее
успеваемость студента? Первое поле будет называться “name”, а имя второго – СУБД
MS SQL Server сгенерирует как No column name.

![](media/c7a3ce93d32bdb473f72b3dceeb707b0.png)

Чтобы такого не произошло, можно указать в предложении SELECT имя для поля явным
образом. Это делается с помощью выражения:

>   имя_поля_таблицы AS новое_имя_поля Таким образом, можно написать следующее:

>   SELECT name AS name, sr_ball \* 100 / 5 AS sr_ball FROM student

Теперь имена полей определены и можно на них ссылаться в дальнейшем при
обработке результата работы оператора SELECT в программе. При задании имени поля
с помощью AS можно использовать любые символы, которые могут образовывать не
только слова, но и словосочетания. Если в наименовании поля содержится символ
“пробел”, то его можно взять в одинарные кавычки. Это позволяет писать вот такие
операторы SELECT:

>   SELECT name AS 'Ф.И.О.',

>   sr_ball \* 100 / 5 AS 'Успеваемость(%)' FROM Student

![](media/65d52bb68334bf165c687da6de535fb6.png)

Данный оператор демонстрирует еще одну технику записи SQL- оператора SELECT.
Вероятность того, что SQL-оператор SELECT не влезет в одну строку довольно
высока. Согласно определению SQL- оператор может быть многострочным. Поэтому,
если оператор длинный и не помещается в одну строку, то его записывают в
несколько строк, используя отступы для повышения читабельности самого оператора,
как это делается и в обычных программах. При этом предложения записывают друг
под другом, а их аргументы с некоторым сдвигом влево, чтобы отделить предложения
от аргументов.

Будет выполнен также и такой запрос, то есть связка AS при работе с псевдонимом
не обязательна.

SELECT name 'Ф.И.О.', sr_ball \* 100 / 5 'Успеваемость(%)' FROM Student

![](media/7aca902a2a9e6720eb55bbcdbfe31927.png)

Последними опущенными пока параметрами предложения SELECT являются DISTINCT или
ALL. Параметр DISTINCT удаляет из результирующей таблицы повторяющиеся записи.
Параметр ALL, который задан по умолчанию, оставляет результирующую таблицу в том
виде, в котором она получилась после склейки значений полей:

>   SELECT DISTINCT name AS 'Ф.И.О.',

>   sr_ball \* 100 / 5 AS 'Успеваемость (%)'

>   FROM Student

Если предположить, что поле name содержит только фамилию, то такой оператор
удалит однофамильцев с одинаковой успеваемостью.

DISTINCT отслеживает, какие значения появились в списке выходных данных, и
исключает из него дублирующиеся значения.

Параметр DISTINCT можно задать только один раз для данного предложения SELECT.
Если SELECT извлекает множество полей, то он исключает строки, в которых все
выбранные поля идентичны. Строки, в которых некоторые значения одинаковы, а
другие — различны, включаются в результат. DISTINCT, фактически, действует

на всю выходную строку, а не на отдельное поле (исключение составляет его
применение внутри агрегатных функций), исключая возможность их повторения.

Размещение текста в выводе запроса осуществляется следующим образом

>   SELECT DISTINCT name AS 'Ф.И.О.',

>   stip AS 'Стипендия', ‘грн.’

>   FROM Student;

>   Вывод этого запроса имеет следующий вид:

| Ф.И.О. | Стипендия | (No column |
|--------|-----------|------------|


>   name)

| Иванов | 200.80 | грн. |   |
|--------|--------|------|---|
| Петров | 250.85 | грн. |   |
| …      | …      | …    |   |

>   Выводы:

1.  Любой SQL-оператор SELECT должен иметь в своем составе предложение SELECT,
    задающее результирующие поля, и предложение FROM, определяющую набор таблиц,
    участвующих в запросе.

2.  При задании поля можно использовать SQL-выражения и определить для каждого
    поля его новое имя с помощью выражения AS.

3.  С целью сокращения записи оператора и повышения его читабельности, для
    таблиц можно задать краткие псевдонимы, которые действуют в рамках всего
    SQL-оператора SELECT.

    1.  Предложение WHERE оператора SELECT

>   Особенности предложения WHERE:

1.  Предложение WHERE задает условие извлечения данных из таблиц(ы). Предложение
    WHERE команды SELECT позволяет определить предикат, то есть условие, которое
    может быть либо истинным, либо ложным для каждой строки таблицы.

2.  Команда извлекает только те строки из таблицы, для которых предикат имеет
    значение ” истина”.

3.  С помощью этой клаузы явным образом задается связь между таблицами базы
    (условия связи), а так же дополнительные условия (условия выборки), которые
    требуются для успешной реализации оператора SELECT.

>   Рассмотрим предыдущий пример с таблицами “Groups” и

>   “Student”. Таблица “Student” имеет в своем составе внешний ключ,

который ссылается на первичный ключ таблицы “Groups”. При создании таблиц БД,
эта ссылка вылилась в конкретные клаузы оператора CREATE TABLE. СУБД не
выполняет автоматически связи между таблицами, связь нужно задавать явным
образом при выполнение каждого SQL-оператора SELECT. Только это может
гарантировать правильность результата. Таким образом, рассмотренный ранее
оператор нужно записать вот так:

>   SELECT s.name AS 'Ф.И.О. студента', g.name AS 'Имя группы'

>   FROM Groups g, Student s WHERE g.id = s.id_group

Здесь в оператор SELECT добавлено предложение WHERE, в котором четко определено,
что идентификатор группы в таблице “Student” должен совпадать с идентификатором
группы в таблице “Groups”. С первого взгляда кажется, что это условие является
не нужным. Но его наличие гарантирует нам правильный результат. Ведь отсутствие
этого условия дает право СУБД склеить таблицы в порядке создания записей, а не в
порядке принадлежности студентов к группе.

Следующим важным моментом этого оператора является использование полей “id” и
“id_group” в условии клаузы WHERE при их отсутствии в клаузе SELECT. Право
обращаться к этим полям нам дает не их перечисление в клаузе SELECT, а
перечисление таблиц, в которые они входят, в предложении FROM. Всегда нужно
помнить о том, что предложение SELECT определяет поля, которые будут в
результирующей таблице, но не определяет набор полей, который можно использовать
в выражениях других клауз SQL-оператора SELECT.

Для задания условий используются следующие операции отношений (реляционные
операции сравнения):

1. = - “равно”,

1.  \< \> - “не равно” (или !=),

2.  \> - “больше”,

3.  \< - “меньше”,

4.  \> = - “больше или равно”,

5.  \< = - “меньше или равно”,

6.  ! \> - “ не меньше”,

7.  ! \< - “ не больше”.

Пример. Запрос на просмотр из БД информации об успеваемости студента Иванова.

>   SELECT name AS 'Ф.И.О.',

>   sr_ball \* 100 / 5 AS 'Успеваемость (%)' FROM Student

>   WHERE name = ‘Иванов’

Пример. Запрос на просмотр из БД информации о студентах, получающих стипендию.

>   SELECT name AS 'Ф.И.О.',

>   stip AS 'Стипендия' FROM Student

>   WHERE stip \>0

Рассмотренные условия принадлежит к типу условий, которые часто называют
условиями выборки.

Стандартные булевы операторы SQL, − это AND, OR, NOT. Существуют и другие, более
сложные булевы операторы (как, например, ”исключающее ИЛИ”), но их можно
построить с помощью трех указанных булевых операторов. Булева логика
”истина/ложь” представляет полный базис для работы цифрового компьютера. Поэтому
фактически весь SQL можно свести к булевой логике. Далее перечислены булевы
операторы и основные принципы их действия:

-   AND (операция “логическое И”) берет два булевых выражения (в виде A AND B) в
    качестве аргументов и дает в результате истину, если они оба истинны.

-   OR (операция “логическое ИЛИ”) два булевых выражения (в виде A OR B) в
    качестве аргументов и оценивает результат как истину, если хотя бы один из
    них истинен.

-   NOT берет единственное булево выражение (в виде NOT A) в качестве аргумента
    и изменяет его значение с истинного на ложное или с ложного на истинное.

>   Операции AND и OR являются бинарными: условие1 AND условие2

>   условие1 OR условие2

>   условие1 AND условие2 OR условие3.

>   Операции AND, OR и NOT можно комбинировать в одну последовательность,
>   создавая требуемое условие выборки данных.

Пример. Выбрать из таблицы Student студентов, у которых средний балл не ниже 3 и
которые принадлежат группе номер 5.

>   SELECT name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’, Id_Group FROM Student

>   WHERE sr_ball \>=3 And Id_Group=5

Пример. Выбрать из таблицы Student студентов, у которых средний балл не ниже 3 и
которые не принадлежат группе номер 1.

>   SELECT Id, name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’, Id_Group FROM
>   Student

>   WHERE Not (sr_ball \<3 And Id_Group=1)

Булевский оператор помещается перед реляционным оператором, на который он
действует, а при необходимости расширения действия используются скобки. В этом
случае SQL понимает круглые скобки как означающие, что все внутри них будет
оцениваться первым и обрабатываться как единое выражение с помощью того
оператора, который находится снаружи.

Вернемся к типу условий, которые могут существовать в предложении WHERE.
Расширим пример с группами и студентами, добавив к нему отношение “факультет”.
Таблица будет называться “Facility” (рисунок 6.2). Поскольку факультет состоит
из нескольких групп, которые в свою очередь состоят из студентов, то не трудно
понять, что группа связана с факультетом посредством внешнего ключа, который
ссылается на первичный ключ факультета. Пусть это поле в таблице “Groups”
называется “Id_Facility”.

![](media/9c35dbc5806fe6187f1b82faf9a30c1e.png)

![](media/9b0e5112d0abb376a1d0d2ec8afa955b.png)

![](media/9b0e5112d0abb376a1d0d2ec8afa955b.png)

>   Рисунок 6.2 − Диаграмма таблиц базы данных Составим запрос, который выводит
>   списки студентов факультета

с именем “ФРТСЛА”. Студенты связаны с факультетом косвенно, через группы,
поэтому SQL-оператор SELECT будет выглядеть вот так:

>   SELECT f.name AS 'Факультет', s.name AS 'Ф.И.О. Студента' FROM Facility f,
>   Groups g, Student s

WHERE f.id=g.id_facility AND g.id=s.id_groups AND f.name='ФРТСЛА'

Данный оператор содержит в предложении WHERE 2 условия связи и одно условие
выборки. Все три условия объединяет оператор AND.

Если посмотреть на рисунок взаимодействия таблиц базы данных, то можно увидеть,
что линий, которые показывают связи между группами две. Именно поэтому
существует два условия связи: первое и второе. Третье условие выполняет
фильтрацию данных согласно поставленной задачи.

Если связываются несколько таблиц между собой, то всегда существуют условия
связи, которых на одно меньше, чем количество таблиц, участвующих в запросе.
Знание этого правила позволяет смотреть на сложные операторы немного по-другому.
При создании таких операторов необходимо помнить, что нужно задать условия
выборки и некоторое количество условий связи. Причем условия связи формируются
автоматически – посчитали количество таблиц (можно так же считать количество
линий связи на диаграмме) и создали соответствующие условия, объединив их по
“И”. А затем приступаем к размышлениям о том, какие должны быть условия выборки.
Хотя можно делать и наоборот – сосредоточиться на условиях выборки, а затем
автоматически добавить к ним условия связи. Для

группирования условий с целью изменения порядка операций можно использовать
круглые скобки:

>   SELECT f.name AS 'Факультет', s.name AS 'Ф.И.О. Студента' FROM Facility f,
>   Groups g, Student s

WHERE (f.id=g.id_facility AND g.id=s.id_groups) AND f.name='ФРТСЛА'

Порядок приоритета операций − сначала AND, а затем OR. В данном примере
использование скобок излишество, но его основная цель – продемонстрировать
синтаксическую конструкцию использования круглых скобок.

Вернемся к нашей задаче − вывести список студентов факультета “ФРТСЛА”.
Существует еще несколько способов ее решения. Исходя из определения внешнего
ключа и правила ссылочной целостности, в поле id_facility таблицы Groups
содержится уникальный идентификатор факультета, к которому принадлежит эта
группа. Следовательно, если мы его знаем, то можем решить поставленную задачу
вот так:

>   SELECT s.name AS 'Ф.И.О. Студента' FROM Groups g, Student s

>   WHERE g.id=s.id_groups AND g.id_facility=5

Этот оператор связывает всего две таблицы, но при этом так же решает
поставленную задачу.

Однако никто не просил нас вывести вместе с именем студента еще и название
факультета, на котором он учится. Очевидно, что данный запрос будет выполняться
быстрее чем предыдущий.

В большинстве случаев данный оператор является идеологически неправильным.
Почему? Пользователь всегда работает с информационной системой через интерфейс.
Задача интерфейса – упросить работу пользователя и сделать ее максимально
приближенной к понятиям той предметной области, которую он обслуживает. Студенты
“ХАИ” знают, что номер факультета “ФРТСЛА” − 5. Но во всех официальных
документах студенты учатся не на 5 факультете, на факультете “ФРТСЛА”. Поэтому
интерфейс предоставляет список названий факультетов, а не их первичных ключей.
Ни в коем случае нельзя вводить в алгоритм работы системы правило, что первичный
ключ связан с другими полями таблицы. Это грубейшее нарушение НФБК. Наоборот,
другие поля зависят только от первичного ключа. Поэтому получается следующая
картина: пользователь выбирает в списке факультет “ФРТСЛА” и мы автоматически
приходим к оператору, который был рассмотрен первым.

Ограничение на работу предложения WHERE. В предложении WHERE нельзя использовать
агрегатные функции (если только не применяется подзапрос), поскольку предикаты
оцениваются в

терминах единственной строки, тогда как агрегатные функции оцениваются в
терминах групп строк.

>   Контрольные вопросы

1.  К каким языкам относится язык SQL?

2.  Какие формы языка SQL существуют?

3.  Каковы компоненты языка SQL?

4.  Каковы основные предложения языка SQL?

5.  Каков синтаксис оператора SELECT?

6.  Каковы основные особенности использования предложения

SELECT?

1.  Каковы основные особенности использования предложения

FROM?

1.  Каковы основные особенности использования предложения

WHERE?

1.  Каковы особенности использования предложений GROUP BY и HAVING?

2.  Каковы основные особенности использования предложения

ORDER BY?

1.  Каковы основные правила работы с псевдонимами в SQL?

>   Лекция 7. **Оператор выборки данных SELECT (2)**

>   При построении предикатов оператора WHERE в SQL

используются следующие операторы:

>   \- операторы сравнения (=, \>, \<, \>=, \<=, \< \>, !=, ! \>, ! \<),

-   булевы операторов AND, OR, NOT,

-   специальные операторы IN, BETWEEN, IS NULL, LIKE, ALL, ANY, SOME, EXISTS,

-   операторы полнотекстового поиска:

    -   CONTAINS и CONTAINSTABLE – используются для точного и неточного
        извлечения слов или фраз из текстовых столбцов,

    -   FREETEXT и FREETEXTTABLE – возвращают смысловой контекст фраз, заданных
        в строке поиска.

Указанные операторы применяют для получения выразительных и мощных предикатов.

Оператор IN (NOT IN)
====================

Оператор IN полностью определяет множество, которому данное значение может
принадлежать или не принадлежать.

Пример. Определить из таблицы Student фамилии и стипендию студентов, учащихся в
группах с первичными ключами 2 и 3.

>   Вариант с использованием операции OR (“логическое ИЛИ”).

>   SELECT name AS 'Ф.И.О.', stip AS ‘Стипендия’ FROM Student

>   WHERE Id_Groups=2 OR Id_Groups=3

>   Вариант с использованием оператора IN. SELECT name AS 'Ф.И.О.', stip AS
>   ‘Стипендия’

>   FROM Student

>   WHERE Id_Groups IN (2, 3)

Как видно из примера, IN представляет множество, элементы которого точно
перечисляются в круглых скобках и разделяются запятыми. Если значения поля, имя
которого указано слева от IN, есть одно из перечисленных в списке значений
(требуется точное совпадение), то предикат считается истинным. Если элементы
множества имеют символьный тип, то значения в скобках используются в одиночных
кавычках.

SELECT name AS 'Ф.И.О.', stip AS 'Стипендия' FROM Student WHERE name IN
('Иванов', 'Семенов')

Пример. Определить из таблицы фамилии студентов, которые не проживают в городах
Харьков и Чугуев (поле city).

>   SELECT name AS 'Ф.И.О.' FROM Student WHERE city NOT IN ('Харьков', 'Чугуев')

Пример. Использование вложенного подзапроса для формирования элементов
множества.

SELECT \* FROM Table1

>   WHERE x NOT IN (SELECT x FROM Table2)

>   По определению значение предиката x NOT IN (S) , где (S)

некоторое множество, равно значению предиката NOT(x IN (S)).

Оператор BETWEEN (NOT BETWEEN)
==============================

Оператор BETWEEN задает границы, в которые должно попадать значение, чтобы
предикат был истинным.

>   Синтаксис оператора BETWEEN:

\<имя_поля\> [NOT] BETWEEN \<начальное_значение\> AND

\<конечное_значение\>

В качестве начального и конечного значений могут использоваться выражения и
константы.

>   Синтаксис предиката BETWEEN в более общем случае:

\<value_expression\> [NOT] BETWEEN \<low_value_expression\> AND

\<high_value_expression\>

Фактически данный предикат – это сокращенный способ записи следующего выражения:

>   ((\<low_value_expression\> \<= \<value_expression\>) AND
>   (\<value_expression\> \<= \<high_value_expression\>))

>   Особенности оператора BETWEEN:

1.  В отличии от IN, оператор BETWEEN чувствителен к порядку -
    начальное_значение в предложении должно быть первым в соответствии с
    алфавитным или числовым порядком.

Пример. Извлечь из таблицы Student фамилии и средний бал студентов, средний бал
которых находится в диапазоне между 4 и 5.

>   SELECT name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’ FROM Student

>   WHERE sr_ball BETWEEN 4 AND 5

1.  Оператор BETWEEN является включающим, то есть здесь граничные значения (в
    данном примере это 4 и 5) также делают предикат истинным. SQL
    непосредственно не поддерживает исключающий BETWEEN. Необходимо
    сформулировать граничные значения так, чтобы включающая интерпретация была
    справедлива, либо, при необходимости, исключить граничные значения. Это
    можно сделать, например, посредством следующего запроса:

>   SELECT name AS 'Ф.И.О.', sr_ball AS ‘Средний балл’ FROM Student

>   WHERE (sr_ball BETWEEN 4 AND 5)

>   AND Not sr_ball IN (4, 5)

1.  Аналогично всем операторам сравнения BETWEEN действует на символьных полях,
    представленных в двоичном (ASCII) эквиваленте, то есть для выборки можно
    воспользоваться алфавитным порядком. Следующий запрос выбирает всех
    студентов, значения поля “name” которых попадают в заданный алфавитный
    диапазон:

>   SELECT \*

>   FROM Student

>   WHERE name BETWEEN ‘K’ AND ‘R’;

Фамилия Romanov будет пропущена, несмотря на то, что BETWEEN является
включающим, так как он сравнивает строки неравной длины. Строка ‘R’ короче
строки ‘Romanov’, поэтому ‘R’ дополняется пробелами. Пробелы предшествуют
символам латинского алфавита (в большинстве реализаций), поэтому Romanov
оказался невыбранным. Об этом необходимо помнить при использовании BETWEEN с
алфавитными диапазонами.

Для включения в результат выполнения запроса сведений о студентах, фамилии
которых начинаются на ‘R’, нужно указать следующую букву алфавита (‘S’) или
приписать символ ‘z’ (несколько символов ‘z’, если это необходимо) после второго
граничного значения.

Оператор LIKE (NOT LIKE)
========================

>   Синтаксис оператора LIKE:

>   \<имя_поля\> [NOT] LIKE \<образец\> (\<строка\> [NOT] LIKE \<подстрока\>)

Оператор LIKE применим только к строковым полям типа CHAR (NCHAR) или VARCHAR
(NVARCHAR), поскольку он используется для поиска подстрок в предикате
предложения WHERE. Другими словами, он осуществляет просмотр строки для проверки
условия - входит ли заданная подстрока в указанную строку. Для гибкой реализации
этой цели используются шаблоны (маски) − специальные символы, которые
используются для конструирования образца строки.

>   Существуют следующие типы шаблонов, используемых с LIKE:

-   Символ ”подчеркивание” (_) заменяет любой одиночный символ.

>   Например,

-   … LIKE ‘б_т’ - образцу ‘б_т’ соответствует ‘бит’ или ‘бут’, но не
    соответствует ’брат’;

-   … LIKE ‘_ро_’ – любое слово из 4 букв, имеющее в середине две буквы ‘ро’,
    например, ’крот’;

-   … LIKE ‘ ов’ – любое слово из 6 букв, оканчивающее на ‘ов’,

например, ‘Петров’.

-   Символ ” процент” (%) заменяет последовательность символов произвольной
    длины, в том числе и нулевой.

>   Например:

-   … LIKE ‘И%’ – любая строка, начинающаяся с буквы И, например, ‘Иванов’;

-   … LIKE ‘%E%’ – любая строка, содержащая букву E, например, ‘SELECT’;

-   … LIKE ‘%У%Д’ – образцу ‘%У%Д’ соответствуют ‘УБД’, ‘СУБД‘, ‘РСУБД’, но не
    ‘УВДУ’;

-   … LIKE ‘%т_о%’ – истинно для любого слова, содержащего шаблон

‘т_о’, например, ‘Петров’.

Пример. Извлечь из таблицы Student информацию обо всех студентах, фамилии
которых начинаются с буквы И.

>   SELECT \*

>   FROM Student

>   WHERE name LIKE ‘И%’

-   [] – допускается применение в строке любого отдельного символа из указанных
    в скобках (допустимо перечисление без пробелов и других разделителей,
    указание интервала, например, А-С соответствует от А до С).

>   Например:

-   … LIKE ‘[cf]%’ – любая строка, начинающаяся на c или f;

-   … LIKE ‘[s-v]%ing’ – любая строка, начинающаяся на буквы s, t, u, v и
    оканчивающаяся на ing;

-   … LIKE '[JT]im' – любая строка из трех букв, начинающаяся на J или

>   T и оканчивающаяся на 'im', например Jim или Tim.

-   [\^]– любой единичный символ из перечисленных в скобках не должен
    содержаться в строке (допустимо перечисление без пробелов и других
    разделителей, а также указание интервала).

>   Например:

-   … LIKE ‘S[\^f]%’ – любая строка, начинающаяся на S, за которой не следует f.

>   Разрешено использование конструкции NOT LIKE.

Пример. Извлечь из таблицы Student информацию обо всех студентах, фамилии
которых не начинаются с буквы ‘И’.

>   SELECT \* FROM Student WHERE name NOT LIKE ‘И%’

LIKE может оказаться полезным при осуществлении поиска имени или другого
значения, полное написание которого неизвестно. Предположим, не совсем понятно,
как правильно записывается фамилия одного из студентов ‘Коваленко’, ‘Коленко’
или ‘Коваленков’. Можно использовать ту часть, которая известна, и символы
шаблона для нахождения всех возможных вариантов:

>   SELECT \* FROM Student WHERE name LIKE ‘К%к%’

Символ шаблона (%) в конце строки необходим в тех реализациях SQL, в которых
длина поля name превосходит количество букв в имени ‘Коваленко’. В таком случае
значение поля name реально хранится как ‘Коваленко’, а за ним следует ряд
пробелов. Следовательно, символ ‘о’ не является последним в строке. Символ (%) в
шаблоне заменяет все пробелы.

Поиск в строке символов подчеркивания (_) или процента (%), выполняется с
использованием Escape-символа. Escape-символ используется в предикате
непосредственно перед символом (%) или (_) и означает, что следующий за ним
символ интерпретируется как обычный символ, а не как символ шаблона.

В SQL строки могут быть равны, но не совпадать с точки зрения оператора LIKE.
При проверке равенства строк надо более короткую строку справа заполнить
пробелами до длины более длинной. А затем посимвольно сравнивать строки. Таким
образом, строки ‘Иванов’ и ‘Иванов ’ (с тремя пробелами) окажутся равны.
Предикат LIKE пробелов не вставляет, так что выражение ‘Иванов’ LIKE ‘Иванов ’
даст значение false.

Чтобы обойти эту проблему, можно воспользоваться функциями для обработки строк
LTRIM() и RTRIM() (функции TRIM() в MS SQL Server нет), которая удалит ненужные
пробелы слева и справа от одного или обоих аргументов …WHERE RTRIM(name) LIKE
‘Иванов’.

Пример. Составить запрос, который выводит список студентов факультета с именем
“ФРТСЛА”.

Используемый ниже способ решения задачи, основан на правиле создания имен групп,
которое используется в ХАИ. Имя группы состоит из трех цифр и необязательной
одной буквы. Первая цифра – номер факультета, вторая – номер курса и третья –
номер

специальности. Буква используется, если групп на специальности несколько. Таким
образом, группы 1 факультета – 1хх, второго – 2хх, третьего – 3хх и т.д. Если
существует такое правило, то это значит, что его можно использовать для
получения имени группы:

>   SELECT s.name AS 'Ф.И.О. Студента' FROM groups g, student s

>   WHERE g.id=s.id_group AND g.name LIKE '5%'

Однако следующий запрос выполнится неправильно, так как не указано условие связи
поля s.name с полем g.name в таблицах Student и Groups.

SELECT s.name AS 'Ф.И.О. Студента'

>   FROM Groups g, Student s WHERE g.name LIKE '5%'

Причина неправильности предыдущего запроса станет ясной после анализа следующего
запроса.

>   SELECT s.name 'ФИО', g.name 'Группа' FROM Groups g, Student s WHERE g.name
>   LIKE '5%'

Предикат (g.name LIKE '5%') из таблицы groups выберет две записи – с именами
групп ‘535’ и ‘535a’. Оператор SELECT s.name … выберет 4 записи из поля s.name –
‘Иванов‘, ‘Петров‘, … . При соединении в одну таблицу сначала будет выбрано
первое значение из таблицы с меньшим числом записей – это ‘535’, потом к этому
значению присоединятся все записи из таблицы с большим числом записей – это
‘Иванов‘, ‘Петров‘, … . Потом будет выбрана группа ‘535a’ и так далее. Результат
представлен на рисунке выше.

Пример. Пусть столбец содержит данные длиной не более 6 символов, а предикат
LIKE ищет имена, начинающиеся с ‘Ива‘. Для этого обычно можно написать такой
код:

SELECT \* FROM student WHERE name LIKE 'Ива%'

>   Однако этот оператор работает медленнее приводимого ниже

кода:

SELECT \* FROM student

>   WHERE (name='Ива') OR (name LIKE 'Ива_') OR (name LIKE 'Ива ') OR (name LIKE
>   'Ива ')

Завершающие пробелы также представляют собой символы, которые могут иметь точное
соответствие.

Предикат с использованием ...name LIKE '%нов'также будет работать медленнее, чем
предикат вида …WHERE (name LIKE '_нов') OR (name LIKE ' нов') OR (name LIKE '
нов').

Оператор IS NULL (IS NOT NULL)
==============================

Часто в таблице встречаются записи с незаданными значениями какого-либо из
полей, потому что значение поля неизвестно или его просто нет. В таких случаях
SQL позволяет указать в поле NULL- значение.

1.  Когда значение поля есть NULL это значит, что программа БД специальным
    образом помечает поле, как не содержащее какого- либо значения для данной
    строки. Дело обстоит не так в случае простого приписывания полю значения
    ”нуль” или ”пробел”.

2.  Поскольку NULL не является значением как таковым, он не имеет типа данных.

3.  NULL может размещаться в поле любого типа. Тем не менее, NULL-значение часто
    используется в SQL.

>   Для определения неизвестного значения используется оператор

IS с ключевым словом NULL.

Пример. Предположим, в таблице есть поле OCENKA, а экзамена еще не было (или
часть студентов экзамен еще не сдала), значит в этом поле будет находиться
значение NULL до тех пор, пока оценка не станет известна. Определить все записи
таблицы, в которых оценка еще не проставлена.

>   SELECT \* FROM Student WHERE OCENKA IS NULL

Совместно с операторами IS NULL могут быть использованы булевы операторы AND, OR
и NOT.

Пример. Определить все строки таблицы Student, в которых стипендия (stip)
проставлена.

SELECT \* FROM Student

>   WHERE stip is not NULL

Использование выражения CASE
============================

Выражение CASE используется для проверки списка условий и получения одного из
нескольких возможных результатов. Функция CASE имеет два формата вызова:

-   простое выражение CASE применяется для сравнения заданного выражения с
    множеством простых выражений для определения результата,

-   в поисковом выражение CASE для определения результата применяется множество
    булевых (логических) выражений.

>   Синтаксис:

Простое выражение CASE: CASE input_expression

>   WHEN when_expression THEN result_expression [...n ] [ ELSE
>   else_result_expression ]

END

Поисковое выражение CASE: CASE

>   WHEN boolean_expression THEN result_expression [ ...n ] [ ELSE
>   else_result_expression ]

END

>   Аргументы:

>   input_expression

Выражение, полученное при использовании простого формата функции CASE. Аргумент
input_expression представляет собой любое допустимое выражение.

>   WHEN when_expression

Простое выражение, с которым сравнивается аргумент input_expression при
использовании простого формата функции CASE. Аргумент when_expression
представляет собой любое допустимое выражение. Типы данных аргумента
input_expression и каждого из выражений when_expression должны быть одинаковыми
или неявно приводимыми друг к другу.

>   THEN result_expression

Выражение, возвращаемое, если сравнение выражений input_expression и
when_expression дает в результате TRUE или выражение Boolean_expression
вычисляется в TRUE. Аргумент result_expression представляет собой любое
допустимое выражение.

>   ELSE else_result_expression

Это выражение, возвращаемое, если ни одна из операций сравнения не дает в
результате TRUE. Если этот аргумент опущен и ни одна из операций сравнения не
дает в результате TRUE, функция CASE возвращает NULL. Аргумент
else_result_expression представляет собой любое допустимое выражение. Типы
данных аргумента else_result_expression и любого из аргументов result_expression
должны быть одинаковыми или неявно приводимыми друг к другу.

>   WHEN Boolean_expression

Это логическое выражение, полученное при использовании поискового формата
функции CASE. Аргумент Boolean_expression представляет собой любое допустимое
логическое выражение.

Выражение CASE может использоваться в любой инструкции или предложении, которые
допускают допустимые выражения. Например, выражение CASE можно использовать в
таких инструкциях, как SELECT, UPDATE, DELETE и SET, а также в таких
предложениях, как IN, WHERE, ORDER BY и HAVING.

Пример оператора SELECT с простым выражением CASE SELECT fam 'ФИО', 'Оценка по
математике' =

>   CASE math

>   WHEN 5 THEN 'отлично' WHEN 4 THEN 'хорошо'

>   WHEN 3 THEN 'удовлетворительно' WHEN 2 THEN 'неудовлетворительно' ELSE
>   'неизвестно'

>   END

FROM Table_1

Пример работы оператора SELECT с поисковым выражением CASE

>   SELECT fam 'ФИО', 'Оценка по математике' = CASE

>   WHEN math=5 THEN 'отлично' WHEN math=4 THEN 'хорошо'

>   WHEN math=3 THEN 'удовлетворительно' WHEN math=2 THEN 'неудовлетворительно'
>   ELSE 'неизвестно'

>   END

FROM Table_1

>   Контрольные вопросы

1.  Каковы основные особенности использования предложения

WHERE?

1.  Каковы особенности использования оператора BETWEEN?

2.  Каковы особенности использования оператора IN?

3.  Каковы особенности использования оператора IS NULL?

4.  Каковы особенности использования оператора LIKE?

5.  Каковы особенности использования простого выражения

CASE?

1.  Каковы особенности использования поискового выражения

CASE?

Лекция 8. Группировка и сортировка полей в операторе
====================================================

SELECT
======

1.  **Предложения GROUP BY и HAVING**

Пример. Необходимо решить следующую задачу: пусть в таблице Student содержится
средний бал студентов (поле sr_ball), а имя группы (поле name) – в таблице
Groups. Как получить средний бал группы?

Оператор, который начинает решать эту задачу будет выглядеть следующим обрарзом:

>   SELECT g.name AS 'Группа', s.sr_ball AS 'Средний балл' FROM Groups g,
>   Student s

>   WHERE g.id = s.id_groups

Рассмотрим последовательно, работу этого оператора. Пусть существуют вот такие
данные в таблицах:

При выполнении данного SQL-оператора SELECT будут склеены поля name таблицы
Groups и sr_ball таблицы Student и получен следующий результат:

| Группа              | Средний балл |
|---------------------|--------------|
| 535 3,45 535 4,24   |              |
| 535a 4,76 535a 4,33 |              |

Можно заметить, что одни и те же значение поля name таблицы Groups многократно
повторяются, представляя таким образом возможность для группирования данных.
Внутри промежуточной таблицы появляются группы данных (они выделены жирными
линиями), объединенные именем группы. Это позволяет произвести над значениями
поля sr_ball, которое не является условием группировки, определенные
арифметические действия, результатом которых является одна строка. К таким
арифметическим действиям относятся операции вычисления количества записей, суммы
значений, среднего арифметического, минимума, максимума и т.д. Функция AVG
считает среднее арифметическое и результат работы SQL-оператора SELECT будет вот
таким:

| Группа | Средний балл |
|--------|--------------|
| 535    | 3,845        |
| 535а   | 4,545        |

>   Оператор, который решает эту задачу будет выглядеть так: SELECT g.name AS
>   'Группа', AVG(s.sr_ball) AS 'Средний балл'

>   FROM Groups g, Student s WHERE g.id = s.id_groups GROUP BY g.name

Предложение GROUP BY SQL-оператора SELECT представляет механизм группировки
полей по определенному условию. Предложение GROUP BY позволяет определять
подмножество значений отдельного поля (s.sr_ball) в терминах другого поля
(g.name) и применять функции агрегирования к полученному подмножеству. Это дает
возможность комбинировать поля и агрегатные функции в одном предложении SELECT.

Пример. Пусть есть таблица Usp (Id, Num - номер зачетки, Ocenka - оценка, Id_Sub
- код предмета, Date - дата). Определить наименьшую оценку, полученную каждым
студентом. (Интересует подмножество оценок по номерам зачеток, а потом к этому
подмножеству оценок применяется функция MIN().)

>   SELECT Num, MIN(Ocenka)

>   FROM Usp GROUP BY Num;

>   Вывод для этого запроса имеет следующий вид:

| Num  |   |
|------|---|
| 3126 | 4 |
| 3124 | 5 |
| 3125 | 3 |
| 3123 | 4 |

Если требуется задать несколько полей, по которым выполняется группировка, то:

1.  они должны быть обязательно заданы в предложении

SELECT,

1.  они должны быть перечислены через запятую в предложении

GROUP BY,

1.  при этом остальные поля предложения SELECT, которые не участвуют в
    группировке, обязательно должны быть заданы в качестве параметров агрегатных
    функций.

Если заданное в предложении SELECT поле не является частью условия группировки и
параметром агрегатной функции, то такой оператор считается ошибочным и не
выполняется.

Пример. Пусть есть таблица Usp. Определить наименьшую оценку, полученную каждым
студентом за каждый день.

>   SELECT Num, Date, MIN(Ocenka) FROM Usp

>   GROUP BY Num, Date;

При работе с предложением GROUP BY сталкиваются с определенными сложностями.
Основной ошибкой является неверное выделение поля или полей группировки. Чтобы
правильно их выделить нужно мысленно выполнить первых две фазы оператора SELECT:
склеивания полей и обработку условия WHERE.

Если предложение GROUP BY не задано, то автоматически производится группировка
по всем полям, перечисленным в предложении SELECT. Это дает возможность
выполнить агрегатные функции, над всем содержимым оператора SELECT таким
образом, что каждая запись представляет единственную группу. Это бывает полезно
в тех случаях, когда требуется, например, посчитать общее число записей в
таблице.

>   SELECT COUNT(\*) FROM Student;

COUNT(\*) включает записи с NULL-значениями, а также дубликаты, по этой причине
DISTINCT в данном случае не может быть использован.

Предложение HAVING
==================

Пример. Пусть есть таблица Usp (Id, Num, Ocenka, Id_Sub, Date). Определить
наименьшую оценку, полученную каждым студентом, выделить двоечников и
троечников.

>   SELECT Num, MIN(Ocenka) FROM Usp

>   GROUP BY Num

>   HAVING MIN(Ocenka)\<4 (или HAVING MIN(Ocenka) IN (3, 2))

>   Предложен

1.  задае предложением GROUP BY;

нутри группы, которая была получена

1.  должно ссылаться только на агрегатные функции и поля, выбранные в GROUP BY.

2.  HAVING может иметь только такие аргументы, у которых единственное значение
    для группы выходных данных.

3.  для задания условий используются те же операции, что и в предложении WHERE.
    (Отличие состоит в том, что предложение WHERE выполняется перед группировкой
    и, следовательно, с ее помощью невозможно задать условие, которое использует
    результаты группировки. Кроме того, в предложение WHERE нельзя использовать
    агрегатные функции, потому что предикаты оцениваются в терминах одиночной
    строки, а агрегатные функции – групп строк.)

Пример. Получить средний бал групп, причем выводить список только тех групп, у
которых средний балл выше 4,5.

Такое задание требует группировки и затем отсеивания некоторого количества
результатов после ее выполнения:

>   SELECT g.name AS 'Группа', AVG(s.sr_ball) AS 'Средний балл' FROM Groups g,
>   Student s

>   WHERE g.id = s.id_group

>   GROUP BY g.name HAVING AVG(s.sr_ball) \> 4,5

>   В остальном способ задания и работа предложения HAVING

>   ничем не отличается от предложения WHERE.

Предложение ORDER BY
====================

SQL-оператор SELECT автоматически не выполняет сортировки данных. В
SQL-операторе SELECT существует расположенное последним предложение ORDER BY,
которое позволяет задать набор полей и порядок их сортировки.

>   Синтаксис предложения ORDER BY:

>   ORDER BY имя_поля1[ ASC \| DESC][, имя_поля2[ ASC \| DESC], ...]

(to ascend – подниматься, восходить, to descend – спускаться, сходить)

>   Особенности предложения ORDER BY:

1.  Параметр “имя_поля” задает поле предложения SELECT,

по которому выполняется сортировка.

1.  Поля, по которым происходит упорядочивание, должны быть указаны в
    предложении SELECT.

2.  Ключевые слова ASC (по возрастанию) и DESC (по убыванию) определяют порядок
    (направление) сортировки. По умолчанию сортировка выполняется по возрастанию
    (ASC). Одновременно ASC и DESC заданы быть не могут.

3.  Если требуется сортировка не по одному, а по несколько полям, то они
    перечисляются через запятую. Причем для каждого поля можно задать
    направление сортировки.

4.  Если задано несколько полей, то поле, которое идет вначале, обладает
    преимуществом перед полем, которое задано после него.

5.  Имена полей при сортировке можно задавать одним из двух способов: - именами
    столбцов, - номерами столбцов.

Пример. Вывести список студентов отсортированный по возрастанию имен.

>   SELECT name AS 'Ф.И.О.' FROM Student ORDER BY name ASC

>   В данном случае ASC можно не указывать.

Пример. Информацию из таблицы с данными о студентах упорядочить по уменьшению
размера стипендии (поле Stip), а для студентов, имеющих одинаковый ее размер – в
алфавитном порядке их фамилий (поле Name).

>   SELECT \* FROM Student ORDER BY Stip DESC, Name ASC;

Для указания полей, по которым упорядочиваются выходные данные, можно
использовать их порядковые номера – номера столбцов в определении выходных
данных оператора SELECT (а не столбцов в базовой таблице). То есть первое поле,
имя которого указано в SELECT, является для предложения ORDER BY полем с номером
1, независимо от его расположения в базовой таблице.

Пример. Вывести список студентов отсортированный по именам. SELECT name AS
'Ф.И.О.', stip AS ‘Стипендия’ FROM Student ORDER BY 1 ASC

Если в поле, которое используется для упорядочения выходных данных, существуют
NULL-значения, то все они следуют в конце или предшествуют всем остальным
значениям этого поля. Конкретный вариант не оговаривается стандартом ANSI.

ORDER BY может использоваться с GROUP BY для упорядочения групп. ORDER BY всегда
выполняется последней.

Пример. Пусть есть таблица Usp (Id, Num, Ocenka, Id_Sub, Date). Определить
наименьшую оценку, полученную каждым студентом, отсортировать по номерам
зачеток.

>   SELECT Num, MIN(Ocenka) FROM Usp

>   GROUP BY Num ORDER BY Num;

>   Вывод для этого запроса имеет следующий вид:

>   До этого ные были сгруппированы, но порядок

групп был произвольным; теперь группы выстроены в определенной
последовательности. Поскольку в команде ORDER BY не указан способ упорядочения,
по умолчанию применяется возрастающий (ASC).

Порядок выполнения предложений SQL-оператора SELECT
===================================================

![](media/551a3399da6c8e3f88b0f76f1a17092b.png)

![](media/e4bfaa9bc49c8b6870c73c4c36da8691.png)

Понимание порядка обработки данных в SQL-операторе SELECT значительно упрощает
его использование. Предложения всегда выполняются в том порядке, в котором они
были заданы при описании оператора SELECT (рисунок 8.1). Именно поэтому у
пользователя есть возможность пропустить некоторые предложения, если они не
нужны, но он не имеет права изменять порядок их определения.

>   Select Wher Group by Having Order by

>   N – число столбцов в базовой таблице, K\<=N,

>   p – число строк в базовой таблице, p’\<=p (за счет Distinct), m\<=p’,
>   m’\<=m,

>   Рисунок 8.1 − Схема выполнения предложений SQL-оператора SELECT

Первым выполняется предложение SELECT, которое выбирает из таблицы значения всех
полей таблиц, и формирует из них промежуточную таблицу в 1НФ. Существование
DISTINCT влияет на содержимое этой таблицы, удаляя повторяющиеся записи.

>   Затем промежуточная таблица поступает в предложение

>   WHERE, где просеивается сквозь условия.

Далее промежуточная таблица попадает в предложение GROUP BY, где выявляются
группы и производятся заданные над ними действия. После этого результат
поступает в предложение HAVING, которое может своим условием отсечь еще часть
данных.

После этого результат сортируется согласно определениям предложения ORDER BY и
поступает к пользователю.

Отсутствие одного из предложений WHERE, HAVING или ORDER BY приводит к пропуску
данного этапа, что ускоряет обработку запроса пользователя. В SQL-операторе
SELECT всегда выполняется группировка данных. Если предложение GROUP BY не
заданно, то группировка автоматически проводится по всем полям.

>   Контрольные вопросы

BY?

BY?

1.  Каковы особенности использования предложения GROUP

2.  Каковы особенности использования предложения HAVING?

3.  Каковы особенности использования предложения ORDER

4.  Каков порядок выполнения предложений SQL-оператора

SELECT?

>   Лабораторная работа 4

Создание запросов к нескольким таблицам базы данных
===================================================

>   Постановка задачи:

На основании таблиц физической модели данных, бизнес-правил предметной области и
скриптов создания таблиц БД создать:

1.  Создать оператор SELECT, объединяющий две и более таблицы с простым
    условием.

2.  Создать оператор SELECT, который связывает две и более таблицы с более
    сложным условием.

3.  Создать оператор SELECT, который использует агрегатные функции и содержит
    группировку (GROUP BY и HAVING).

4.  Создать оператор SELECT с использованием объединения нескольких запросов
    вместе (UNION).

5.  Создать оператор SELECT, который реализует самосоединение.

6.  Создать операторы SELECT, реализующие внешнее объединение таблиц (левое,
    правое и полное).

7.  Создать оператор SELECT с использованием вложенных подзапросов.

Для создания указанных скриптов и запросов использовать команды языка
манипулирования данными DML.

>   Письменный отчет по лабораторной работе должен содержать:

1.  Титульный лист, содержащий – название лабораторной работы, фамилию, имя,
    отчество, номер группы исполнителя, дату сдачи.

2.  Диаграмму БД.

3.  Заполненные таблицы БД.

4.  SQL-операторы SELECT для работы с БД.

5.  Привести примеры работы основных операторов в соответствии с постановкой
    задачи (в виде − оператор + результат его работы).

6.  Выводы по лабораторной работе (в выводах отразить особенности занесения и
    модификации информации в БД, SQL- операторов SELECT и пути дальнейшей
    модернизации БД).

>   Контрольные вопросы и задания

1.  К каким языкам относится язык SQL?

2.  Какие формы языка SQL существуют?

3.  Каковы компоненты языка SQL?

4.  Каковы основные предложения компонент языка SQL?

5.  Каков синтаксис оператора SELECT?

6.  Каковы основные особенности использования предложения

SELECT?

1.  Каковы основные особенности использования предложения

FROM?

1.  Каковы основные особенности использования предложения

WHERE?

1.  Каковы особенности использования предложений GROUP BY и

HAVING?

1.  Каковы основные особенности использования предложения ORDER BY?

2.  Каковы особенности использования операторов BETWEEN, IN, IS NULL, LIKE?

3.  Как осуществляется внутреннее объединение таблиц в

SQL?

1.  Как осуществляется самосоединение таблиц в SQL?

2.  Как осуществляется внешнее объединение таблиц в SQL?

3.  Каковы основные правила работы с псевдонимами в SQL?

>   Лекция 9. **Вложенные запросы**

Вложенные запросы
=================

Подзапрос (вложенный запрос) — это запрос, содержащийся в выражении предложения
WHERE или HAVING другого запроса с

целью определения дополнительных ограничений на выводимые данные. Подзапрос в
содержащем его запросе используют для наложения условий на выводимые данные.
Подзапросы могут использоваться с операторами SELECT, INSERT, UPDATE или DELETE.

Подзапросы используются для размещения в запросах условий, точные данные для
которых неизвестны, тем самым расширяя возможности и гибкость SQL.

Чтобы оценить внешний запрос, SQL сначала должен оценить вложенный запрос внутри
предложения WHERE.

Пример. Пусть существует таблица USP (Id, Id_Stud, Ocenka, Id_Sub, Date),
известна фамилия студента («Петров»), но неизвестно значение поля Id_Stud
(внешний ключ таблицы USP) для него. Чтобы извлечь данные обо всех оценках этого
студента, можно записать следующий запрос:

SELECT \* FROM Usp WHERE

>   Id_Stud = (SELECT Id FROM Student WHERE Name = 'Петров')

>   Как работает запрос SQL со связанным подзапросом?

-   Выбирается строка из таблицы USP, имя которой указано во внешнем запросе.

-   Выполняется подзапрос и полученное значение применяется для анализа этой
    строки в условии предложения WHERE внешнего запроса.

-   По результату оценки этого условия принимается решение о включении или
    невключении строки в состав выходных данных.

-   Процедура повторяется для следующей строки таблицы внешнего запроса.

Приведенный выше запрос корректен только в том случае, если в результате
выполнения указанного в скобках подзапроса возвращается единственное значение.
Если в результате выполнения подзапроса будет возвращено несколько значений, то
этот подзапрос будет ошибочным. В данном примере это произойдет, если в таблице
STUDENT будет несколько записей со значениями поля Name = 'Петров'.

Таким образом, необходимо чтобы для операторов отношения (\>, \<, \>=, \<=, \<
\>) подзапрос возвращал одно и только одно значение. Если в результате
выполнения подзапроса получается несколько значений, то это делает невозможной
оценку предиката основного запроса на предмет истинности или ложности, что
приводит к оценке запроса как ошибочного.

В некоторых случаях для гарантии получения единственного значения в результате
выполнения подзапроса используется DISTINCT.

>   Правила при составлении подзапросов:

-   Подзапрос необходимо заключить в круглые скобки.

-   Подзапрос может ссылаться только на один столбец в выражении своего
    ключевого слова SELECT, за исключением случаев, когда в главном запросе
    используется сравнение с несколькими столбцами из подзапроса.

-   Предложение ORDER BY нельзя использовать в подзапросе. В подзапросе можно
    использовать GROUP BY.

-   Подзапрос, возвращающий несколько строк данных, можно использовать только в
    операторах, допускающих множество значений, например в IN.

-   В списке ключевого слова SELECT не допускаются ссылки на значения типа BLOB,
    ARRAY, CLOB или NCLOB.

-   Подзапрос нельзя непосредственно использовать как аргумент допускающий
    множество значений функции.

-   Операцию BETWEEN по отношению к подзапросу использовать нельзя, но ее можно
    использовать в самом подзапросе.

Предикаты с подзапросами являются необратимыми, то есть условия, включающие
подзапросы, используют конструкцию следующего вида:

>   \<выражение\> \<оператор\> \<подзапрос\>,

и не в коем случае не \<подзапрос\> \<оператор\> \<выражение\>, или

\<подзапрос\> \<оператор\> \<подзапрос\>.

\- Оператор IN (в отличии от операторов BETWEEN, LIKE, IS NULL) широко
применяется в подзапросах. IN определяет набор значений, которые тестируются на
совпадения с другими значениями для определения истинности предиката. Когда
используется IN с подзапросом, SQL просто формирует этот набор из вывода
подзапроса.

>   Пример. Выбрать данные обо всех оценках (таблица USP)

>   студентов из Харькова: SELECT \* FROM Usp

>   WHERE Id_Stud IN

>   (SELECT Id

>   FROM Student

>   WHERE City = ' Харьков')

-   В любой ситуации, когда применяется оператор равенства (=), предпочтительнее
    использовать IN. В отличии от запроса с оператором равенства (=), IN не
    может заставить запрос потерпеть неудачу, если подзапросом выбрано больше
    чем одно значение.

-   Команда SELECT \* **…** не может использоваться в подзапросе.

-   Одним из видов функций, которые автоматически всегда выдают в результате
    единственное значение для любого количества строк, являются агрегатные
    функции.

Пример. Выбрать данные обо всех оценках студентов, значения которых выше средней
оценки (это запрос со связанным подзапросом):

SELECT \* FROM Usp

>   WHERE Ocenka \> (SELECT AVG(Ocenka) FROM Usp)

-   Подзапросы можно применять при использовании предложения

GROUP BY внутри предложения HAVING.

Пример. Требуется определить количество предметов обучения, сданных студентами с
оценкой, превышающей среднее значение оценки студента с номером внешнего ключа
301 (запрос со связанным подзапросом):

SELECT COUNT(DISTINCT Id_Sub), Ocenka FROM Usp

>   GROUP BY Ocenka

>   HAVING Ocenka \> (SELECT AVG(Ocenka )

>   FROM Usp

>   WHERE Id_Stud = 301);

Иной вариант решения задачи

SELECT COUNT(DISTINCT Id_Sub), Ocenka FROM Usp

>   WHERE Ocenka \> (SELECT AVG( Ocenka )

>   FROM Usp

>   WHERE Id_Stud = 301)

>   GROUP BY OCENKA

Формирование связанных подзапросов
==================================

Связанный (соотнесенный, коррелированный) подзапрос — это подзапрос, зависящий
от информации, предоставляемой главным запросом.

Когда в SQL используются подзапросы, во внутреннем запросе можно ссылаться на
таблицу, имя которой указано в предложении FROM внешнего запроса, тем самым
формируя связанный подзапрос (или соотнесенный подзапрос - correlated subquery).
В этом случае подзапрос выполняется повторно, по одному разу для каждой строки
таблицы из основного запроса. Связанные подзапросы относятся, из- за сложности
их оценок, к числу наиболее тонких понятий в SQL. Однако, связанные подзапросы –
весьма мощное средство, выполняющее очень сложные функции при достаточно
компактных командах.

![](media/76dfd0f379bec5375f9c2f1e0b820ce3.png)

Пример. Выбрать сведения обо всех предметах обучения, по которым проводился
экзамен 20 января 2010 г. В таблице USP есть сведения об оценках и датах
экзаменов, в таблице LESSON – сведения обо всех занятиях и экзаменах.

![](media/1c454bd9c38d2e315bcbd8e2aba7ab6b.png)

SELECT \* FROM Lesson LE

>   WHERE '20/01/2010' =

>   (SELECT Date FROM Usp

>   WHERE LE.Id\_ Sub = Usp.Id_Sub)

>   Процедура, выполняемая связанным запросом:

-   выбор текущей строки из таблицы LESSON во внешнем запросе,

-   сохранение значения текущей строки в псевдониме LE,

определенном во FROM внешнего запроса,

-   выполнение подзапроса, при этом везде, где найден псевдоним из внешнего
    запроса, используется значение из текущей строки (это называют внешней
    ссылкой),

-   оценка предиката внешнего запроса на основе результатов подзапроса,

-   описанная выше последовательность повторяется для следующей строки из
    таблицы внешнего запроса, и так до тех пор, пока все строки из таблицы
    LESSON не будут проверены.

В некоторых СУБД для выполнения этого запроса может потребоваться преобразование
значения даты в символьный тип.

Эту же задачу можно решить с помощью операции объединения таблиц.

Можно использовать подзапросы, связывающие таблицу со своей собственной копией.

Пример. Найти все оценки по дисциплинам со значениями, выше средней по этим же
дисциплинам.

SELECT \* FROM Usp U1

>   WHERE Ocenka \> (SELECT AVG(Ocenka)

>   FROM USP U2

>   WHERE U2. ID_Sub = U1. ID_Sub)

Следует иметь в виду, что реальное время выполнения запроса в большой степени
зависит от оптимизатора запросов конкретной СУБД.

Предложение GROUP BY позволяет группировать выводимые запросом записи по
значению некоторого поля. Использование предложения HAVING позволяет при выводе
осуществлять фильтрацию таких групп.

Предикат предложения HAVING оценивается не для каждой строки результата, а для
каждой группы выходных записей, сформированной предложением GROUP BY внешнего
запроса.

Пример. Необходимо по данным из таблицы USP (Id, Id_Stud, Ocenka, Id_Sub, Date -
дата экзамена) определить сумму полученных студентами оценок (поле OCENKA),
сгруппировав значения оценок по датам экзаменов (DATE) и исключив те дни, когда
число студентов, сдававших в течение дня экзамены, было меньше 10.

>   SELECT Date, SUM(Ocenka) FROM Usp U1 GROUP BY Date

>   HAVING 10 \< (SELECT COUNT(Ocenka)

>   FROM Usp U2

>   WHERE U1. Date = U2. Date)

Подзапрос вычисляет количество строк с одной и той же датой, совпадающей с
датой, для которой сформирована очередная группа основного запроса.

Связанные подзапросы по своей сути близки к соединениям (JOIN) – обе конструкции
включают проверку каждой записи одной таблицы с каждой записью другой или с
псевдонимом из той же таблицы, при этом большинство операций у них похожи.

>   Контрольные вопросы

1.  Определение подзапроса.

2.  Основные правила при составлении подзапросов?

3.  Определение и особенности работы со связанным подзапросом.

>   Лекция 10. **Формирование многотабличных запросов**

Современные БД обычно являются нормализованными – данные распределяются по
многочисленным небольшим таблицам в целях устранения повторяющихся данных,
сокращения объема занимаемой памяти, повышения производительности и обеспечения
целостности данных. Однако практически всегда требуется извлекать данные из
нескольких таблиц. Объединение (соединение, многотабличный запрос) полностью
предназначено для обеспечения выборки данных из нескольких таблиц и включения
этих данных в один результирующих набор.

Одна из наиболее важных черт запросов SQL состоит в их способности определять
связи между множеством таблиц и отображать содержащуюся в них информацию в
терминах этих связей. Операция такого рода называется объединением (соединением)
и является одной из самых мощных операцией для реляционных БД. С помощью
соединений непосредственно связывается информация, содержащаяся:

-   в нескольких таблицах,

-   между отдельными частями одной таблицы.

В многотабличном запросе при операции объединения в предложении FROM имена
таблиц перечисляются через запятую.

>   Объединение таблиц может быть выполнено тремя способами:

-   с использованием предложения UNION (объединение, союз),

-   с помощью установления связей между таблицами в предикате запроса (в
    условии, организованном предложением WHERE),

-   с помощью оператора объединения JOIN.

Второй способ объединения таблиц называется внутренним объединением
(соединением), которое возвращает только те строки, для которых условие
объединения принимает значение True. Таблицы, участвующие во внутреннем
объединении, равноправны.

С помощью конструкции Join реализуется внутреннее и внешнее объединения.

Предложение UNION
=================

>   Предложение UNION используется для:

-   размещения нескольких запросов вместе,

-   объединения их вывода.

Предложение UNION объединяет вывод двух или более запросов в единый набор строк
и столбцов.

Пример. Получить список всех студентов и преподавателей, фамилии которых
заключены между буквами ‘K’ и ‘C’.

>   SELECT SFAM AS ‘Фамилия’, SIMA AS ‘Имя’ FROM STUDENT

>   WHERE SFAM BETWEEN ‘K’ AND ‘C’ UNION

>   SELECT TFAM, TIMA FROM TEARCHER

>   WHERE TFAM BETWEEN ‘K’ AND ‘C’

>   Особенности вывода:

1.  в MS SQL Server заголовок столбцов формируется первым запросом,

2.  при объединении столбцы должны быть совместимы для объединения, то есть
    необходимость включения в запросе одинакового числа столбцов в одинаковом
    порядке, должна присутствовать совместимость типов, если пустые значения
    NULL запрещены в каком-либо столбце объединения, то они должны быть
    запрещены и во всех остальных столбцах,

3.  предложение UNION автоматически исключает дубликаты строк из вывода,

4.  можно вставлять константы и выражения в предложение UNION (должна быть
    совместимость констант и выражений)

>   SELECT ‘Студент ’ AS ‘Таблица’, SFAM AS ‘Фамилия’, SIMA AS ‘Имя’ FROM
>   STUDENT

>   UNION

>   SELECT ‘Преподаватель’, TFAM, TIMA FROM TEARCHER

Если не будет псевдонима у ‘Студент ’, то SQL Server присвоит этому столбцу имя
No column name.

1.  предложение ORDER BY применяется и для упорядочения выходных данных
    объединения. Задание упорядочения осуществляется по номеру столбца.

>   SELECT ‘Студент ’, SFAM, SIMA FROM STUDENT UNION

>   SELECT ‘Преподаватель’, TFAM, TIMA FROM TEARCHER ORDER BY 2 ASC

В данном примере выполнено упорядочивание по возрастанию по значениям полей SFAM
и TFAM.

Можно упорядочить выходные данные в соответствии со значениями одного или
нескольких полей: для каждого из полей независимо по возрастанию или убыванию
(ASC или DESC), как это делалось для выходных данных одного запроса. Число 2 в
предложении ORDER BY задаёт номер столбца в упорядоченном списке предложения
SELECT.

1.  Если объединение выполняется более чем для двух запросов, то для
    упорядочения вычислений нужно использовать круглые скобки (круглые скобки
    могут определять порядок устранения дубликат).

>   Иначе говоря, вместо того, чтобы задать query X UNION query Y UNION query Z;
>   необходимо конкретизировать

>   либо (query X UNION query Y) UNION query Z;

>   либо query X UNION (query Y UNION query Z);

Это необходимо, потому что UNION и UNION ALL можно комбинировать для исключения
одних дубликатов без устранения других. Предложение

>   (query X UNION ALL query Y) UNION query Z;

не обязательно генерирует те же выходные данные, что и предложение

query X UNION ALL (query Y UNION query Z); если имеются дубликаты строк,
подлежащие исключению из выходных данных.

Внутреннее объединение таблиц
=============================

1.  Объединение двух таблиц с помощью установления связей. Пример. Выбрать из
    таблиц Teacher (id (код_преподавателя -

первичный ключ), name (имя_преподавателя), id_dep (код_кафедры)) и Subject (id
(код_предмета), name (имя_предмета), id_Teach (код_преподавателя - внешний
ключ)) информацию о преподавателях (ФИО) и дисциплинах (Предмет), которые
преподаватель ведет.

>   SELECT T. Name AS ‘ФИО’, S. Name AS ‘Предмет’ FROM Teacher T, Subject S

>   WHERE T.id=S.id_Teach

Пусть id – первичный ключ таблицы предка Teacher, а id_Teach – внешний ключ
таблицы потомка Subject. Между таблицами Teacher и Subject используется связь
между полями id и id_Teach. Такое объединение таблиц называется объединением
посредством отношения предок /потомок. В этом случае между таблицами создается
отношение ”один-ко-многим”.

SQL не требует, чтобы связываемые столбцы двух (или более) таблиц обязательно
представляли собой пару “первичный ключ – внешний ключ”. Любые два столбца из
двух таблиц могут быть связанными столбцами, если только они имеют сравнимые
типы данных. Такие столбцы создают между таблицами отношение ”многие-ко-многим”.

При выполнении многотабличного запроса SQL исследует каждую комбинацию строк
двух или более возможных таблиц и проверяет эти комбинации по их предикатам.
Если комбинация значений строк дает такое значение, которое делает предикат
истинным, то из комбинации этих строк будут выбраны значения для вывода.

Объединение, использующее предикаты, основанные на равенствах, называется
эквиобъединением (объединением по равенству). Эквиобъединения являются,
по-видимому, наиболее распространенным типом объединения, но существуют и
другие. Фактически в объединении можно использовать любой оператор сравнения.

1.  Объединение трёх таблиц.

Пример. Вывести список оценок, выставленных тем или иным преподавателем в виде
таблицы с полями (ФИО, Предмет, Оценка). Пусть существуют таблицы Teacher (id
(код_преподавателя), Name (имя_преподавателя), id_dep (код_кафедры)), Subject
(id (код_предмета), Name (имя_предмета), id_Teach (код_преподавателя)) и Usp
(id, Num (зачетка), Ocenka (оценка), id_Pred (код_предмета), Date).

SELECT T. Name AS ‘ФИО’, S. Name AS ‘Предмет’, U. Ocenka AS ‘Оценка’

>   FROM Teacher T, Subject S, Usp U

>   WHERE T.id=S.id_Teach AND S.id= U.id_Pred

Здесь выполнен запрос, объединяющий три таблицы – Teacher, Subject и Usp.

Таким образом, объединение позволяет сделать сложные сравнения между любыми
полями любого числа таблиц и использовать полученные результаты для того, чтобы
решать – какую информацию хотелось бы видеть.

1.  Объединение двух (или более) копий одиночной таблицы

(самосоединение, тета-соединение или рефлексивное соединение)

Объединение таблицы с ее же копией означает следующее – любую строку таблицы
(одну в каждый момент времени) можно комбинировать с ее копией и с любой другой
строкой этой же таблицы. Каждая такая комбинация оценивается в терминах
предиката, как и в случае соединения нескольких различных таблиц. Это позволяет
легко создавать определенные виды связей между различными записями внутри
единственной таблицы – например, осуществлять поиск пар строк с общим значением
поля.

Объединение таблицы со своей копией можно представить себе следующим образом –
реально копия таблицы не создаётся, но SQL выполняет команду так, как будто бы
делалось именно это. Данный тип объединения не отличается от обычного соединения
двух таблиц, за исключением того, что в данном случае таблицы идентичны.

При объединении таблицы со своей копией для ссылки к столбцам необходимо иметь
два различных имени для одной и той же таблицы, что делается с помощью временных
имен – псевдонимов, определяемых в предложении FROM.

Пример. Определить студентов, имеющих одинаковые стипендии.

>   SELECT First. Name, Second. Name, First. Stip FROM Student First, Student
>   Second WHERE First. Stip = Second. Stip

Результат такого запроса будет иметь вид:

| Name   | Name   | Stip |
|--------|--------|------|
| Серов  | Серов  | 500  |
| Серов  | Иванов | 500  |
| …      | …      | ...  |
| Иванов | Серов  | 500  |
| Иванов | Иванов | 500  |

В данном примере SQL ведет себя так, как если бы он соединял две различные
таблицы с именами First и Second, то есть псевдонимы разрешают одной и той же
таблице быть обработанной независимо.

Логика этого запроса такова – из таблицы Student выбирается очередная строка и
запоминается под первым псевдонимом. После этого SQL начнет проверять ее в
комбинации с каждой строкой таблицы Student под вторым псевдонимом. Если
комбинация строк удовлетворяет предикату, то соответствующие поля из нее
выбираются для вывода.

>   Особенности работы с псевдонимами:

-   псевдонимы могут использоваться в предложении SELECT до их объявления в
    предложении FROM,

-   псевдонимы таблиц могут совпадать с именами таблиц,

-   допускается использование любого числа псевдонимов для одной таблицы в
    запросе (хотя более двух псевдонимов в запросе – излишество),

-   SQL отклонит запрос, если используемые псевдонимы далее не будут определены
    в предложении FROM,

-   в предложении SELECT допускается не использовать каждый псевдоним или
    таблицу, которые упоминались в предложении FROM запроса,

-   в одном запросе нельзя смешивать использование написания имен таблиц и
    псевдонимов,

-   псевдоним существует только во время выполнения команды, а после завершения
    запроса псевдонимы запроса больше не имеют никакого значения,

-   псевдонимы используются для упрощения записи при длинных и сложных именах
    таблиц и для минимизации синтаксических ошибок.

Недостаток данного запроса – вывод имеет два значения для каждой комбинации
фамилий, причем второй раз в обратном порядке

– это связано с тем, что текущее значение в первом псевдониме сначала выбирается
в комбинации со значением во втором псевдониме, а затем наоборот, кроме того
каждая строка сравнена сама с собой – например, Серов с Серовым.

Способ устранения данного недостатка – наложение условия порядка на два значения
так, чтобы одно значение могло быть меньше второго или предшествовало ему в
алфавитном порядке. Это сделает предикат ассиметричным относительно связи,
поэтому те же самые значения в обратном порядке не будут выбраны снова.

Поэтому предыдущий запрос нужно модифицировать таким образом:

>   SELECT First. Name, Second. Name, First. Stip FROM Student First, Student
>   Second WHERE First.Stip=Second. Stip

>   AND First. Name \< Second. Name

>   Результат такого запроса имеет вид:

| …      | …     | …   |
|--------|-------|-----|
| Иванов | Серов | 100 |
| …      | …     | …   |

В частности, Иванов предшествует Серову в алфавитном порядке, поэтому комбинация
удовлетворяет обоим условиям и появляется в выводе. Для комбинации “Серов –
Иванов”, как и для – “Серов – Серов” второе условие запроса не выполняется. Если
же есть необходимость оставить в выводе запроса комбинацию вида “Серов – Серов”,
то в запросе следует использовать сравнение вида

\<= вместо \<.

В SQL разрешается создание объединения, которое включает псевдонимы одиночной
таблицы и различные таблицы.

Таким образом, операция объединения соединяет информацию из двух (или более)
таблиц (одинаковых или разных), формируя пары

связанных строк из них. Объединенную таблицу образуют пары тех строк из
различных таблиц, у которых в связанных столбцах содержатся одинаковые значения.

Конструкция Join
================

С помощью конструкции Join реализуется внутреннее (Inner Join или просто Join) и
внешнее (Left \| Right \| Full Outer \| Cross Join) объединения.

Внешнее объединение возвращает все строки из одной таблицы (главной) и только те
строки из другой таблицы (подчиненной), для которых условие объединения
принимает значение True. Строки второй таблицы, не удовлетворяющие условию
объединения (то есть имеющие значение False), получают значение Null и в
результирующем наборе не выводятся.

В стандарте ANSI SQL-92 условия объединения (соединения) записываются в
предложении From в соответствии со следующим синтаксисом –

>   From \<таблица\> [ Inner \| Left \| Right \| Full Outer \| Cross ] Join \<

таблица \> On \<условие поиска\>

(в ‘условиях поиска’ могут быть заданы любые критерии сравнения строк двух
объединяемых таблиц, в том числе с использованием булевских операторов).

Все разновидности конструкции Join имеют одну общую отличительную особенность, а
именно – в них одна строка согласуется с одной или несколькими другими строками
для получения результирующей строки, представляющей собой надмножество,
созданное путем соединения полей из нескольких строк.

В соединении различаются стороны – левая и правая. Левой считается таблица,
указанная в предложении From первой, а правой – таблица, указанная второй.

Конструкция Inner Join реализует внутреннее объединение и возвращает строки,
согласованные по всем полям, которые обозначены как используемые для соединения.
Внутреннее соединение является исключительным, т.е. любая строка, для которой
нет соответствия в обеих таблицах, неизбежно исключается из окончательного
варианта результирующего набора.

>   Существует четыре вида внешнего объединения:

-   левое внешнее объединение (Left Join) – запрос возвращает все строки из
    левой таблицы и только те из правой таблицы, которые удовлетворяют условию
    соединения (строки правой таблицы, не удовлетворяющие условию объединения,
    получают значение Null и в результирующем наборе не выводятся),

-   правое внешнее объединение (Right Join) – все наоборот по отношению к левому
    внешнему объединению,

-   полное внешнее объединение (Full Outer Join) – запрос возвращает все строки
    и левой и правой таблиц, но в особом порядке,

-   перекрестное объединение (Cross Join) – запрос возвращает все строки левой
    таблицы и первую строку правой таблиц, все строки левой таблицы и вторую
    строку правой таблиц, и так далее.

Пример. Пусть в БД используются две таблицы Т1 и Т2 следующего вида:

Необходимо выбрать поставщиков, проживающих в одних и тех же городах.

1.  Запрос, реализующий внутреннее объединение в стандарте

SQL-89 имеет вид:

Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as
‘Город2’

>   From T1, T2

>   Where T1.city=T2.city;

>   Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Lesha | Kharkov |
| Katja | Kiev    | Petja | Kiev    |
| Lena  | Kharkov | Lesha | Kharkov |

1.  Запрос, реализующий внутреннее объединение в стандарте SQL-92 имеет вид
    (стандарт SQL-92 допускает использование синтаксиса стандарта SQL-89):

>   Select T1.name 'Имя1', T1.city 'Город1',T2.name 'Имя2',T2.city 'Город2' From
>   T1 Inner Join T2 -- аналогичный результат без Inner

>   On T1.city=T2.city

>   Естественно, что вывод этого запроса аналогичен выводу по п. 1.

1.  Запрос, реализующий внутреннее объединение между частями одной таблицы –
    определить имена работников, живущих в одном и том же городе и этот город:

>   SELECT T1.Name,T1.City,T2.Name,T2.City FROM T1 INNER JOIN T1 T2

>   ON (T1.City=T2.City) And (T1.Name\>T2.Name)

1.  Запрос, реализующий левое внешнее объединение в стандарте

SQL-92 имеет вид:

Select T1.name as ‘Имя1’, T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as
‘Город2’

>   From T1 Left Join T2 On T1.city=T2.city;

Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Lesha | Kharkov |
| Katja | Kiev    | Petja | Kiev    |
| Lena  | Kursk   | Null  | Null    |
| Lena  | Kharkov | Lesha | Kharkov |

Вместо отсутствующих данных подставляется Null–значение.

1.  Запрос, реализующий правое внешнее объединение в стандарте

*SQL*-92 имеет вид:

Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as
‘Город2’

>   From T1 Right Join T2 On T1.city=T2.city;

Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Katja | Kiev    | Petja | Kiev    |
| Masha | Kharkov | Lesha | Kharkov |
| Lena  | Kharkov | Lesha | Kharkov |
| Null  | Null    | Vitja | Poltava |

1.  Запрос, реализующий правое внешнее объединение в стандарте

*SQL*-92 с дополнительным условием имеет вид:

Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as
‘Город2’

>   From T1 Right Join T2

>   On T1.city=T2.city And not (T1.city=’Kiev’) Order by 3

Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Lesha | Kharkov |
| Lena  | Kharkov | Lesha | Kharkov |
| Null  | Null    | Petja | Kiev    |
| Null  | Null    | Vitja | Poltava |

1.  Запрос, реализующий полное внешнее объединение (в результат должны быть
    включены все строки с обеих сторон соединения) в стандарте *SQL*-92 с имеет
    вид:

Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as
‘Город2’

>   From T1 Full Outer Join T2 On T1.city=T2.city

Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Lesha | Kharkov |
| Katja | Kiev    | Petja | Kiev    |
| Lena  | Kursk   | Null  | Null    |
| Lena  | Kharkov | Lesha | Kharkov |
| Null  | Null    | Vitja | Poltava |

Полное внешнее объединение является своего рода результатом совместного
применения левого и правого объединений.

1.  Запрос, реализующий перекрестное объединение имеет вид: Select T1.name as
    ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’

>   From T1 Cross Join T2

Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Petja | Kiev    |
| Katja | Kiev    | Petja | Kiev    |
| Lena  | Kursk   | Petja | Kiev    |
| Lena  | Kharkov | Petja | Kiev    |
| Masha | Kharkov | Lesha | Kharkov |
| Katja | Kiev    | Lesha | Kharkov |
| Lena  | Kursk   | Lesha | Kharkov |
| Lena  | Kharkov | Lesha | Kharkov |
| Masha | Kharkov | Vitja | Poltava |
| Katja | Kiev    | Vitja | Poltava |
| Lena  | Kursk   | Vitja | Poltava |
| Lena  | Kharkov | Vitja | Poltava |

Объединение Cross Join характеризуется отсутствием операции On.

Функции SQL
===========

Современные СУБД содержат ряд встроенных функций, которые позволяют выполнять
различные операции над данными, извлекаемыми из таблиц. Такие функции могут быть
частью SQL- выражения и позволяют переложить часть работы по обработке данных на
сервер СУБД.

Предположим, что результат, который мы хотим видеть на экране формируется путем
получения синуса над хранящемся значением. Можно извлечь данные из таблицы и
затем выполнить на клиентском компьютере операцию синус. Однако, нет никакой

необходимости это делать, потому что в SQL-операторе SELECT вместо имени поля
можно поставить SQL-выражение “SIN(имя_поля)” и сразу получить требуемые
значения.

>   Все SQL-функции разделяются на функции двух типов:

-   скалярные - предназначены для обработки одного данного;

-   агрегатные - предназначены для обработки множества данных. Скалярные функции
    разделяются на:

1.  Функции работы с числами.

2.  Функции работы с символами.

3.  Функции работы с датой и временем.

4.  Функции явного преобразования типов данных.

5.  Функции для шифрования/дешифрования данных.

6.  Остальные.

В таблице 10.1 перечислены основные категории функций MS SQL Server.

>   Таблица 10.1 – Категории функций MS SQL Server

| №  | Категория                        | Содержимое                                                                                                                                                |
|----|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Математические функции           | Предназначены для выполнения математических выражений.                                                                                                    |
| 2  | Функции даты и времени           | Предназначены для управления                                                                                                                              |
| 3  | Строковые функции                | Предназначены для управления текстовыми данными.                                                                                                          |
| 4  | Функции агрегирования            | Предназначены для вычисления единственного числа, основываясь на всех значениях в столбце (AVG, COUNT, COUNT_BIG, GROUPING, MAX, MIN, STDEV, STDEVP, SUM, |
| 5  | Функции курсора                  | Возвращают информацию о курсоре                                                                                                                           |
| 6  | Функции метаданных               | Возвращают информацию об объектах БД.                                                                                                                     |
| 7  | Функции конфигурирования         | Возвращают информацию о                                                                                                                                   |
| 8  | Функции безопасности             | Возвращают информацию о пользователях и ролях.                                                                                                            |
| 9  | Функции шифрования/дешифрования  | Предназначены для шифрования и                                                                                                                            |
| 10 | Системные функции                | Функции для управления объектами на низком уровне.                                                                                                        |
| 11 | Функции для текста и изображений | Функции для работы с большими                                                                                                                             |

>   датами и временем.

>   VAR, VARP).

>   (CURSOR_STATUS).

>   текущей конфигурации сервера.

>   дешифрования данных.

>   столбцами и типами данных.

>   Математические функции

>   В таблице 10.2 перечислены основные математические функции

MS SQL Server.

>   Таблица 10.2 – Математические функции

| ABS(n)      | Возвращает абсолютное значение n                         |
|-------------|----------------------------------------------------------|
| ACOS(n)     | Возвращает арккосинус n                                  |
| ATAN(n)     | Арктангенс n                                             |
| ATN2        | Арктангенс угла, описанного двумя углами                 |
| CEILING(n)  | Ближайшее целое, превышающее n                           |
| COS(n)      | Косинус n                                                |
| COТ(n)      | Котангенс угла n                                         |
| DEGREES     | Преобразование радиан в градусы                          |
| EXP(n)      | Экспонента n                                             |
| FLOOR(n)    | Ближайшее целое, меньшее n                               |
| LOG         | Логарифм по основанию 2                                  |
| LOG10       | Логарифм по основанию 10                                 |
| PI          | Константа Pi                                             |
| POWER(m, n) | Возвращает m в степени n                                 |
| RADIANS     | Преобразование градусов в радианы                        |
| RAND        | Генератор случайных чисел                                |
| ROUND       | Округление чисел с плавающей точкой до заданной точности |
| SIGN        | Возвращает знак выражения                                |
| SIN(n)      | Синус n                                                  |
| SQRT(n)     | Корень квадратный от n                                   |
| SQUARE      | Возведение в квадрат                                     |
| TAN(n)      | Тангенс n                                                |

>   Функции агрегирования

Агрегатные функции SQL (таблица 10.3), предназначены для выполнения действий над
множеством значений, которые группируются клаузой GROUP BY SQL-оператора SELECT.
Результатом работы функции является одно значение, которое получилось в
результате обработки множества. Все функции за исключением одной не учитывают в
своей работе поля со значением NULL и имеют общую форму представления:

имя_функции ([DISTINCT \| ALL] выражение)

По умолчанию перед выражением стоит клауза ALL, которая говорит, что в обработку
попадают все значения множества. Клауза DISTINCT позволяет удалить из обработки
повторяющиеся значения.

>   Таблица 10.3 – Функции агрегирования (агрегатные функции)

| Функция   | Назначение                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| AVG       | AVG([ALL\|DISTINCT]\<expression\>) Функция AVG возвращает среднее арифметическое значений, представленных в параметре \<expression\>. Параметр expression должен содержать числовые значения. NULL–значения игнорируются.                                                                                                                                                                                  |
| COUNT     | COUNT([ALL\|DISTINCT]\<expression\>\|\*) Функция COUNT возвращает данные типа int о количестве элементов, представленных в параметре \<expression\>. Параметр не может относиться к типу данных uniqueidentifier, text, ntext или image. При использовании значения параметра \* происходит возврат данных о количестве строк в таблице, при этом дублирующие значения или NULL– значениея не исключаются. |
| COUNT_BIG | COUNT_BIG([ALL\|DISTINCT]\<expression\>\|\*) Возвращает данные о количестве элементов в группе. Аналогична функции COUNT, но возвращаемое значение имеет тип данных biqint.                                                                                                                                                                                                                                |
| GROUPING  | GROUPING(\<column_name\>) Функция GROUPING добавляет дополнительный столбец к выводу оператора SELECT. Функция GROUPING используется только в списке выборки. Ее параметром является столбец \<column_name\>), который используется в конструкции GROUP BY и в котором должно быть проверено наличие NULL–значений.                                                                                        |
| MAX       | MAX([ALL\|DISTINCT]\<expression\>) Функция MAX возвращает максимальное из значений, представленных в параметре \<expression\>. При вычислении функции MAX все NULL–значения игнорируются.                                                                                                                                                                                                                  |
| MIN       | MIN([ALL\|DISTINCT]\<expression\>) Функция MIN возвращает минимальное из значений, представленных в параметре \<expression\>. При вычислении функции MIN все NULL–значения игнорируются.                                                                                                                                                                                                                   |
| STDEV     | STDEV(\<expression\>) Функция STDEV возвращает результат                                                                                                                                                                                                                                                                                                                                                   |
|           | вычисления среднеквадратического отклонения по всем значениям, представленным в параметре \<expression\>. При вычислении функции STDEV все NULL– значения игнорируются.                                                                                                                                                                                                                                    |
| SUM       | SUM([ALL\|DISTINCT]\<expression\>) Функция SUM возвращает сумму всех значений, представленных в параметре \<expression\>. При вычислении функции SUM все NULL–значения игнорируются.                                                                                                                                                                                                                       |
| VAR       | VAR(\<expression\>) Функция VAR возвращает результат вычисления дисперсии по всем значениям, представленным в параметре \<expression\>. При вычислении функции VAR все NULL– значения игнорируются.                                                                                                                                                                                                        |

>   Особенности запросов с агрегатными функциями:

1.  С функциями SUM и AVG используются только числовые поля, а с COUNT, MAX и
    MIN могут использоваться числовые или символьные поля.

2.  Функция COUNT(\*) считает количество значений в столбце или число строк в
    таблице.

>   Пример. Посчитать число студентов, сдавших учебные предметы.

>   SELECT COUNT(DISTINCT Id_Stud) FROM USP

>   Пример. Посчитать общее количество строк в таблице USP. SELECT COUNT(\*)
>   FROM USP

COUNT(\*) включает записи с NULL значениями, а также дубликаты, по этой причине
DISTINCT в данном случае не может быть использован.

Пример. Посчитать количество не-NULL значений в поле Id_Predm таблицы USP
(аргумент ALL означает – “включать дубликаты”).

>   SELECT COUNT(ALL Id_Predm) FROM USP

1.  Допускается использование агрегатных функций с аргументами, которые состоят
    из выражений, включающих одно или более полей, при этом команда DISTINCT не
    разрешается.

Пример. Найти максимальную величину проиндексированной стипендии. SELECT MAX
(STIP\*2) FROM USP;

1.  Нельзя использовать агрегатную функцию от агрегатной функции.

В списке возвращаемых столбцов нельзя одновременно указывать агрегатные функции
и простые имена столбцов. Такой запрос не имеет смысла.

>   SELECT Id_Stud, MIN (OCENKA) FROM USP;

Так как первый столбец создает таблицу, а второй возвратит только одно значение,
то это вызовет ошибку.

1.  Предложение GROUP BY позволяет определять подмножество значений в поле в
    терминах другого поля, и применять функцию агрегата к такому подмножеству.
    Это дает возможность объединять поля и агрегатные функции в едином
    предложении SELECT.

Пример. Определить наименьшую оценку полученную каждым студентом.

>   SELECT Id_Stud, MIN (OCENKA) FROM USP GROUP BY Id_Stud;

Пример. Определить наименьшую оценку полученную каждым студентом за каждый день.

>   SELECT Id_Stud, DATE, MIN (OCENKA) FROM USP GROUP BY Id_Stud, DATE;

Пример. Определить наименьшую оценку полученную каждым студентом за каждый день
меньшую 4.

>   SELECT Id_Stud, DATE, MIN (OCENKA) FROM USP

>   GROUP BY Id_Stud, DATE HAVING MIN (OCENKA) \<4;

Аргументы в предложении HAVING должны иметь одно значение на группу вывода.
Поэтому следующая команда будет запрещена:

>   SELECT Id_Stud, MIN (OCENKA) FROM USP

>   GROUP BY Id_Stud HAVING DATE= 06/03/2006;

Правильный способ сделать рассмотренный запрос следующий: SELECT Id_Stud, MIN
(OCENKA) FROM USP

>   WHERE DATE= 06/03/2006 GROUP BY Id_Stud;

>   Особенности работы агрегатных функций с полями со значением

NULL:

1.  Если какие либо из значений содержащихся в столбце, равны

NULL, при вычислении результата функции они исключаются!

1.  Если все значения в столбце равны NULL, то функции AVG(), SUM(), MIN(),
    MAX() возвращают значения NULL! Функция COUNT() возвращает ноль!

2.  Если в столбце нет значений (т.е. столбец пуст), то функции AVG(), SUM(),
    MIN(), MAX() возвращают значения NULL! Функция COUNT() возвращает ноль!

3.  Функция COUNT(\*) подсчитывает количество строк и не зависит от наличия или
    отсутствия в столбце значений NULL! Если строк в столбце нет, то эта функция
    возвращает ноль!

>   Особенности при работе с агрегатными функциями и DISTINCT.

1.  Если используется DISTINCT и агрегатная функция, то ее аргументом может быть
    только имя столбца, выражение не может быть аргументом.

2.  В функциях MIN(), MAX() так же нет смысла использовать DISTINCT! В функции
    COUNT() в принципе можно использовать DISTINCT, но это требуется не часто.

3.  А вот к функции COUNT(\*) вообще не применимо DISTINCT,

так как она просто подсчитывает число строк!

1.  Так же в одном запросе DISTINCT можно употреблять только один раз! Если оно
    применяется с аргументом агрегатной функции, его уже нельзя использовать ни
    с одним другим аргументом!

>   Системные функции и функции метаданных

>   Системные функции и функции метаданных (таблица 10.4)

возвращают информацию об SQL Server и хранящихся в нем данных.

>   Таблица 10.4 – Некоторые из системных функций и функций метаданных

| CASE           | Выполняет сравнение                                                     |
|----------------|-------------------------------------------------------------------------|
| CONVERT и CAST | Преобразует один тип данных в другой (например, целые числа в символы). |
| CURRENT_USER   | Возвращает имя текущего пользователя, который запустил SQL Server.      |
| ISDATE         | Указывает, представляют ли входные данные функции реальную дату.        |
| ISNULL         | Заменяет любое пустое значение заданным для замены.                     |
| ISNUMERIC      | Указывает, представляют ли входные данные функции числом.               |

>   Функции даты и времени

>   В таблице 10.5 перечислены основные функции даты и времени

MS SQL Server.

>   Таблица 10.5 – Функции даты и времени

| DATEADD    | Добавляет к дате некоторую величину.                                                                                                         |          |    |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------|----------|----|
| DATEIFF    | Выводит количество единиц времени, заданных в аргументе datepart, между двумя датами.                                                        |          |    |
| DATENAME   | Возвращает текстовые имена (например, Tuesday), соответствующие заданной дате                                                                |          |    |
| DATEPART   | Извлекает определенный заданной даты.                                                                                                         фрагмент из |
| DAY        | Извлекает день из даты.                                                                                                                      |          |    |
| GETDATE    | Возвращает текущее время и дату.                                                                                                             |          |    |
| GETUTCDATE | Возвращает текущую дату                                                                                                                      | и время  | по |
|            | Гринвичу (GMT – Greenwich Mean Time), преобразованное в формат универсального синхронизированного времени (UTC – Universal Time Coordinate). |          |    |
| MONTH      | Извлекает месяц из даты.                                                                                                                     |          |    |
| YEAR       | Извлекает год из даты.                                                                                                                       |          |    |

>   Некоторые из функций даты и времени используют аргумент

datepart, определяющий фрагмент, к которому применяется операция.

Пример. Функция DATEADD принимает в качестве аргументов маркер datepart,
величину приращения и исходную дату. Она возвращает результат добавления
указанной величины в единицах, указанных в аргументе datepart, к текущей дате.

>   // Добавить к текущей дате три дня

>   PRINT DATEADD(d, 3, GETDATE())

>   В таблице 10.6 перечислены константы аргумента datepart.

>   Таблица 10.6 – Константы аргумента datepart

| yy или y  | Год                  |
|-----------|----------------------|
| gg или g  | Квартал              |
| mm или m  | Месяц                |
| wk или ww | Неделя               |
| dw или w  | День недели          |
| dy или y  | День года (1 из 366) |
| dd или d  | День                 |
| hh        | Час                  |
| mi или n  | Минута               |
| ss или s  | Секунда              |
| ms        | Миллисекунда         |

>   Строковые функций

В таблице 10.7 перечислены основные строковые функции MS SQL Server.

>   Таблица 10.7 – Некоторые строковые функций

| LEFT      | Отбирает символы из левого конца строки, функция LEFT(‘abcdefg’, 4) возвратит строку abcd.                                  |
|-----------|-----------------------------------------------------------------------------------------------------------------------------|
| LEN       | Возвращает длину символьной строки.                                                                                         |
| LOWER     | Преобразует строку в нижний регистр.                                                                                        |
| LTRIM     | Удаляет начальные пробелы из строки.                                                                                        |
| REPLACE   | Заменяет заданные фрагменты строки другой строкой, функция                                                                  |
|           | REPLACE(‘abc’,’b’,’e’) возвратит строку aec.                                                                                |
| RIHGT     | Отбирает символы из правого конца строки.                                                                                   |
| RTRIM     | Удаляет конечные пробелы из строки.                                                                                         |
| SUBSTRING | Возвращает заданное количество символов после заданной точки в строке, функция SUBSTRING(‘abcde’,2,3) возвратит строку bcd. |
| UPPER     | Преобразует строку в верхний регистр.                                                                                       |
| \+        | Операция конкатенации строк.                                                                                                |

>   Пример. Отбор записей по значениям символьного поля. SELECT \* FROM Group
>   WHERE Dol =’студент’;

>   В данном примере составляется список студентов группы.

В операции сравнения учитывается регистр символов, поэтому слова ‘Студент’,
‘СТУДЕНТ’ и ‘студент’ не равны друг другу, а также начальные и конечные пробелы.
Поэтому различия в регистре символов должности, а также наличие пробелов в
начале и в конце строки приводят к ошибкам при отборе записей. В данной ситуации
критерий отбора лучше записать в следующем виде:

>   WHERE UPPER(TRIM(Dol)) = ’СТУДЕНТ’;

Если преобразование выполнить не возможно, то пользователь получает сообщение об
ошибке и SQL-оператор не выполняется.

>   Пример. Задание вычисляемого поля –

>   SELECT "-" \|\| Fam As Фамилия, Okl, Okl\*2 FROM Group;

Выводятся старые значения окладов сотрудников и новые, увеличенные на 100%. К
каждой фамилии с помощью операции конкатенации (\|\|) добавляется символ ”-”.
Заголовки таблицы – Фамилия, Okl, Okl\*2.

>   Контрольные вопросы

1.  Каковы основные способы объединения таблиц в запросе?

2.  Каковы особенности использования предложения UNION?

3.  Каковы особенности внутреннего объединения таблиц в запросе?

4.  Каковы особенности самосоединения таблиц в запросе?

5.  Какие виды объединения реализует предложение JOIN?

6.  Какие виды внешнего объединения реализует предложение

JOIN?

1.  Какие существуют типы SQL-функции?

2.  Какие существуют категории SQL-функции?

3.  Какие SQL-функции относятся к агрегатным?

4.  Каковы особенности запросов с агрегатными SQL-

функциями?

1.  Какие SQL-функции относятся к скалярным?

>   Лабораторная работа 5

Создание дополнительных объектов базы данных
============================================

>   Постановка задачи:

На основании таблиц физической модели данных, бизнес-правил предметной области и
скриптов построения таблиц БД создать:

1.  Создать 3-5 различных индексов.

2.  Создать 3-4 различных модифицируемых представления.

3.  Создать 3-4 различных представления для чтения.

4.  Создать запросы с использованием представлений.

5.  Создать команды для вставки, изменения и удаления данных базовых таблиц на
    основании представлений.

Для создания указанных скриптов и запросов использовать команды языка
манипулирования данными DML.

>   Письменный отчет по лабораторной работе должен содержать:

1.  Титульный лист, содержащий – название лабораторной работы, фамилию, имя,
    отчество, номер группы исполнителя, дату сдачи.

2.  Диаграмму БД.

3.  Скрипты для создания индексов БД.

4.  Скрипты для создания модифицируемых представлений для работы с БД.

5.  Скрипты для создания представлений для чтения для работы с БД.

6.  Скрипты для создания запросов с использованием представлений БД и результаты
    выполнения этих запросов.

7.  Скрипты для команд модификации данных базовых таблиц на основании
    представлений.

8.  Привести примеры работы основных операторов в соответствии с постановкой
    задачи (в виде − оператор + результат его работы).

9.  Выводы по лабораторной работе (в выводах отразить особенности работы с
    индексами и представлениями БД).

>   Контрольные вопросы и задания

1.  Определение и назначение представления.

2.  Каков синтаксис создания (удаления) представления?

3.  Каковы особенности работы с представлениями базы данных?

4.  Какие типы представлений существуют и каковы их особенности?

5.  Каковы особенности хранения данных на MS SQL-сервере?

6.  Определение и назначение индекса.

7.  Какие виды индексов существуют в MS SQL-сервере?

8.  Каковы особенности кластерного индекса?

9.  Каковы особенности некластерного индекса?

10. На основании каких структур данных строятся индексы?

11. Каков синтаксис создания (удаления) индексов?

12. Какие параметры может иметь команда создания индекса?

13. Каковы достоинства и недостатки индексов?

>   Лекция 11. **Представления и индексы**

Представления
=============

Представление (view) это объект СУБД, который является именованным запросом на
выборку, то есть именованным SQL- оператором SELECT. Представление не хранит
данные, а только их представляет. Пользователь воспринимает представление как
некоторое виртуальное отношение (виртуальную таблицу). Представление это
табличный подзапрос, представление содержится в таблицах схемы и вызывается
каждый раз при его применении.

Пример. Пусть имеется отношение Student (Id, Name, Enter_Year, Age, Id_Group,
Average_Mark). Создать представление, скрывающее информацию о годе поступления
(атрибут Enter_Year) и о возрасте (атрибут Age), а также изменяющее имена
некоторых атрибутов.

>   CREATE VIEW SPISOK (Id, Name, Group, Sr_Ball)

>   AS SELECT Id, Name, Id_Group, Average_Mark FROM

STUDENT

Теперь в БД существует представление с именем SPISOK, которое можно использовать
в командах так же, как и любую другую таблицу БД. Эта таблица может быть
запрошена, модифицирована, вставлена в, удалена из, и соединена с, другими
таблицами и представлениями. Запрос такого представления имеет вид:

>   SELECT \* FROM SPISOK

>   Механизм представлений позволяет:

1.  скрыть несущественные или нежелательные детали БД для разных пользователей,

2.  обеспечить повышенную производительность БД при частом использовании одного
    и того же оператора SELECT,

3.  модифицировать реальные структуры данных в удобном для приложения виде
    (например, при росте или реструктуризации БД) (фактически команды
    модификации перенаправляются к базовой таблице),

4.  поддерживать старую структуру БД (структура БД изменена, а старое
    программное обеспечение не изменено) – функциональность старой БД остается,
    а структура БД расширяется новыми модулями,

5.  разграничивать права доступа к данным,

6.  просматривать одни и те же данные разным пользователям в разных вариантах в
    одно и тоже время,

7.  ограничивать объемы данных для удобства работы с БД,

8.  после создания представления использовать его в запросах наравне с
    таблицами,

9.  на основе представлений можно создавать новые представления.

>   Синтаксис команды создания представление имеет следующий

вид:

>   CREATE VIEW \< имя_представления \> [(\< список_столбцов \>)] [WITH
>   [ENCRYPTHION] [, SCHEMABINDING]]

>   AS \< SQL-запрос \> [WITH CHECK OPTION]

Если список_столбцов при описании представления не указан, то в представление
войдут все столбцы из запроса, на основе которых оно создано, с соответствующими
именами.

С помощью опции ENCRYPTHION выполняется шифрование представления – недоступны
возможности просмотра и редактирования представления, но его можно выполнять и
удалить.

С помощью опции SCHEMABINDING выполняется связывание представления со схемой БД,
т. е. эта связь определяет от каких объектов (таблиц или других представлений)
зависит рассматриваемое представление. Наличие опции SCHEMABINDING позволяет
воспрепятствовать внесению изменений (с помощью операторов CREATE, ALTER или
DROP) в объекты, от которых зависит представление. Создание индексированного
представления возможно только при наличии опции SCHEMABINDING.

Конструкция WITH CHECK OPTION определяет, что модификация или вставка данных с
помощью такого представления осуществляется, только если вставляемая строка
соответствует критериям конструкции WHERE оператора SELECT представления.

Оператор AS в стандарте SQL-92 позволяет давать имена результатам выполнения
выражений подзапросов и использовать их. Таким образом, представление можно
считать постоянным табличным подзапросом, сохраняемым в схеме БД и вызываемым по
имени (таблица 11.1).

>   Таблица 11.1 – Список объектов БД и их свойства в запросе

| Объектов БД   | Физическое существование | Доступ со стороны пользователя |
|---------------|--------------------------|--------------------------------|
| Таблица       | да                       | да                             |
| Представление | нет                      | да                             |
| Индекс        | да                       | нет                            |
| Домен         | нет                      | нет                            |

>   Особенности работы с представлениями:

1.  Запрос, на котором основано представление, выполняется всякий раз, когда
    представление участвует в какой-либо команде. Представление будет
    модифицировано автоматически всякий раз, когда таблица, лежащая в его
    основе, изменяется. Представление “собирает в себя” выбранную по условию
    версию данных, к которым в нем осуществляется доступ.

2.  В представлении можно использовать вычислимые поля, группировки, подзапросы
    (в том числе и соотнесенные), однако при этом следует учитывать ограничения,
    отражающие природу представления.

Пример. Если изменять имена атрибутов в представлении не требуется, то команда
создания такого представления будет иметь вид:

>   CREATE VIEW SPISOK_1

>   AS SELECT Id, Name, Id_Group, Average_Mark FROM

STUDENT

Представление, содержащее информацию о студентах со средним баллом больше-равно
4 имеет вид:

>   CREATE VIEW SPISOK_AVR_4

AS SELECT Id, Id_Group, Name, Average_Mark FROM STUDENT

>   WHERE Average_Mark \>= 4

Желательно, чтобы те поля, которые участвуют в предикате представления, были
включены и в состав выводимых полей, даже если они содержат одинаковые значения.
Иначе с помощью представления нельзя будет организовать вставку значений в поле
Average_Mark.

1.  С помощью представлений никогда не удастся добиться такого же
    быстродействия, как при непосредственном вызове на выполнение оператора
    SELECT, лежащего в основе этого представления.

2.  Представление (посредством его имени) можно использовать в командах –
    запрашивать (SELECT), изменять (UPDATE), вставлять в него записи (INSERT),
    удалять из БД (DELETE), соединять с другим таблицами и представлениями.
    Существуют ограничения на операции модификации (UPDATE, INSERT, DELETE),
    которые зависят от вида представления. Фактически команды модификации
    представления перенаправляются к базовой таблице БД. Вносимое в
    модифицируемое представление изменение должно однозначно вноситься и в
    базовую таблицу.

Пример. Модификация информации в БД с помощью представления:

>   UPDATE SPISOK_1

>   SET NAME = ’СИДОРОВА’ WHERE Id=32

Модифицируемое представление должно содержать первичный ключ таблицы – должна
быть абсолютная уверенность, что каждая строка обновляемого представления
отображается в одну строку базовой таблицы.

>   Существует два типа представлений:

-   модифицируемое (обновляемое) - если команды модификации могут выполняться в
    представлении;

-   предназначенное только для чтения при запросе - если в представлении может
    выполняться только команда SELECT.

Чтобы обеспечить вставку данных (операторы INSERT) с помощью представления
достаточно обеспечить, чтобы этим представлением были охвачены все столбцы без
ограничений:

-   значения по умолчанию,

-   наличие NULL–значений.

Критерии, по которым определяют, является ли представление модифицируемым:

1.  необходимо, чтобы представление основывалось только на одной базовой
    таблице,

2.  представление должно содержать первичный ключ базовой таблицы,

3.  представление не должно иметь никаких полей, которые бы являлись агрегатными
    функциями,

4.  представление не должно содержать запросов с DISTINCT в своем определении,

5.  представление не должно использовать GROUP BY или HAVING

в своем определении,

1.  желательно, чтобы представление не использовало в своем определении
    подзапросы,

2.  представление может быть использовано в другом представлении, но это
    представление должно быть также модифицируемым,

3.  представление не должно использовать константы, строки или выражения
    значений среди выбранных полей вывода,

4.  для команды INSERT представление должно содержать любые поля основной
    таблицы, которые имеют ограничение NOT NULL, если другое ограничение по
    умолчанию не определено.

Таким образом, модифицируемые представления фактически подобны фрагментам
базовых таблиц, отображая определенную часть их содержимого.

Представления – “только для чтения”, с другой стороны, позволяют получать и
форматировать данные более рационально – избегать сложных предикатов и снижать
вероятность ошибок.

1.  Упорядочивание данных в представлении выполняется с помощью предложения
    ORDER BY запроса, на котором основано представление.

2.  Представление может быть основано на нескольких базовых таблицах.

3.  Вычисление представления производится каждый раз при его использовании,
    любые изменения в данных таблиц БД адекватно отобразятся в представлении – в
    этом его отличие от запроса к БД.

4.  Механизм представлений реализуется непосредственно на базовых отношениях и
    хранится в виде функции.

5.  Материализация представлений осуществляется при реализации соответствующих
    действий пользователя, до этого момента материализованных данных
    представления в БД не хранится. Материализация означает, что при ссылке на
    имя представления СУБД находит его определение в таблицах схемы и создает
    рабочую таблицу соответствующего имени со столбцами соответствующих типов
    данных и соответствующими именами. Затем эта новая таблица заполняется
    результатами работы оператора SELECT, находящегося в теле определения
    представления.

6.  Для внесения изменений в определение представления используют два способа:

-   с помощью оператора ALTER VIEW, при этом предполагается, что рассматриваемое
    представление уже существует (выполняется полная замена существующего
    представления, сохраняются все права на использование представления),

-   уничтожение представления (DROP VIEW \<имя_представления\>) и его повторное
    создание с помощью оператора CREATE VIEW.

При удалении представления нет необходимости удаления всех данных из
представления, потому что реальные данные в нем не содержатся. Для удаления
представления пользователь должен являться его владельцем.

1.  Для получения информации о различных объектах БД используют представления
    информационной схемы и представления каталогов.

    1.  Индексы

        1.  **Особенности хранения данных на MS SQL-сервере**

Данные в реляционной БД хранятся в таблицах, которые в свою очередь состоят из
строк определенной структуры. Последовательность строк, с логической точки
зрения, представляется непрерывной, хотя с точки зрения реляционной модели, сами
по себе записи в отношении не упорядочены.

С точки зрения физического хранения данных для MS SQL– сервера, строки таблиц
привязаны к конкретным областям диска фиксированного размера – страницам.

Страница – это блок фиксированной длины непрерывных виртуальных адресов памяти,
который участвует в операциях чтения и записи как единое целое, то есть требует
только одного перемещения головки диска для выполнения этих операций. В MS
SQL–сервере размер страницы равен 8 Кбайт (8192 байт). Количество строк в
странице может варьироваться в зависимости от их размера. Страница может
рассматриваться как контейнер для хранения строк таблиц и индексов. Одна строка
не может быть разделена между двумя страницами.

>   Страница состоит из следующих компонентов:

-   заголовка страницы (page header) (96 байт),

-   самих данных, - указателей смещения строк (row offset), которые необходимы
    для определения в странице позиции, с которой начинаются данные конкретной
    строки,

-   двух указателей на предыдущую и последующую страницы

(страницы данных образуют двухсвязный список).

>   Разновидности страниц базы данных:

-   страницы данных (Data Pages) – используются для хранения реальных данных
    таблиц (кроме BLOB-данных);

-   страницы индекса (Index Pages) - используются для хранения страниц разных
    уровней В-дерева, используемого для хранения данных индекса (индексная
    страница (узел В-дерева) содержит упорядоченный список всех значений
    индексированного столбца (они называются ключевыми значениями) вместе с
    указателем местоположения каждой записи, содержащей это значение в таблице);

-   BLOB-страницы (Binari Large Object) – предназначены для хранения больших
    бинарных объектов;

-   карты размещения страниц (таблицы распределения) (Global и Shared Global
    Allocation Map - GAM и SGAM) – используются для определения свободных и
    используемых страниц и экстентов БД;

-   страницы свободного пространства (Page Free Space – PFS);

-   карты (таблицы) размещения индексов (Index Allocation Map – IAM) – содержат
    сведения об экстентах файла БД, используемых таблицами кучи или индексами,
    используется для навигации по куче,

-   таблица массовых изменений,

-   таблица дифференциальных изменений. Страницы объединяются в экстенты.

Экстент – это единица памяти, которую сервер выделяет по мере необходимости как
единое целое при размещении на диске данных таблицы или индекса (рисунок 11.1).
Экстент означает пространство, используемое для хранения реальной информации
внутри физического пространства, выделенного под БД в целом. В MS SQL– сервере
2005 экстент состоит из 8 смежных страниц данных (64 Кбайта). В MS SQL–сервере
при создании таблицы изначально не

выделяется ни одной страницы, они выделяются только при вставке в таблицу новых
строк.

>   Особенности работы с экстентами:

-   после заполнения экстента при вставке новой записи выделяется новый экстент,

-   благодаря предварительному выделению памяти сервер экономит время,

-   экстенты таблицы не размещаются физически один за другим в файле БД, они
    разбросаны, поэтому доступ к данным кучи будет выполняться медленно,

-   общий объем неиспользуемой части экстентов обычно не велик, но он может
    возрастать особенно при высокой степени дефрагментации данных,

-   экстенты блокируются только во время выделения нового либо освобождения
    старого экстента.

>   Рисунок 11.1 – Укрупненная структура расположения данных в БД (по умолчанию
>   БД имеет два файла – физический файл БД (\*.mdf), - файл журнала (\*.ldf))

В зависимости от способа хранения различают два типа таблиц: таблицы кучи и
кластерные таблицы. Тип, к которому принадлежит таблица, зависит от того,
имеется ли у этой таблицы кластерный индекс или нет.

Таблицы кучи – это таблицы, расположенные в куче, которая представляет собой
набор страниц данных, выделяемых по мере надобности для таблиц, не имеющих
кластерного индекса, а также для самих индексов. Строки таблицы кучи не имеют
какого-либо конкретного порядка, и страницы данных, принадлежащие одной таблице,
также никак не упорядочены и не связаны в список. Для вставки новой строки в
таблицу в адресном пространстве выделяется следующий экстент данных, если
пространство на уже выделенных страницах заполнено. Доступ к конкретной строке
осуществляется путем полного сканирования таблицы.

Кластерные таблицы – это таблицы, которые имеют кластерный индекс. Кластерный
индекс – это такой индекс, в котором логический порядок ключевых значений
определяет физический порядок соответствующих строк в таблице. Кластерный индекс
у таблицы может быть только один, и его наличие приводит к тому, что строки
таблицы хранятся на диске в строго определенном порядке – упорядочены по
возрастанию (или по убыванию).

Заголовок страницы данных кластерной таблицы (рисунок 11.2) включает в себя
идентификатор таблицы, которой принадлежит страница, а также указатели на
следующую и предыдущую страницы. Остальную часть страницы заполняют строки
данных.

>   Рисунок 11.2 – Двусвязный список для организации страниц данных кластерной
>   таблицы на SQL-сервере

При вставке новой строки в кластерную таблицу, если в нужной странице нет
свободного места, происходит *расщепление* (*разбиение*) страницы. Суть процесса
расщепления состоит в перемещении половины строк из полностью заполненной
страницы во вновь выделенную страницу таким образом, что вместо одной полностью
заполненной страницы появляются две, заполненные почти наполовину. Так
появляется место для новой строки с сохранением физического порядка сортировки.
Доступ к конкретной строке кластерной таблицы осуществляется по алгоритму поиска
в сбалансированном дереве по значению ключа, уникальному для каждой строки
таблицы.

>   Существуют следующие основные методы доступа к данным БД:

1.  сканирование таблицы (последовательный доступ) – последовательное чтение
    всех строк таблицы в том порядке, в котором они записаны в место их
    физического хранения, за раз считывается одна страница данных;

2.  доступ посредством индексов (индекс обычно имеет структуру В-дерева или
    инвертированную структуру файла) – индекс позволяет возвращать по одной
    строке таблицы за раз;

3.  доступ посредством хешированных индексов – такой индекс делит данные на
    области с одинаковым значением функции хеширования;

4.  доступ посредством битовых векторных индексов – конкретное значение
    конкретного атрибута (ключ) представляется в виде одного бита в векторе
    (маске) или в массиве (битовые индексы появились в Oracle 8.0).

>   Методы доступа 3 и 4 используются только в Oracle.

Определение индекса и его структура
===================================

Существует два существенно различающихся способа извлечения данных посредством
запроса из БД в MS SQL–сервере:

1.  путем табличного сканирования (путем последовательного сканирования строк,
    страниц и экстентов таблицы (или таблиц) БД);

2.  при помощи индекса.

Какой из способов будет автоматически использован сервером для конкретного
запроса зависит от:

-   доступных на текущий момент индексов,

-   от запрашиваемых в запросе столбцов,

-   от типа объединений таблиц, которые используются в запросе,

-   от физического размера используемых в запросе таблиц.

Пусть требуется вывести список студентов, у которых средний был выше 4,5: SELECT
name FROM Student WHERE avg_mark \> 4.5;

Пусть в таблице Student отсутствуют индексы и значит таблица размещена в куче.
Как будет реализована эта выборка? Единственным способом реализации этого
запроса является табличное сканирование – т. е. при поиске данных из диапазона
данных (5.0 \>avg_mark\> 4.5) сервер должен обратиться к каждой строке каждой
страницы каждого экстента таблицы данных Student для поиска каждого конкретного
значения из диапазона поиска.

Табличное сканирование может существенно замедлить работу системы, однако не
всегда. *Если таблица очень маленькая* (занимает около одного экстента), то
табличное сканирование может работать быстрее, чем индексированный доступ. Если
создается индекс в маленькой таблице, то серверу придется считать индексные
страницы, и только после этого считать страницы данных. В данной ситуации
быстрее просто сканировать таблицу.

Таким образом, маленькие таблицы предпочтительней делать кучами. Однако в
больших таблицах следует избегать сканирования и использовать индексы.

Естественно, что проще было бы выполнить данную выборку из диапазона, если бы
данные в таблице Student были бы отсортированы или имелась бы информация о
номерах строк (о первичных ключах строк) в порядке возрастания (убывания)
значений в поле avg_mark. Эта информация и содержится в объектах БД – индексах.

*Индексы* – это внутренние объекты СУБД, которые ускоряют процесс обработки
данных (выборки, вставки, изменения и удаления). Индекс – упорядоченный список
значений полей или значений групп полей в таблице. Когда создается индекс в
поле, БД запоминает соответствующий порядок всех значений этого поля в области
памяти. Оптимизатор сервера для ускорения доступа к данным автоматически
применяет индексы.

Индекс хранит информацию о порядке следования записей, относительно поля
avg_mark, что может привести к ускорению выполнения оператора SELECT. Когда
требуется выполнить операцию выборки из БД данных с использованием сортировки,
то эта

информация из индекса автоматически подключается сервером к процессу извлечения
данных.

Пример. Показан фрагмент таблицы Student с полями id – ключевое поле (созданный
сервером кластерный индекс), avg_mark - средний балл и таблица с индексами поля
avg_mark по возрастанию (некластерный индекс).

>   В SQL-сервере могут существовать индексы двух типов:

-   кластерные (кластеризованные) индексы – аналогом такого индекса является
    словарь, если кластерный индекс будет создан для столбца “Фамилия”, то
    физически запись со значением Иванов в поле “Фамилия” всегда будет стоять
    перед записью со значением Петров;

-   некластерные (некластеризованные) индексы – аналогом такого индекса является
    предметный указатель в книге, в котором, например, имеется раздел И, в
    котором есть ссылка на страницы, где упоминается фамилия Иванов.

Кластерный и некластерный индексы реализуются посредством структуры данных
В-дерева (balanced tree – сбалансированное дерево).

>   Между типами индексов имеются существенные различия:

-   c точки зрения физической реализации индексов,

-   с точки зрения числа индексов на таблицу БД – кластерный индекс всегда один
    на базовую таблицу, а некластерных индексов может быть несколько на таблицу,

-   с точки зрения выполнения различных операций в БД с использованием индексов.

Кластерные индексы
==================

При определении для таблицы с данными кластерного индекса серверу фактически
отдается команда физически отсортировать данные по возрастанию (или убыванию) в
порядке индекса (по полю, для которого создан кластерный индекс). При вставке
(модификации) данных в таблицу с кластерным индексом запись будет вставляться с
учетом поддержки упорядоченности по полю, для которого построен кластерный
индекс. Поэтому у любой таблицы может быть только один кластерный индекс.

На уровне листа В-дерева кластерного индекса страницы данных, предназначенные
для хранения индексной информации,

физически совпадают со страницами данных базовой таблицы, для которой этот
индекс создан.

Средний размер кластерного индекса составляет около 5% от размера таблицы, но
может варьироваться в зависимости от размера индексируемого столбца.

В кластерном индексе данные на уровне листа физически отсортированы.

Пусть требуется выполнить запрос – выборка диапазона – SELECT name FROM Student
WHERE avg_mark \>= 4.5;

Пусть в таблице Student по полю avg_mark создан кластерный индекс. Выборка
запроса будет выполнена следующим образом.

Выполняется проход по В-дереву кластерного индекса (от корневой страницы через
промежуточные к листовой странице) для поиска значения ключа кластеризации 4,5.
Так как страницы данных листового уровня индекса представляют собой двухсвязный
список, то далее выполняется проход по списку в порядке возрастания значения
поля avg_mark до равенства значению конца диапазона 5,0 (а точнее

-   пока указатель не станет равным Null в данном запросе).

>   Кластерный индекс является идеальным выбором для столбцов:

-   в которых постоянно выполняется поиск диапазонов данных,

-   с низкой селективностью (низкая селективность значений столбца означает, что
    в столбце много одинаковых записей – много, например, значений 4,6 в поле
    “Средний балл”).

Проблемы возникают при модификации данных в поле с кластерным индексом (команды
INSERT, UPDATE, DELETE), так при этом сервер должен физически перекомпоновывать
данные для их соответствия параметрам кластерного индекса. Для необходимости
перекомпоновки сервер оставляет немного свободного места в конце каждой страницы
данных с кластерным индексом. Это пустое пространство регулируется параметром
FILLFACTOR - фактором заполнения.

Фактор заполнения задается при создании кластерного индекса и позже может быть
изменен. Чем выше фактор заполнения, тем меньше свободного места он выделяет и
наоборот. Если фактор заполнения равен 100%, то это означает, что страница
данных заполнена на 100%, но еще есть место для одной записи.

Когда требуется вставить данные в полностью заполненную страницу, сервер
выполняет разбиение страниц (рисунок 11.3). Это означает, что сервер перемещает
примерно половину данных с заполненной страницы на пустую, создавая таким
образом две наполовину заполненные страницы. Так как физически новая страница
может находиться в любом месте файла базы данных, а страницы данных таблицы с
кластерным индексом должны образовывать двухсвязный список, то далее у трех
страниц данных

>   Необходимо вставить новую запись, однако на странице отсутствует свободное
>   место.

>   Исходная страница должна быть разбита на две страницы, поскольку новую
>   запись необходимо вставить между другими записями.

>   Рисунок 11.3 – Процесс разбиения (расщепления) страницы кластерного индекса

должны быть обновлены указатели на предыдущую и последующую страницы. Кроме
этого еще необходимо произвести вставку в В- дерево кластерного индекса, что
приведет к перестройке В-дерева.

В БД, где данные используются исключительно для чтения, например, в среде
поддержки принятия решений, можно использовать высокий фактор заполнения (меньше
свободного места). Высокий фактор заполнения будет гарантировать, что данные
считываются из меньшего количества страниц файла БД, что повысит
производительность команды SELECT.

Низкий фактор заполнения следует использовать в БД с большими потоками команд
INSERT, UPDATE, DELETE. Более низкий фактор заполнения обеспечит меньшее число
разбиений страниц и повысит производительность команд INSERT, UPDATE, DELETE.

Некластерные индексы
====================

>   Некластерный индекс также реализуется посредством В-дерева. Между двумя
>   типами индексов существуют следующие отличия:

1.  листовой уровень некластерного индекса содержит не реальные данные, а только
    указатели на страницы данных,

2.  некластерный индекс не перемещает физически данные таблицы БД. (Все это
    похоже на разницу между словарем (кластерный индекс) и указателем в конце
    книги (некластерный индекс).)

>   Существует два вида реализации некластерного индекса:

\- некластерный индекс основанный на куче (если в таблице изначально нет
кластерного индекса по другому полю таблицы) –

вставка данных в таблицу с некластерным индексом происходит в очередную
свободную строку последней страницы и потом происходит обновление указателей
индекса,

\- некластерный индекс основанный на кластерном индексе (если в таблице есть
кластерный индекс) – при вставка данных в такую таблицу сервер физически
помещает данные в соответствии с кластерным индексом с и потом обновляет
ключевое значение некластерного индекса для указания на ключевое значение
кластерного индекса.

Если в таблице выполняется поиск одного значения с применением некластерного
индекса, то сервер обратится к индексу один раз, поскольку листовой уровень
индекса приведет прямо к данным. Если же выполняется поиск диапазона значений,
то сервер будет постоянно ссылаться на индекс в поисках ключевого значения для
каждой записи диапазона. Это означает, что следует использовать некластерный
индекс в столбцах, в которых редко выполняется поиск диапазонов данных, или в
столбцах с высокой селективностью (с небольшим числом дублирующихся записей).

Различия между кластерным и некластерным индексами приведены в таблице 11.2.

>   Таблица 11.2 – Различия между кластерным и некластерным

>   индексами

| Кластерный индекс                                                                      | Некластерный индекс                                                                    |
|----------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
| Только 1 на таблицу                                                                    | До 249 индексов на таблицу                                                             |
| Физически перестраивает данные в таблице согласно ограничениям индекса                 | Создает отдельный список ключевых значений с указателями на данные страницы            |
| Используется в столбцах, где часто выполняется поиск диапазонов данных                 | Используется в столбцах, где выполняется поиск отдельных значений                      |
| Используется в столбцах с низкой селективностью (высокое число дублированных значений) | Используется в столбцах с высокой селективностью (низкое число дублированных значений) |

>   Достоинство индексов.

1.  Ускорение операции поиска.

2.  Ускорение операции сортировки.

3.  Ускорение фазы поиска при удалении, вставке и модификации.

Индексация позволяет находить содержащий индексированную строку блок данных,
выполняя небольшое число обращений к внешнему устройству.

>   Недостатки индексов.

1.  Для хранения индексов требуется дополнительная память.

2.  При операциях вставки, модификации и удаления требуется перестройка данных
    (в случае кластерного индекса) и индексов.

Управление индексом существенно замедляет время выполнения операций, связанных с
обновлением данных (таких, как INSERT, UPDATE и DELETE), так как эти операции
требуют перестройки индексов.

Индексы можно создавать как по одному, так и по множеству полей.

SQL Server сам решает, когда индекс необходим для работы и использует его
автоматически.

Создание индекса на MS SQL-сервере
==================================

>   Методы создания индексов в MS SQL-сервере:

1.  с помощью утилиты SQL Sever Management Studio –

визуальное средство;

1.  с помощью функции Database Tuning Advisor (данная функция входит в утилиту
    SQL Profiler, которая выполняет мониторинг SQL Sever 2005) – визуальное
    средство;

2.  с помощью команды Create языка SQL– визуальные средства являются только
    оболочкой для команд SQL;

3.  неявное создание индекса как обязательного объекта в результате ввода в
    действие некоторого ограничения (Primary Key, Unique).

При этом таблица должна быть уже создана и содержать столбцы, имена которых
указаны в команде создания индекса. Имя индекса, определенное в команде, должно
быть уникальным в базе данных.

Будучи однажды созданным, индекс является невидимым для пользователя, все
операции с ним осуществляет СУБД автоматически.

Оператор CREATE INDEX создает на указанной таблице или представлении индекс,
основанный на заданных столбцах. Синтаксис команды создания индекса имеет
следующий вид:

>   CREATE [UNIQUE] [CLUSTERED \| NONCLUSTERED]

>   INDEX \<index_name\> ON \<table or view name\> (\<column name\> [ASC \|
>   DESC] [, … n]) INCLUDE (\<column name\> [, -n])

>   [WITH

>   [PAD_INDEX = {ON \| OFF}]

>   [[,] FILLFACTOR = \<коэффициент заполнения\> ] [[,] IGNORE_DUP_KEY = {ON \|
>   OFF}]

>   [[,] DROP_EXISTING = {ON \| OFF}]

>   [[,] STATISTICS_NORECOMPUTE = {ON \| OFF}] [[,] SORT_IN_TEMPDB = {ON \|
>   OFF}]

>   [[,] ONLINE = {ON \| OFF}]

>   [[,] ALLOW_ROW_LOCKS = {ON \| OFF}] [[,] ALLOW_PAGE_LOCKS = {ON \| OFF}]

>   [[,] MAXDOP = \<maximum degree of parallelism\>

>   ]

>   [ON {\<filegroup\>\|\<partition scheme name\>\|DEFAULT}]

Эта команда создает индекс с именем index_name для указанной таблицы table или
представления view по перечисленным в параметре column столбцам. Индекс не
является автономным объектом, он относится к некоторому столбцу (столбцам)
таблицы или представления.

>   Обязательной является только конструкция CREATE INDEX

\<index_name\> ON \<table or view name\>(\<column name\>), а все остальные
конструкции, которые следуют за ней, являются необязательными.

Параметры команды создания индекса имеют следующий смысл. UNIQUE – говорит о
том, что задается индекс, реализующий ограничение уникальности для своих
столбцов, которое означает, что данные в этих столбцах не могут повторяться (по
умолчанию индексы

не являются уникальными).

>   CLUSTERED – создается кластерный индекс.

NONCLUSTERED – создается некластерный индекс (значение по умолчанию).

ASC (сокращение от ascending) – создает индекс в порядке возрастания и это
значение установлено по умолчанию, а DESC – в порядке убывания.

INCLUDE – для обеспечения лучшей поддержки “охваченных” запросов (запрос
рассматривается как “охваченный”, если все данные, которые должны быть получены
в результате выполнения запроса, полностью представлены в используемом индексе).
При применении INCLUDE сервер переносит содержимое указанных столбцов на
листовой уровень индекса, что влечет за собой значительное сокращение операций
ввода/вывода. Эту опцию имеет смысл применять только при создании некластерных
индексов, так как кластерные индексы уже содержат данные на листовом уровне.
Отрицательные последствия применения опции INCLUDE – увеличение размеров строк
индекса листового уровня. В результате может оказаться, что попытка ускорить
выполнение одного запроса приведет к снижению быстродействия при выполнении
других запросов.

WITH – данная опция применяется для передачи СУБД указания на то, что за ней
последует одна или несколько дополнительных опций.

PAD_INDEX – задает степень заполнения страниц индекса на нелистовом уровне (в
процентах) при первоначальном создании индекса (по умолчанию остается место для
вставки на уровне страниц индекса двух индексных записей максимальной длины).
Если значение PAD_INDEX=ON, то это означает, что значение FILLFACTOR
распространяется и на степень заполнения страниц на всех уровнях индекса (если
значение PAD_INDEX не определено, то FILLFACTOR применяется только к страницам
листа в индексе). Применение параметра PAD_INDEX=ON не имеет смысла, если не
задана опция FILLFACTOR.

FILLFACTOR – задает степень заполнения данными страниц на уровне листа (значение
по умолчанию FILLFACTOR=0 (означает тоже что и FILLFACTOR=100), что обозначает
полное заполнение страниц на уровне листа индекса, но имеется пустое место на
индексных страницах верхних уровней). Обычно значение опции FILLFACTOR это любое
число от 1 до 100. Это число показывает, насколько полным должно стать
заполнение страниц в процентах после завершения создания индекса. При разбиении
страниц данные все равно перераспределяются между двумя страницами в равных
долях. Это значит, что в процессе эксплуатации БД невозможно постоянно сохранять
контроль над тем, в каком процентном отношении заполняются страницы индекса,
поэтому при техническом сопровождении индекса необходимо проводить перестройку
индекса. Если значение FILLFACTOR не задано, то СУБД полностью заполняет
страницы, за вычетом двух строк.

Значение FILLFACTOR=100 означает, что и каждая индексная страница должна быть
полностью заполнена при создании индекса. Если кластерный индекс имеет
FILLFACTOR=100, то это означает, что при вставке записи всегда будет происходить
процесс разбиения страницы (многочисленные разбиения страниц могут уменьшить
эффективность работы сервера). Если значении FILLFACTOR слишком мало, то индекс
займет неоправданно много места в памяти.

Идеальное значение FILLFACTOR=R/W, R – среднее число операций чтения, W -
среднее число операций записи, выполняемых для компонентов индекса. FILLFACTOR
подбирается экспериментально, R и W могут быть определены статистически при
работе с БД с помощью утилиты Performance Monitor.

>   Рекомендации по выбору фактора заполнения FILLFACTOR:

-   редко изменяемые таблицы (выполняется от 100 до 1 операции чтения на одну
    операцию записи) FILLFACTOR=100,

-   часто изменяемые таблицы (количество операций чтения превышает количество
    операций записи) FILLFACTOR=50-70,

-   промежуточная ситуация FILLFACTOR=80-90.

IGNORE_DUP_KEY – говорит о том, что нужно игнорировать совпадающие значения в
столбцах индекса. При наличии опции

IGNORE_DUP_KEY при попытке вставить уже имеющееся значение, выдается
предупреждение (а не сообщение о критической ошибке), вставка строки не
выполняется, но отката транзакции нет.

DROP_EXISTING – перед созданием нового индекса требует удалить существующий
индекс с именем, которое совпадает с именем создаваемого индекса. Если в
результате перестройки должен быть получен индекс, полностью совпадающий с
существующим индексом, то СУБД определяет, что такой некластерный индекс не
следует подвергать операции удаления и повторного создания (в отличии от
выполнения явных операций удаления индекса, а потом его создания). Эта опция
обеспечивает гораздо более эффективное формирование индекса по сравнению с тем,
когда происходит просто удаление и повторное создание существующего индекса,
если он используется в сочетании с кластерным индексом.

STATISTICS_NORECOMPUTE – приказывает не перестраивать статистику таблиц после
создания индекса. По умолчанию в СУБД предпринимается попытка автоматизировать
процесс обновления статистических данных, относящихся к используемым таблицам и
индексам. Чтобы отменить эту опцию, необходимо вызвать команду UPDATE
STATISTICS. Рекомендуется не использовать эту опцию, так как статистические
данные, относящиеся к индексу, используются оптимизатором запросов для
определения того, насколько данный индекс способствует повышению
производительности выполнения данного конкретного запроса. Отказ от
автоматического обновления статистических данных приведет к тому, что
оптимизатор запросов будет выбирать способы выполнения запросов на основании
устаревшей информации.

SORT_IN_TEMPDB – требует выполнять сортировку при создании индекса в базе данных
TEMPDB (используется при создании индексов на больших таблицах), применение
опции дает эффект, если текущая БД и БД TEMPDB находятся на разных дисковых
устройствах. ONLINE – если ONLINE=ON, то принудительно устанавливается такой
режим доступа к индексируемой таблице, что эта таблица остается применимой и для
общего доступа и не создаются какие- либо блокировки, не позволяющие обращаться
к таблице и (или) к индексу. Но выполнение операции создания индекса (при
ONLINE=ON) существенно снизит производительность работы пользователей. По
умолчанию (при ONLINE= OFF) при создании индекса происходит полная блокировка
таблицы, при этом индекс

формируется намного быстрее, чем при ONLINE=ON.

ALLOW_ROW_LOCKS и ALLOW_PAGE_LOCKS (позволение (или нет) блокировки строки или
страницы) – служат для указания на то, что могут ли применяться для создаваемого
индекса блокировки на уровне страницы или на уровне строки. Блокировка это
своего рода способ резервирования ресурсов, позволяющий предотвратить

конфликты между операциями доступа к данным, которые могли бы привести к
нарушению целостности данных.

MAXDOP – опция позволяет переопределить значение параметра настройки
конфигурации системы, определяющее максимальную степень распараллеливания
(Degree Of Parallelism - DOP), которая применяется при формировании индекса.
Степень распараллеливания определяет максимальное количество процессов, которые
могут быть введены в действие в целях осуществления одной операции в БД –
операции формирования индекса.

ON filegroup – указывает, в какой группе файлов нужно физически создать и
хранить индекс (по умолчанию - PRIMARY). Удобнее использовать для хранения
индексов и страниц данных разные жесткие диски.

Пример. Если таблица EXAM часто используется для поиска оценки конкретного
студента по значению поля ID_STUDENT, то следует создать индекс по этому полю.

>   CREATE UNIQUE CLUSTERED INDEX IND*\_*STUD ON EXAM (ID*\_*STUDENT ASC)

WITH PAD_INDEX = ON, FILLFACTOR = 90, DROP_EXISTING = ON;

Создан для поля ID*\_*STUDENT таблицы EXAM уникальный кластерный индекс по
возрастанию значений с именем IND*\_*STUD, причем фактор заполнения страниц
индекса всех уровней равен 90, если перед созданием данного индекса уже
существовал индекс с именем IND*\_*STUD, то он будет предварительно удален.

>   Удаление индекса происходит в следующих случаях:

-   удаление неверно созданных индексов,

-   удаление индексов вследствие изменения структуры таблицы,

-   удаление индексов вследствие создания новых индексов, которые позволяют
    лучше выполнять запросы.

>   Для удаления индекса используется команда DROP INDEX,

имеющая следующий синтаксис:

>   DROP INDEX \<имя индекса\> [, … n];

>   Пример. DROP INDEX IND_STUD;

С помощью команды DROP INDEX можно удалить один или несколько индексов только
текущей БД. При удалении индекса происходит освобождение всех страниц, которые
использовались для хранения данных индекса.

С помощью команды DROP INDEX нельзя удалить индексы из системных таблиц, а также
индексы, созданные сервером при определении ограничений целостности Primary Key
и Unique.

Команда ALTER INDEX используется для сопровождения индексов и не вносит никаких
изменений в их структуру.

Особенности работы с индексами
==============================

1.  После того, как был проведен анализ интенсивности использования данных и
    сделан вывод о том, какие столбцы должны быть проиндексированы, обычно
    приступают к созданию индексов. Создание индекса может быть выполнено
    непосредственно, или как часть другой, более сложной операции.

2.  Некластерные индексы приносят наибольший выигрыш в быстродействии, когда для
    индекса характерен высокий уровень селективности (selectivity). Практика
    показывает, что если уровень уникальности в индексируемом столбце меньше
    90-95 %, то использование некластерных индексов вообще нецелесообразно из-
    за большого числа отдельных физических операций чтения при поиске.

3.  Кластерные индексы значительно меньше зависят от селективности, так как,
    когда сервер доберется до начала требуемого интервала, то независимо от
    процента уникальных значений, можно непосредственно начать извлекать данные,
    не прибегая к чтению дополнительных страниц индекса.

4.  Очень эффективно индексирование для столбца внешнего ключа при частом
    использовании операции объединения со слиянием (merge joins). Дело в том,
    что внешние ключи часто выступают в роли целевых объектов при выполнении
    объединения с таблицей, на которую они ссылаются. При объединении со
    слиянием, из каждой таблицы извлекаются строки и затем сравниваются между
    собой на предмет соответствия критерию объединения. Так как для обоих
    связанных столбцов существуют индексы в обеих таблицах, то процесс
    извлечения обеих строк выполняется чрезвычайно быстро.

5.  По умолчанию для первичного ключа (ограничение целостности Primary Key)
    сервер автоматически создает уникальный кластерный (Clustered) индекс (если
    в таблице уже не существует кластерный индекс). Однако поле первичного ключа
    может быть не самым лучшим претендентом на роль кластерного индекса.
    Пользователь может явно указать, что для первичного ключа должен быть создан
    некластерный индекс (Nonclustered).

CREATE TABLE MyTable (

>   Column1 int IDENTITY

>   PRIMARY KEY NONCLUSTERED,

>   Column2 int

)

1.  Уникальный индекс также автоматически создается при

определении в таблице ограничений целостности Unique [8 c.1030] (определение
альтернативного ключа). Индекс, используемый для обеспечения уникальности
столбца или группы столбцов, называется

первичным. Индексы, применяемые для ускорения работы запросов в неуникальных
столбцах, называются вторичными.

1.  Случайные индексы (индексы, создаваемые по случаю) – это индексы, которые
    создаются после ввода в действие ограничений (Primary Key и Unique). Для
    этого типа индексов не допускается применение любых опций, кроме [CLUSTERED
    \| NONCLUSTERED] и FILLFACTOR.

2.  Индекс любого типа может быть создан в процессе создания таблицы. В команде
    CREATE TABLE предусмотрены средства, позволяющие выполнить организацию
    индекса как часть процесса создания таблицы. При этом разрешается создание
    индекса как для одного, так и для нескольких столбцов. Индекс может быть
    создан уже после создания таблицы с помощью команды CREATE INDEX, специально
    предназначенной для этого.

3.  После создания кластерного индекса единственный способ его изменить – это
    выполнить его удаление и потом повторное построение. При этом потребуется
    операция пересортировки таблицы, которая является очень длительной и
    требующей много дисковой памяти. Для того чтобы выполнить пересортировку
    таблицы при изменении кластерного индекса суммарно понадобится в 2,2 раза
    больше дискового пространства, чем обычно занимает таблица (для
    одновременного хранения старого индекса, нового индекса, старой таблицы и
    рабочего пространства для хранения временной информации).

4.  Кластерные индексы лучше всего подходят для столбцов, участвующих в
    запросах:

-   с выражениями Between либо \<, \> - ранжированные запросы,

-   с параметрами Group by либо с агрегатными функциями Min, Max и Count
    (Кластерные индексы хорошо работают в этих случаях, так как при поиске
    выполняется переход непосредственно к физическим данным, последовательное
    чтение которых продолжается до достижения конца интервала.),

-   с параметром Order by на основе кластерного ключа

(данные уже физически отсортированы по полю кластерного индекса).

1.  Главное противопоказание для создания кластерного индекса – когда будет
    выполняться большое количество вставок непоследовательных данных.

2.  Добавление данных в некластерный индекс на основе кучи обычно выполняется
    быстрее, чем на основе кластерного ключа.

3.  Влияние порядка столбцов в индексе. Индекс будет использован, только если
    запрос начинается с первого столбца, входящего в индекс. Точное совпадение
    количества и порядка столбцов в запросе и в индексе не обязательно, но чем
    больше столбцов совпадает (по порядку), тем лучше.

4.  Индекс вообще будет проигнорирован, если первый столбец индекса не упомянут
    в параметрах Join, Order by и Where– запроса.

5.  При сопровождении индекса необходимо учитывать два вопроса:

-   разбиение страниц,

-   фрагментацию памяти файла данных БД (высокая фрагментация данных означает
    медленное чтение информации, но с другой стороны позволяет быстро добавлять
    новые данные).

1.  Кластерные индексы обычно являются более быстрыми, чем некластерные.

2.  Операция SELECT обычно выигрывает от применения индексов.

3.  Если столбец входит в состав выражения, то индекс не используется. Чтобы
    недопустить использования индекса в столбец включают в ничего не значащее
    выражение.

>   SELECT \* FROM STUDENT WHERE Id=34+0;

1.  Операции INSERT, DELETE и UPDATE (в операции UPDATE используется подход –
    сначала удаление, а потом вставка) замедляются при наличии индексов – в этих
    операциях выполняется дополнительная работа – вносятся изменения не только в
    данные, но и в индекс.

2.  Лучше создавать индексы на столбцах, которые имеют целочисленные, а не
    строковые значения. Совсем неудачно использовать для построения индексов
    столбцы с типом данных Float или Real (эти типы совершенно не подходят для
    первичных ключей). Строковые типы данных подходят для индексов, если
    соответствующие столбцы не велики по размеру, так как с ростом ширины
    столбца увеличиваются затраты на поддержание индекса. Нельзя строить индексы
    по типам данных Text и Image.

3.  Неудачно использовать для построения индексов столбцы с типом данных bit –
    SQL-сервер не будет использовать такой индекс для ускорения запроса.

>   Контрольные вопросы и задания

1.  Определение и назначение представления.

2.  Каков синтаксис создания (удаления) представления?

3.  Каковы особенности работы с представлениями базы данных?

4.  Какие типы представлений существуют и каковы их особенности?

5.  Каковы особенности хранения данных на MS SQL-сервере?

6.  Определение и назначение индекса.

7.  Какие виды индексов существуют в MS SQL-сервере?

8.  Каковы особенности кластерного индекса?

9.  Каковы особенности некластерного индекса?

10. На основании каких структур данных строятся индексы?

11. Каков синтаксис создания (удаления) индексов?

12. Какие параметры может иметь команда создания индекса?

13. Каковы достоинства и недостатки индексов?

Список вопросов
===============

| 1  | Определения, основные понятия и классификация БД.                                          |
|----|--------------------------------------------------------------------------------------------|
| 2  | Основные понятия реляционной модели данных.                                                |
| 3  | Отношения и их свойства. Домены.                                                           |
| 4  | Понятие ключа в отношении.                                                                 |
| 5  | Целостность данных.                                                                        |
| 6  | Типы связей между отношениями.                                                             |
| 7  | Функциональная зависимость в отношении.                                                    |
| 8  | Нормальные формы отношений.                                                                |
| 9  | Пример проектирования учебной БД.                                                          |
| 10 | Основные положения инфологической модели Баркера.                                          |
| 11 | Основные положения физической модели БД.                                                   |
| 12 | Бизнес-правила предметной области.                                                         |
| 13 | Основные понятия языка SQL.                                                                |
| 14 | SQL-оператор CREATE TABLE.                                                                 |
| 15 | SQL-оператор ALTER TABLE.                                                                  |
| 16 | SQL-оператор DROP TABLE.                                                                   |
| 17 | Вставка данных в БД.                                                                       |
| 18 | Модификация данных в БД.                                                                   |
| 19 | Удаление данных из БД.                                                                     |
| 20 | Общая форма SQL-оператора выборки данных SELECT.                                           |
| 21 | Предложение SELECT SQL-оператора выборки данных.                                           |
| 22 | Предложение FROM SQL-оператора выборки данных.                                             |
| 23 | Предложение WHERE SQL-оператора выборки данных.                                            |
| 24 | Предложение WHERE SQL-ОПЕРАТОРА выборки данных. Операторы IN, BETWEEN в предложении WHERE. |
| 25 | Предложение WHERE SQL-оператора выборки данных. Оператор LIKE в предложении WHERE.         |
| 26 | Предложение WHERE SQL-оператора выборки данных.                                            |
| 27 | Предложение GROUP BY SQL-оператора выборки данных.                                         |
| 28 | Предложение HAVING SQL-оператора выборки данных.                                           |
| 29 | Предложение ORDER BY SQL-оператора выборки данных.                                         |
| 30 | Объединение запросов с использованием предложения                                          |
| 31 | Многотабличные запросы (предложение JOIN).                                                 |
| 32 | Особенности хранения данных на MS SQL-сервере.                                             |

>   Оператор IS NULL в предложении WHERE.

>   UNION.

| 33 | Кластерный индекс и его структура.                       |
|----|----------------------------------------------------------|
| 34 | Некластерный индекс и его структура.                     |
| 35 | Синтаксис оператора создания индекса в БД. Использование |
| 36 | Понятие представления. Оператор создания представления.  |

>   индексов.

>   Использование представления.

Библиографический список
========================

>   Книги по теория баз данных:

1.  Дейт К. Введение в системы баз данных. – М.: Вильямс, 2001. – 1072 с.

2.  Коннолли Т. и др. Базы данных: проектирование, реализация и сопровождение. –
    М.: Вильямс, 2000. – 800 с.

3.  Гарсиа-Молина Г., Ульман Дж., Уидом Дж. Системы баз данных. Полный курс. –
    М.: Вильямс, 2004. – 1088 с.

4.  Грабер М. SQL. Справочное руководство. – М.: Лори, 2007. – 672

с.

1.  Селко Д. SQL для профессионалов. Программирование. – М.:

Лори, 2004. – 442 с.

1.  Соколов А.Ю. Проектирование баз данных. – Харьков, ХАИ, 2003. – 238 с.

>   Книги по MS SQL Server:

1.  Виейра Р. Программирование баз данных Microsoft SQL Server 2005 для
    профессионалов. – М.: Вильямс, 2008. – 1072 с.

2.  Браст Э.Дж., Форте С. Разработка приложений на основе Microsoft SQL Server
    2005. Мастер-класс. – М.: Русская Редакция, 2007. – 880 с.

3.  Гандерлой М., Джорден Дж., Чанц Д. Освоение Microsoft SQL Server 2005. – М.:
    Вильямс, 2007. – 1104 с.

>   10. Нильсен П. Microsoft SQL Server 2005. Библия пользователя. —

М.: Вильямс, 2008. — 1232 с.

>   Книги по ADO.NET:

11. Сеппа Д. Microsoft ADO.NET. — М.: Русская Редакция, 2003. – 640 с.

12. Малик С. Microsoft ADO.NET 2.0 для профессионалов. — М.: Вильямс, 2006. —
560 с.

>   13. Троелсен Э. Язык программирования C \# и платформа .NET 2.0.

– М.: Вильямс, 2007. – 1168 с.

14. Нейгел К., Ивьен Б., Уотсон К. и др. С\# 2005 для профессионалов. – М.:
Вильямс, 2006. – 1376 с.

Приложение А. Типы данных MS SQL Server
=======================================

В таблице А.1 приведены основные типы данных MS SQL Server.

>   Таблица А.1 – Основные типы данных MS SQL Server

| Наименование                                            | Описание                                                                                                                                                                                                                                                                                                                                                                                                            |
|---------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1. Целочисленные типы                                   |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| bit                                                     | Столбец с типом данных bit может хранить значения 1, 0 или Null (Null - маркер, указывающий серверу БД на неизвестность значения). Тип удобно использовать в качестве двоичного индикатора состояния – on/off, yes/no, true/false.                                                                                                                                                                                  |
| tinyint                                                 | Столбец с типом данных tinyint может хранить значения от 0 до 255 или Null. Тип данных занимает 1 байт памяти.                                                                                                                                                                                                                                                                                                      |
| smallint                                                | Столбец с типом данных smallint может хранить значения от -32768 (-215) до 32767 (215-1) либо Null. Для хранения данных используется 2 байта памяти.                                                                                                                                                                                                                                                                |
| int                                                     | Целочисленный тип данных, допускающий значения в диапазоне от -231 (-2147483648) до 231-1 (2147483647) либо Null. Для хранения данных используется 4 байта памяти.                                                                                                                                                                                                                                                  |
| biqint                                                  | Целочисленный тип данных, допускающий значения в диапазоне от -263 (- 9223372036854775808) до 263-1 (9223372036854775807) либо Null. Для хранения данных используется 8 байта памяти.                                                                                                                                                                                                                               |
| 2. Текстовые данные                                     |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| char                                                    | Столбец с типом данных char содержит фиксированное число символов, не относящихся к кодовой таблице Unicode. Столбец char(30) всегда будет хранить 30 символов и занимать 30 байт, даже если столбцу присвоена строка меньшей длины. Максимальный размер столбца char – 8000 символов. Применяется для хранения текстовых данных, всегда имеющих одну и туже длину, таких как почтовый индекс или номер автомобиля. |
| varchar                                                 | Столбец с типом данных varchar предназначен для хранения строковых данных переменной                                                                                                                                                                                                                                                                                                                                |
|                                                         | длины, не относящихся к кодовой таблице Unicode. Максимальный размер строки varchar – 8000 символов. В поле типа varchar(10) может храниться максимум 10 символов, однако если строка будет иметь 5 символов, то под нее будет выделено 5 байт памяти.                                                                                                                                                              |
| varchar(max)                                            | Может хранить до 231 символов (до 2 Гбайт данных), в остальном аналогичен типу varchar.                                                                                                                                                                                                                                                                                                                             |
| nchar                                                   | Столбец с типом данных nchar содержит фиксированное число символов таблицы Unicode. Столбец char(30) всегда будет хранить 30 символов и занимать 30 байт, даже если столбцу присвоена строка меньшей длины. Максимальный размер столбца char – 4000 символов, 1 символ Unicode занимает 2 байта. Применяется для хранения небольших фрагментов текста.                                                              |
| nvarchar                                                | Столбец с типом данных nvarchar предназначен для хранения строковых данных переменной длины таблицы Unicode. Максимальный размер столбца nvarchar – 4000 символов.                                                                                                                                                                                                                                                  |
| nvarchar(max)                                           | Может хранить до 230 символов (до 2 Гбайт данных), в остальном аналогичен типу nvarchar.                                                                                                                                                                                                                                                                                                                            |
| 3. Десятичные данные                                    |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| decimal                                                 | Этот формат используется для хранения дробных чисел. Диапазон значений -1038-1 от до 1038-1. Эти данные содержат два параметра: точность и масштаб. Точность – общее количество цифр, которое может храниться в поле. Масштаб - количество цифр справа от десятичной точки. 222.11 – точность равна 5, а масштаб равен 2.                                                                                           |
| numeric                                                 | Точный аналог типа decimal, различий между ними нет.                                                                                                                                                                                                                                                                                                                                                                |
| 4. Данные с плавающей точкой                            |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| float                                                   | Столбец с типом данных float может хранить данные в диапазоне от -1,79\*10308 до 1,79\*10308, если столбец описан с максимально возможной точностью. При описании данных типа float задается количество битов, используемых для хранения числа, и, соответственно, точность, которая может находиться в диапазоне от 1 до 53. Столбец типа float(53) хранит данные с плавающей точкой с максимально возможной       |
|                                                         | точностью.                                                                                                                                                                                                                                                                                                                                                                                                          |
| real                                                    | Столбец с типом данных real является синонимом типа float(24). Столбец с типом данных real может хранить данные в диапазоне от -3,4\*1038 до 3,4\*1038,                                                                                                                                                                                                                                                             |
| 5. Денежные типы данных                                 |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| smallmoney                                              | Этот тип предназначен для хранения денежных данных от -214748,3648 до 214748,3647 с точностью до одной десятитысячной. Занимает 4 байта.                                                                                                                                                                                                                                                                            |
| money                                                   | Этот тип предназначен для хранения денежных данных от -1063 до 1063-1 с точностью до одной десятитысячной. Занимает 8 байт.                                                                                                                                                                                                                                                                                         |
| 6. Типы данных даты и времени                           |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| smalldatetime                                           | Этот тип предназначен для хранения дат с 1 января 1900 и заканчивая 9 июня 2079 с точностью до 1 минуты.                                                                                                                                                                                                                                                                                                            |
| datetime                                                | Столбец, описанный с использованием типа datetime, может хранить даты с 1 января 1753 и заканчивая 31 декабря 9999 с точностью до 3,33 мс.                                                                                                                                                                                                                                                                          |
| 7. Двоичные типы данных                                 |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| binary                                                  | Столбец типа binary может хранить до 8000 байт двоичных данных. Размер столбца всегда указывается явным образом, например, binary (100). Двоичные столбцы дополняются пробелами, так что они всегда хранят точное количество байт, определенное для столбца.                                                                                                                                                        |
| varbinary                                               | Столбец типа varbinary хранит двоичные данные с переменной длиной вплоть до заданного размера, тип ограничен 8000 байтами. Столбец varbinary(12) может хранить любое число байт данных в диапазоне от 1 до 12.                                                                                                                                                                                                      |
| varbinary(max)                                          | Тип данных может хранить до 231 байт данных (до 2 Гбайт данных), в остальном аналогичен типу varbinary.                                                                                                                                                                                                                                                                                                             |
| 8. Специализированные типы данных                       |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| cursor                                                  | Используется для описания результатов работы хранимых процедур или инструкций SQL, которые возвращают указатель на набор записей.                                                                                                                                                                                                                                                                                   |
| sql_variant                                             | Тип данных sql_variant является заменителем любого другого типа, за исключением varchar(max), nvarchar(max), timestamp. Столбец                                                                                                                                                                                                                                                                                     |
|                                                         | типа sql_variant может в одних строках хранить целочисленные данные, а в других – строках той же таблица данные типа varchar. Данные этого типа обрабатываются медленнее, чем простые типы данных.                                                                                                                                                                                                                  |
| table                                                   | Тип данных table используется для временного хранения результата работы функции, хранимой процедуры или пакета.                                                                                                                                                                                                                                                                                                     |
| timestamp                                               | Тип timestamp представляет собой 8-битный двоичный столбец, который хранит уникальное значение, генерируемое SQL Server. Тип timestamp полезен при выявлении изменений, внесенных в данные другим пользователем, в то время как выработаете с этими данными.                                                                                                                                                        |
| uniqueidentifier                                        | Столбец типа uniqueidentifier может хранить глобальные уникальные идентификаторы.                                                                                                                                                                                                                                                                                                                                   |
| xml                                                     | Тип xml предназначен для хранения целого документа Xml, вместе с разметкой. Обеспечивает проверку данных по схеме Xml и применение специальных функций, предназначенных для обработки кода Xml.                                                                                                                                                                                                                     |
| 9. Типы, поддерживаемые для обеспечения совместимости с |                                                                                                                                                                                                                                                                                                                                                                                                                     |
| text                                                    | Может хранить до 231 символов (до 2 Гбайт данных), обладает переменной длиной. Вместо этого типа следует использовать тип данных varchar(max).                                                                                                                                                                                                                                                                      |
| ntext                                                   | Может хранить до 230 символов переменной длины таблицы Unicode (до 2 Гбайт данных). Вместо этого типа следует использовать тип данных nvarchar(max).                                                                                                                                                                                                                                                                |
| image                                                   | Столбец типа image хранит двоичные данные (binary) с переменной длиной. Вместо этого типа следует использовать тип данных varbinary(max).                                                                                                                                                                                                                                                                           |

>   предыдущими версиями MS SQL Server
