---
title: "Лекция 10. Формирование многотабличных запросов"
layout: bookpage
lang: ru
navigation_weight: 10
---

# Лекция 10. Формирование многотабличных запросов

Современные БД обычно являются нормализованными – данные распределяются по многочисленным небольшим таблицам в целях устранения повторяющихся данных, сокращения объема занимаемой памяти, повышения производительности и обеспечения целостности данных. Однако практически всегда требуется извлекать данные из нескольких таблиц. Объединение (соединение, многотабличный запрос) полностью предназначено для обеспечения выборки данных из нескольких таблиц и включения этих данных в один результирующих набор.

Одна из наиболее важных черт запросов SQL состоит в их способности определять связи между множеством таблиц и отображать содержащуюся в них информацию в терминах этих связей. Операция такого рода называется объединением (соединением) и является одной из самых мощных операцией для реляционных БД. С помощью соединений непосредственно связывается информация, содержащаяся:

- в нескольких таблицах,
- между отдельными частями одной таблицы.

В многотабличном запросе при операции объединения в предложении FROM имена таблиц перечисляются через запятую.

Объединение таблиц может быть выполнено тремя способами:

- с использованием предложения UNION (объединение, союз),

-с помощью установления связей между таблицами в предикате запроса (в условии, организованном предложением WHERE),

-с помощью оператора объединения JOIN.

Второй способ объединения таблиц называется внутренним объединением (соединением), которое возвращает только те строки, для которых условие объединения принимает значение True. Таблицы, участвующие во внутреннем объединении, равноправны.

С помощью конструкции Join реализуется внутреннее и внешнее объединения.

## 10.1 Предложение UNION

Предложение UNION используется для:

- размещения нескольких запросов вместе,
- объединения их вывода.

Предложение	UNION	объединяет	вывод	двух или	более запросов в единый набор строк и столбцов.

Пример. Получить список всех студентов и преподавателей, фамилии которых заключены между буквами ‘K’ и ‘C’.

```sql
SELECT SFAM AS ‘Фамилия’, SIMA AS ‘Имя’ FROM STUDENT
WHERE SFAM BETWEEN ‘K’ AND ‘C’ UNION
SELECT TFAM, TIMA FROM TEARCHER
WHERE TFAM BETWEEN ‘K’ AND ‘C’
```

Особенности вывода:

1. в MS SQL Server заголовок столбцов формируется первым запросом,
2. при объединении столбцы должны быть совместимы для объединения, то есть необходимость включения в запросе одинакового числа столбцов в одинаковом порядке, должна присутствовать совместимость типов, если пустые значения NULL запрещены в каком-либо столбце объединения, то они должны быть запрещены и во всех остальных столбцах,
3. предложение UNION автоматически исключает дубликаты строк из вывода,
4. можно вставлять константы и выражения в предложение UNION (должна быть совместимость констант и выражений)

```sql
SELECT ‘Студент ’ AS ‘Таблица’, SFAM AS ‘Фамилия’, SIMA AS ‘Имя’ FROM STUDENT
UNION
SELECT ‘Преподаватель’, TFAM, TIMA FROM TEARCHER
```

Если не будет псевдонима у ‘Студент ’, то SQL Server присвоит этому столбцу имя No column name.

5. предложение ORDER BY применяется и для упорядочения выходных данных объединения. Задание упорядочения осуществляется по номеру столбца.

```sql
SELECT ‘Студент ’, SFAM, SIMA FROM STUDENT UNION
SELECT ‘Преподаватель’, TFAM, TIMA FROM TEARCHER ORDER BY 2 ASC
```

В данном примере выполнено упорядочивание по возрастанию по значениям полей SFAM и TFAM.

Можно упорядочить выходные данные в соответствии со значениями одного или нескольких полей: для каждого из полей независимо по возрастанию или убыванию (ASC или DESC), как это делалось для выходных данных одного запроса. Число 2 в предложении ORDER BY задаёт номер столбца в упорядоченном списке предложения SELECT.

6. Если объединение выполняется более чем для двух запросов, то для упорядочения вычислений нужно использовать круглые скобки (круглые скобки могут определять порядок устранения дубликат).

Иначе говоря, вместо того, чтобы задать 

```sql
query X UNION query Y UNION query Z; необходимо конкретизировать
либо (query X UNION query Y) UNION query Z;
либо query X UNION (query Y UNION query Z);
```
Это необходимо, потому что UNION и UNION ALL можно комбинировать для исключения одних дубликатов без устранения других. Предложение `(query X UNION ALL query Y) UNION query Z`;
не обязательно генерирует те же выходные данные, что и предложение `query X UNION ALL (query Y UNION query Z)`; если имеются дубликаты строк, подлежащие исключению из выходных данных.

## 10.2. Внутреннее объединение таблиц

1. Объединение двух таблиц с помощью установления связей. 

Пример. Выбрать из таблиц Teacher (id (код_преподавателя - первичный ключ), name (имя_преподавателя), id_dep (код_кафедры)) и Subject (id (код_предмета), name (имя_предмета), id_Teach (код_преподавателя - внешний ключ)) информацию о преподавателях (ФИО) и дисциплинах (Предмет), которые преподаватель ведет.

```sql
SELECT T. Name AS ‘ФИО’, S. Name AS ‘Предмет’ FROM Teacher T, Subject S
WHERE T.id=S.id_Teach
```

Пусть id – первичный ключ таблицы предка Teacher, а id_Teach – внешний ключ таблицы потомка Subject. Между таблицами Teacher и Subject используется связь между полями id и id_Teach. Такое объединение таблиц называется объединением посредством отношения предок /потомок. В этом случае между таблицами создается отношение ”один-ко-многим”.

SQL не требует, чтобы связываемые столбцы двух (или более) таблиц обязательно представляли собой пару “первичный ключ – внешний ключ”. Любые два столбца из двух таблиц могут быть связанными столбцами, если только они имеют сравнимые типы данных. Такие столбцы создают между таблицами отношение ”многие-ко-многим”.

При выполнении многотабличного запроса SQL исследует каждую комбинацию строк двух или более возможных таблиц и проверяет эти комбинации по их предикатам. Если комбинация значений строк дает такое значение, которое делает предикат истинным, то из комбинации этих строк будут выбраны значения для вывода.

Объединение, использующее предикаты, основанные на равенствах, называется эквиобъединением (объединением по равенству). Эквиобъединения являются, по-видимому, наиболее распространенным типом объединения, но существуют и другие. Фактически в объединении можно использовать любой оператор сравнения.

2. Объединение трёх таблиц.

Пример. Вывести список оценок, выставленных тем или иным преподавателем в виде таблицы с полями (ФИО, Предмет, Оценка). Пусть существуют таблицы Teacher (id (код_преподавателя), Name (имя_преподавателя), id_dep (код_кафедры)), Subject (id (код_предмета),	Name	(имя_предмета),	id_Teach (код_преподавателя)) и Usp (id, Num (зачетка), Ocenka (оценка), id_Pred (код_предмета), Date).

```sql
SELECT T. Name AS ‘ФИО’, S. Name AS ‘Предмет’, U. Ocenka AS ‘Оценка’
FROM Teacher T, Subject S, Usp U
WHERE T.id=S.id_Teach AND S.id= U.id_Pred
```

Здесь выполнен запрос, объединяющий три таблицы – Teacher, Subject и Usp.
Таким образом, объединение позволяет сделать сложные сравнения между любыми полями любого числа таблиц и использовать полученные результаты для того, чтобы решать – какую информацию хотелось бы видеть.

3. Объединение двух (или более) копий одиночной таблицы (самосоединение, тета-соединение или рефлексивное соединение)

Объединение таблицы с ее же копией означает следующее – любую строку таблицы (одну в каждый момент времени) можно комбинировать с ее копией и с любой другой строкой этой же таблицы. Каждая такая комбинация оценивается в терминах предиката, как и в случае соединения нескольких различных таблиц. Это позволяет легко создавать определенные виды связей между различными записями внутри единственной таблицы – например, осуществлять поиск пар строк с общим значением поля.

Объединение таблицы со своей копией можно представить себе следующим образом – реально копия таблицы не создаётся, но SQL выполняет команду так, как будто бы делалось именно это. Данный тип объединения не отличается от обычного соединения двух таблиц, за исключением того, что в данном случае таблицы идентичны.

При объединении таблицы со своей копией для ссылки к столбцам необходимо иметь два различных имени для одной и той же таблицы, что делается с помощью временных имен – псевдонимов, определяемых в предложении FROM.

Пример. Определить студентов, имеющих одинаковые стипендии.

```sql
SELECT First. Name, Second. Name, First. Stip FROM Student First, Student Second WHERE First. Stip = Second. Stip
```

Результат такого запроса будет иметь вид:

| Name   | Name   | Stip |
|--------|--------|------|
| Серов  | Серов  | 500  |
| Серов  | Иванов | 500  |
| …      | …      | ...  |
| Иванов | Серов  | 500  |
| Иванов | Иванов | 500  |

В данном примере SQL ведет себя так, как если бы он соединял две различные таблицы с именами First и Second, то есть псевдонимы разрешают одной и той же таблице быть обработанной независимо.

Логика этого запроса такова – из таблицы Student выбирается очередная строка и запоминается под первым псевдонимом. После этого SQL начнет проверять ее в комбинации с каждой строкой таблицы Student под вторым псевдонимом. Если комбинация строк удовлетворяет предикату, то соответствующие поля из нее выбираются для вывода.

Особенности работы с псевдонимами:

-псевдонимы могут использоваться в предложении SELECT до их объявления в предложении FROM,
псевдонимы таблиц могут совпадать с именами таблиц,

-допускается использование любого числа псевдонимов для одной таблицы в запросе (хотя более двух псевдонимов в запросе – излишество),

-SQL отклонит запрос, если используемые псевдонимы далее не будут определены в предложении FROM,
в предложении SELECT допускается не использовать каждый псевдоним или таблицу, которые упоминались в предложении FROM запроса,

-в одном запросе нельзя смешивать использование написания имен таблиц и псевдонимов,

-псевдоним существует только во время выполнения команды, а после завершения запроса псевдонимы запроса больше не имеют никакого значения,

-псевдонимы используются для упрощения записи при длинных и сложных именах таблиц и для минимизации синтаксических ошибок.

Недостаток данного запроса – вывод имеет два значения для каждой комбинации фамилий, причем второй раз в обратном порядке

– это связано с тем, что текущее значение в первом псевдониме сначала выбирается в комбинации со значением во втором псевдониме, а затем наоборот, кроме того каждая строка сравнена сама с собой – например, Серов с Серовым.

Способ устранения данного недостатка – наложение условия порядка на два значения так, чтобы одно значение могло быть меньше второго или предшествовало ему в алфавитном порядке. Это сделает предикат ассиметричным относительно связи, поэтому те же самые значения в обратном порядке не будут выбраны снова.

Поэтому предыдущий запрос нужно модифицировать таким образом:

```sql
SELECT First. Name, Second. Name, First. Stip FROM Student First, Student Second WHERE First.Stip=Second. Stip
AND First. Name < Second. Name
```

Результат такого запроса имеет вид:

| …      | …     | …   |
|--------|-------|-----|
| Иванов | Серов | 100 |
| …      | …     | …   |

В частности, Иванов предшествует Серову в алфавитном порядке, поэтому комбинация удовлетворяет обоим условиям и появляется в выводе. Для комбинации “Серов – Иванов”, как и для – “Серов – Серов” второе условие запроса не выполняется. Если же есть необходимость оставить в выводе запроса комбинацию вида “Серов – Серов”, то в запросе следует использовать сравнение вида <= вместо <.

В SQL разрешается создание объединения, которое включает псевдонимы одиночной таблицы и различные таблицы.

Таким образом, операция объединения соединяет информацию из двух (или более) таблиц (одинаковых или разных), формируя пары связанных строк из них. Объединенную таблицу образуют пары тех строк из различных таблиц, у которых в связанных столбцах содержатся одинаковые значения.

## 10.3. Конструкция Join

С помощью конструкции Join реализуется внутреннее (Inner Join или просто Join) и внешнее (Left | Right | Full Outer | Cross Join) объединения.

Внешнее объединение возвращает все строки из одной таблицы (главной) и только те строки из другой таблицы (подчиненной), для которых условие объединения принимает значение True. Строки второй таблицы, не удовлетворяющие условию объединения (то есть имеющие значение False), получают значение Null и в результирующем наборе не выводятся.

В стандарте ANSI SQL-92 условия объединения (соединения) записываются в предложении From в соответствии со следующим синтаксисом –

```sql
From <таблица> [ Inner | Left | Right | Full Outer | Cross ] Join <
таблица > On <условие поиска>
```

(в ‘условиях поиска’ могут быть заданы любые критерии сравнения строк двух объединяемых таблиц, в том числе с использованием булевских операторов).

Все разновидности конструкции Join имеют одну общую отличительную особенность, а именно – в них одна строка согласуется с одной или несколькими другими строками для получения результирующей строки, представляющей собой надмножество, созданное путем соединения полей из нескольких строк.

В соединении различаются стороны – левая и правая. Левой считается таблица, указанная в предложении From первой, а правой – таблица, указанная второй.

Конструкция Inner Join реализует внутреннее объединение и возвращает строки, согласованные по всем полям, которые обозначены как используемые для соединения. Внутреннее соединение является исключительным, т.е. любая строка, для которой нет соответствия в обеих таблицах, неизбежно исключается из окончательного варианта результирующего набора.

Существует четыре вида внешнего объединения:

- левое внешнее объединение (Left Join) – запрос возвращает все строки из левой таблицы и только те из правой таблицы, которые удовлетворяют условию соединения (строки правой таблицы, не удовлетворяющие условию объединения, получают значение Null и в результирующем наборе не выводятся),

- правое внешнее объединение (Right Join) – все наоборот по отношению к левому внешнему объединению,

- полное внешнее объединение (Full Outer Join) – запрос возвращает все строки и левой и правой таблиц, но в особом порядке,

- перекрестное объединение (Cross Join) – запрос возвращает все строки левой таблицы и первую строку правой таблиц, все строки левой таблицы и вторую строку правой таблиц, и так далее.

| T1     |        |
|--------|--------|
| Name   | City   |
| Masha  | Kharkov|
| Katja  | Kiev   |
| Lena   | Kursk  |
| Lena   | Kharkov| 

| T2     |        |
|--------|--------|
| Name   | City   |
| Petja  | Kiev   |
| Lesha  | Kharkov|
| Vitja  | Poltava|

Пример.	Пусть	в	БД	используются	две	таблицы	Т1	и	Т2 следующего вида:

(pic)

Необходимо выбрать поставщиков, проживающих в одних и тех же городах.

1. Запрос,	реализующий	внутреннее	объединение	в	стандарте
SQL-89 имеет вид:

	```sql
	Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
	From T1, T2
	Where T1.city=T2.city;
	```

	Результат такого запроса имеет вид:

	| Имя1  | Город1  | Имя2  | Город2  |
	|-------|---------|-------|---------|
	| Masha | Kharkov | Lesha | Kharkov |
	| Katja | Kiev    | Petja | Kiev    |
	| Lena  | Kharkov | Lesha | Kharkov |

2. Запрос, реализующий внутреннее объединение в стандарте SQL-92 имеет вид (стандарт SQL-92 допускает использование синтаксиса стандарта SQL-89):
```sql
Select T1.name 'Имя1', T1.city 'Город1',T2.name 'Имя2',T2.city 'Город2' From T1 Inner Join T2 -- аналогичный результат без Inner
On T1.city=T2.city
```
Естественно, что вывод этого запроса аналогичен выводу по п. 1.
3. Запрос, реализующий внутреннее объединение между частями одной таблицы – определить имена работников, живущих в одном и том же городе и этот город:
```sql
SELECT T1.Name,T1.City,T2.Name,T2.City FROM T1 INNER JOIN T1 T2
ON (T1.City=T2.City) And (T1.Name>T2.Name)
```
4. Запрос, реализующий левое внешнее объединение в стандарте
SQL-92 имеет вид:

	```sql
	Select T1.name as ‘Имя1’, T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
	From T1 Left Join T2 On T1.city=T2.city;
	```
	Результат такого запроса имеет вид:

	| Имя1  | Город1  | Имя2  | Город2  | 
	|-------|---------|-------|---------|
	| Masha | Kharkov | Lesha | Kharkov |
	| Katja | Kiev    | Petja | Kiev    |
	| Lena  | Kursk   | Null  | Null    |
	| Lena  | Kharkov | Lesha | Kharkov | 

	Вместо отсутствующих данных подставляется Null–значение.

5. Запрос, реализующий правое внешнее объединение в стандарте
SQL-92 имеет вид:
	```sql
	Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
	From T1 Right Join T2
	On T1.city=T2.city And not (T1.city=’Kiev’) Order by 3
	```
	Результат такого запроса имеет вид:

	| Имя1  | Город1  | Имя2  | Город2  |
	|-------|---------|-------|---------|
	| Katja | Kiev    | Petja | Kiev    |
	| Masha | Kharkov | Lesha | Kharkov |
	| Lena  | Kharkov | Lesha | Kharkov |
	| Null  | Null    | Vitja | Poltava |

6. Запрос, реализующий правое внешнее объединение в стандарте
SQL-92 с дополнительным условием имеет вид:
	```sql
	Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
	From T1 Right Join T2
	On T1.city=T2.city And not (T1.city=’Kiev’) Order by 3
	```
	Результат такого запроса имеет вид:

	| Имя1  | Город1  | Имя2  | Город2  |
	|-------|---------|-------|---------|
	| Masha | Kharkov | Lesha | Kharkov |
	| Lena  | Kharkov | Lesha | Kharkov |
	| Null  | Null    | Petja | Kiev    |
	| Null  | Null    | Vitja | Poltava |

7. Запрос, реализующий полное внешнее объединение (в результат должны быть включены все строки с обеих сторон соединения) в стандарте SQL-92 с имеет вид:
	```sql
	Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
	From T1 Full Outer Join T2 On T1.city=T2.city
	```
	Результат такого запроса имеет вид:

	| Имя1  | Город1  | Имя2  | Город2  |
	|-------|---------|-------|---------|
	| Masha | Kharkov | Lesha | Kharkov |
	| Katja | Kiev    | Petja | Kiev    |
	| Lena  | Kursk   | Null  | Null    |
	| Lena  | Kharkov | Lesha | Kharkov |
	| Null  | Null    | Vitja | Poltava |

	Полное внешнее объединение является своего рода результатом совместного применения левого и правого объединений.

8. Запрос, реализующий перекрестное объединение имеет вид:
```sql
Select T1.name as ‘Имя1’,T1.city as ‘Город1’,T2.name as ‘Имя2’,T2.city as ‘Город2’
From T1 Cross Join T2
```
Результат такого запроса имеет вид:

| Имя1  | Город1  | Имя2  | Город2  |
|-------|---------|-------|---------|
| Masha | Kharkov | Petja | Kiev    |
| Katja | Kiev    | Petja | Kiev    |
| Lena  | Kursk   | Petja | Kiev    |
| Lena  | Kharkov | Petja | Kiev    |
| Masha | Kharkov | Lesha | Kharkov |
| Katja | Kiev    | Lesha | Kharkov |
| Lena  | Kursk   | Lesha | Kharkov |
| Lena  | Kharkov | Lesha | Kharkov |
| Masha | Kharkov | Vitja | Poltava |
| Katja | Kiev    | Vitja | Poltava |
| Lena  | Kursk   | Vitja | Poltava |
| Lena  | Kharkov | Vitja | Poltava |

Объединение Cross Join характеризуется отсутствием операции On.

## 10.4. Функции SQL

Современные СУБД содержат ряд встроенных функций, которые позволяют выполнять различные операции над данными, извлекаемыми из таблиц. Такие функции могут быть частью SQL- выражения и позволяют переложить часть работы по обработке данных на сервер СУБД.

Предположим, что результат, который мы хотим видеть на экране формируется путем получения синуса над хранящемся значением. Можно извлечь данные из таблицы и затем выполнить на клиентском компьютере операцию синус. Однако, нет никакой необходимости это делать, потому что в SQL-операторе SELECT вместо имени поля можно поставить SQL-выражение “SIN(имя_поля)” и сразу получить требуемые значения.

Все SQL-функции разделяются на функции двух типов:

- скалярные - предназначены для обработки одного данного;

- агрегатные - предназначены для обработки множества данных. 

Скалярные функции разделяются на:

1. Функции работы с числами.
2. Функции работы с символами.
3. Функции работы с датой и временем.
4. Функции явного преобразования типов данных.
5. Функции для шифрования/дешифрования данных.
6. Остальные.

В таблице 10.1 перечислены основные категории функций MS SQL Server.

Таблица 10.1 – Категории функций MS SQL Server

| №  | Категория                        | Содержимое                                                                                                                                                |
|----|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1  | Математические функции           | Предназначены для выполнения математических выражений.                                                                                                    |
| 2  | Функции даты и времени           | Предназначены для управления                                                                                                                              |
| 3  | Строковые функции                | Предназначены для управления текстовыми данными.                                                                                                          |
| 4  | Функции агрегирования            | Предназначены для вычисления единственного числа, основываясь на всех значениях в столбце (AVG, COUNT, COUNT_BIG, GROUPING, MAX, MIN, STDEV, STDEVP, SUM, |
| 5  | Функции курсора                  | Возвращают информацию о курсоре                                                                                                                           |
| 6  | Функции метаданных               | Возвращают информацию об объектах БД.                                                                                                                     |
| 7  | Функции конфигурирования         | Возвращают информацию о                                                                                                                                   |
| 8  | Функции безопасности             | Возвращают информацию о пользователях и ролях.                                                                                                            |
| 9  | Функции шифрования/дешифрования  | Предназначены для шифрования и                                                                                                                            |
| 10 | Системные функции                | Функции для управления объектами на низком уровне.                                                                                                        |
| 11 | Функции для текста и изображений | Функции для работы с большими                                                                                                                             |

### Математические функции

В таблице 10.2 перечислены основные математические функции MS SQL Server.

Таблица 10.2 – Математические функции

| ABS(n)      | Возвращает абсолютное значение n                         |
|-------------|----------------------------------------------------------|
| ACOS(n)     | Возвращает арккосинус n                                  |
| ATAN(n)     | Арктангенс n                                             |
| ATN2        | Арктангенс угла, описанного двумя углами                 |
| CEILING(n)  | Ближайшее целое, превышающее n                           |
| COS(n)      | Косинус n                                                |
| COТ(n)      | Котангенс угла n                                         |
| DEGREES     | Преобразование радиан в градусы                          |
| EXP(n)      | Экспонента n                                             |
| FLOOR(n)    | Ближайшее целое, меньшее n                               |
| LOG         | Логарифм по основанию 2                                  |
| LOG10       | Логарифм по основанию 10                                 |
| PI          | Константа Pi                                             |
| POWER(m, n) | Возвращает m в степени n                                 |
| RADIANS     | Преобразование градусов в радианы                        |
| RAND        | Генератор случайных чисел                                |
| ROUND       | Округление чисел с плавающей точкой до заданной точности |
| SIGN        | Возвращает знак выражения                                |
| SIN(n)      | Синус n                                                  |
| SQRT(n)     | Корень квадратный от n                                   |
| SQUARE      | Возведение в квадрат                                     |
| TAN(n)      | Тангенс n                                                |

### Функции агрегирования

Агрегатные функции SQL (таблица 10.3), предназначены для выполнения действий над множеством значений, которые группируются клаузой GROUP BY SQL-оператора SELECT. Результатом работы функции является одно значение, которое получилось в результате обработки множества. Все функции за исключением одной не учитывают в своей работе поля со значением NULL и имеют общую форму представления:
```sql
имя_функции ([DISTINCT | ALL] выражение)
```
По умолчанию перед выражением стоит клауза ALL, которая говорит, что в обработку попадают все значения множества. Клауза DISTINCT позволяет удалить из обработки повторяющиеся значения.

Таблица 10.3 – Функции агрегирования (агрегатные функции)

| Функция   | Назначение                                                                                                                                                                                                                                                                                                                                                                                                 |
|-----------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| AVG       | AVG([ALL\|DISTINCT]\<expression\>) Функция AVG возвращает среднее арифметическое значений, представленных в параметре \<expression\>. Параметр expression должен содержать числовые значения. NULL–значения игнорируются.                                                                                                                                                                                  |
| COUNT     | COUNT([ALL\|DISTINCT]\<expression\>\|\*) Функция COUNT возвращает данные типа int о количестве элементов, представленных в параметре \<expression\>. Параметр не может относиться к типу данных uniqueidentifier, text, ntext или image. При использовании значения параметра \* происходит возврат данных о количестве строк в таблице, при этом дублирующие значения или NULL– значениея не исключаются. |
| COUNT_BIG | COUNT_BIG([ALL\|DISTINCT]\<expression\>\|\*) Возвращает данные о количестве элементов в группе. Аналогична функции COUNT, но возвращаемое значение имеет тип данных biqint.                                                                                                                                                                                                                                |
| GROUPING  | GROUPING(\<column_name\>) Функция GROUPING добавляет дополнительный столбец к выводу оператора SELECT. Функция GROUPING используется только в списке выборки. Ее параметром является столбец \<column_name\>), который используется в конструкции GROUP BY и в котором должно быть проверено наличие NULL–значений.                                                                                        |
| MAX       | MAX([ALL\|DISTINCT]\<expression\>) Функция MAX возвращает максимальное из значений, представленных в параметре \<expression\>. При вычислении функции MAX все NULL–значения игнорируются.                                                                                                                                                                                                                  |
| MIN       | MIN([ALL\|DISTINCT]\<expression\>) Функция MIN возвращает минимальное из значений, представленных в параметре \<expression\>. При вычислении функции MIN все NULL–значения игнорируются.                                                                                                                                                                                                                   |
| STDEV     | STDEV(\<expression\>) Функция STDEV возвращает результат                                                                                                                                                                                                                                                                                                                                                   |
|           | вычисления среднеквадратического отклонения по всем значениям, представленным в параметре \<expression\>. При вычислении функции STDEV все NULL– значения игнорируются.                                                                                                                                                                                                                                    |
| SUM       | SUM([ALL\|DISTINCT]\<expression\>) Функция SUM возвращает сумму всех значений, представленных в параметре \<expression\>. При вычислении функции SUM все NULL–значения игнорируются.                                                                                                                                                                                                                       |
| VAR       | VAR(\<expression\>) Функция VAR возвращает результат вычисления дисперсии по всем значениям, представленным в параметре \<expression\>. При вычислении функции VAR все NULL– значения игнорируются.                                                                                                                                                                                                        |

Особенности запросов с агрегатными функциями:

1. С функциями SUM и AVG используются только числовые поля, а с COUNT, MAX и MIN могут использоваться числовые или символьные поля.

2. Функция COUNT(\*) считает количество значений в столбце или число строк в таблице.
Пример.	Посчитать	число	студентов,	сдавших	учебные предметы.
```sql
SELECT COUNT(DISTINCT Id_Stud) FROM USP
Пример. Посчитать общее количество строк в таблице USP. SELECT COUNT(*) FROM USP
COUNT(*) включает записи с NULL значениями, а также дубликаты, по этой причине DISTINCT в данном случае не может быть использован.
```
Пример. Посчитать количество не-NULL значений в поле Id_Predm таблицы USP (аргумент ALL означает – “включать дубликаты”).
```sql
SELECT COUNT(ALL Id_Predm) FROM USP
```
3. Допускается использование агрегатных функций с аргументами, которые состоят из выражений, включающих одно или более полей, при этом команда DISTINCT не разрешается.
Пример. Найти максимальную величину проиндексированной стипендии.
```sql
SELECT MAX (STIP*2) FROM USP;
```
4. Нельзя использовать агрегатную функцию от агрегатной функции.
В списке возвращаемых столбцов нельзя одновременно указывать агрегатные функции и простые имена столбцов. Такой запрос не имеет смысла.
```sql
SELECT Id_Stud, MIN (OCENKA) FROM USP;
```
Так как первый столбец создает таблицу, а второй возвратит только одно значение, то это вызовет ошибку.
5. Предложение GROUP BY позволяет определять подмножество значений в поле в терминах другого поля, и применять функцию агрегата к такому подмножеству. Это дает возможность объединять поля и агрегатные функции в едином предложении SELECT.

Пример. Определить наименьшую оценку полученную каждым студентом.
```sql
SELECT Id_Stud, MIN (OCENKA) FROM USP GROUP BY Id_Stud;
```
Пример. Определить наименьшую оценку полученную каждым студентом за каждый день.
```sql
SELECT Id_Stud, DATE, MIN (OCENKA) FROM USP GROUP BY Id_Stud, DATE;
```
Пример. Определить наименьшую оценку полученную каждым студентом за каждый день меньшую 4.
```sql
SELECT Id_Stud, DATE, MIN (OCENKA) FROM USP
GROUP BY Id_Stud, DATE	HAVING MIN (OCENKA) <4;
```
Аргументы в предложении HAVING должны иметь одно значение на группу вывода. Поэтому следующая команда будет запрещена:
```sql
SELECT Id_Stud, MIN (OCENKA)	FROM USP
GROUP BY Id_Stud HAVING DATE= 06/03/2006;
```
Правильный способ сделать рассмотренный запрос следующий: 
```sql
SELECT Id_Stud, MIN (OCENKA) FROM USP
WHERE DATE= 06/03/2006 GROUP BY Id_Stud;
```
Особенности работы агрегатных функций с полями со значением
NULL:

1. Если какие либо из значений содержащихся в столбце, равны NULL, при вычислении результата функции они исключаются!
2. Если все значения в столбце равны NULL, то функции AVG(), SUM(), MIN(), MAX() возвращают значения NULL! Функция COUNT() возвращает ноль!
3. Если в столбце нет значений (т.е. столбец пуст), то функции AVG(), SUM(), MIN(), MAX() возвращают значения NULL! Функция COUNT() возвращает ноль!
4. Функция COUNT(\*) подсчитывает количество строк и не зависит от наличия или отсутствия в столбце значений NULL! Если строк в столбце нет, то эта функция возвращает ноль!

Особенности при работе с агрегатными функциями и DISTINCT.

1. Если используется DISTINCT и агрегатная функция, то ее аргументом может быть только имя столбца, выражение не может быть аргументом.
2. В функциях MIN(), MAX() так же нет смысла использовать DISTINCT! В функции COUNT() в принципе можно использовать DISTINCT, но это требуется не часто.
3. А вот к функции COUNT(\*) вообще не применимо DISTINCT,
так как она просто подсчитывает число строк!
4. Так же в одном запросе DISTINCT можно употреблять только один раз! Если оно применяется с аргументом агрегатной функции, его уже нельзя использовать ни с одним другим аргументом!

### Системные функции и функции метаданных

Системные	функции	и	функции	метаданных	(таблица 10.4) возвращают информацию об SQL Server и хранящихся в нем данных.

Таблица 10.4 – Некоторые из системных функций и функций метаданных

| CASE           | Выполняет сравнение                                                     |
|----------------|-------------------------------------------------------------------------|
| CONVERT и CAST | Преобразует один тип данных в другой (например, целые числа в символы). |
| CURRENT_USER   | Возвращает имя текущего пользователя, который запустил SQL Server.      |
| ISDATE         | Указывает, представляют ли входные данные функции реальную дату.        |
| ISNULL         | Заменяет любое пустое значение заданным для замены.                     |
| ISNUMERIC      | Указывает, представляют ли входные данные функции числом.               |

### Функции даты и времени

В таблице 10.5 перечислены основные функции даты и времени MS SQL Server.

Таблица 10.5 – Функции даты и времени

| DATEADD    | Добавляет к дате некоторую величину.                                                                                                         |          
|------------|----------------------------------------|
| DATEIFF    | Выводит количество единиц времени, заданных в аргументе datepart, между двумя датами.                                                        |         
| DATENAME   | Возвращает текстовые имена (например, Tuesday), соответствующие заданной дате                                                                |         
| DATEPART   | Извлекает определенный заданной даты.                                                                                                         фрагмент  из |
| DAY        | Извлекает день из даты.                                                                                                                      |         
| GETDATE    | Возвращает текущее время и дату.                                                                                                             |       
| GETUTCDATE | Возвращает текущую дату                                                                                                                      и время  по Гринвичу (GMT – Greenwich Mean Time), преобразованное в формат универсального синхронизированного времени (UTC – Universal Time Coordinate). |    
| MONTH      | Извлекает месяц из даты.                                                                                                                     |   
| YEAR       | Извлекает год из даты.                                                                                                                       | 

Некоторые из функций даты и времени используют аргумент datepart, определяющий фрагмент, к которому применяется операция.

Пример. Функция DATEADD принимает в качестве аргументов маркер datepart, величину приращения и исходную дату. Она возвращает результат добавления указанной величины в единицах, указанных в аргументе datepart, к текущей дате.
```sql
// Добавить к текущей дате три дня
PRINT DATEADD(d, 3, GETDATE())
```
В таблице 10.6 перечислены константы аргумента datepart.

Таблица 10.6 – Константы аргумента datepart

| yy или y  | Год                  |
|-----------|----------------------|
| gg или g  | Квартал              |
| mm или m  | Месяц                |
| wk или ww | Неделя               |
| dw или w  | День недели          |
| dy или y  | День года (1 из 366) |
| dd или d  | День                 |
| hh        | Час                  |
| mi или n  | Минута               |
| ss или s  | Секунда              |
| ms        | Миллисекунда         |

### Строковые функций

В таблице 10.7 перечислены основные строковые функции MS SQL Server.

Таблица 10.7 – Некоторые строковые функций

| LEFT      | Отбирает символы из левого конца строки, функция LEFT(‘abcdefg’, 4) возвратит строку abcd.                                  |
|-----------|-----------------------------------------------------------------------------------------------------------------------------|
| LEN       | Возвращает длину символьной строки.                                                                                         |
| LOWER     | Преобразует строку в нижний регистр.                                                                                        |
| LTRIM     | Удаляет начальные пробелы из строки.                                                                                        |
| REPLACE   | Заменяет заданные фрагменты строки другой строкой, функция                                                                  |
|           | REPLACE(‘abc’,’b’,’e’) возвратит строку aec.                                                                                |
| RIHGT     | Отбирает символы из правого конца строки.                                                                                   |
| RTRIM     | Удаляет конечные пробелы из строки.                                                                                         |
| SUBSTRING | Возвращает заданное количество символов после заданной точки в строке, функция SUBSTRING(‘abcde’,2,3) возвратит строку bcd. |
| UPPER     | Преобразует строку в верхний регистр.                                                                                       |
| \+        | Операция конкатенации строк.                                                                                                |

Пример. Отбор записей по значениям символьного поля. 
```sql
SELECT * FROM Group WHERE Dol =’студент’;
```
В данном примере составляется список студентов группы.

В операции сравнения учитывается регистр символов, поэтому слова ‘Студент’, ‘СТУДЕНТ’ и ‘студент’ не равны друг другу, а также начальные и конечные пробелы. Поэтому различия в регистре символов должности, а также наличие пробелов в начале и в конце строки приводят к ошибкам при отборе записей. В данной ситуации критерий отбора лучше записать в следующем виде:
```sql
WHERE UPPER(TRIM(Dol)) = ’СТУДЕНТ’;
```
Если преобразование выполнить не возможно, то пользователь получает сообщение об ошибке и SQL-оператор не выполняется.

Пример. Задание вычисляемого поля –
```sql
SELECT "-" || Fam As Фамилия, Okl, Okl*2 FROM Group;
```
Выводятся старые значения окладов сотрудников и новые, увеличенные на 100%. К каждой фамилии с помощью операции конкатенации (||) добавляется символ ”-”. Заголовки таблицы – Фамилия, Okl, Okl\*2.

## Контрольные вопросы

1. Каковы основные способы объединения таблиц в запросе?
2. Каковы особенности использования предложения UNION?
3. Каковы особенности внутреннего объединения таблиц в запросе?
4. Каковы особенности самосоединения таблиц в запросе?
5. Какие виды объединения реализует предложение JOIN?
6. Какие виды внешнего объединения реализует предложение
JOIN?
7. Какие существуют типы SQL-функции?
8. Какие существуют категории SQL-функции?
9. Какие SQL-функции относятся к агрегатным?
10. Каковы	особенности	запросов	с	агрегатными	SQL-
функциями?
11. Какие SQL-функции относятся к скалярным?
